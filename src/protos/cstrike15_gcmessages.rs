// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cstrike15_gcmessages.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct GameServerPing {
    // message fields
    ping: ::std::option::Option<i32>,
    ip: ::std::option::Option<u32>,
    instances: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GameServerPing {
    fn default() -> &'a GameServerPing {
        <GameServerPing as ::protobuf::Message>::default_instance()
    }
}

impl GameServerPing {
    pub fn new() -> GameServerPing {
        ::std::default::Default::default()
    }

    // optional int32 ping = 2;


    pub fn get_ping(&self) -> i32 {
        self.ping.unwrap_or(0)
    }
    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: i32) {
        self.ping = ::std::option::Option::Some(v);
    }

    // optional uint32 ip = 3;


    pub fn get_ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }
    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional uint32 instances = 5;


    pub fn get_instances(&self) -> u32 {
        self.instances.unwrap_or(0)
    }
    pub fn clear_instances(&mut self) {
        self.instances = ::std::option::Option::None;
    }

    pub fn has_instances(&self) -> bool {
        self.instances.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instances(&mut self, v: u32) {
        self.instances = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GameServerPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ping = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ip = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.instances = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.instances {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ping {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.instances {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GameServerPing {
        GameServerPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ping",
                    |m: &GameServerPing| { &m.ping },
                    |m: &mut GameServerPing| { &mut m.ping },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ip",
                    |m: &GameServerPing| { &m.ip },
                    |m: &mut GameServerPing| { &mut m.ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "instances",
                    |m: &GameServerPing| { &m.instances },
                    |m: &mut GameServerPing| { &mut m.instances },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GameServerPing>(
                    "GameServerPing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GameServerPing {
        static mut instance: ::protobuf::lazy::Lazy<GameServerPing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GameServerPing,
        };
        unsafe {
            instance.get(GameServerPing::new)
        }
    }
}

impl ::protobuf::Clear for GameServerPing {
    fn clear(&mut self) {
        self.ping = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.instances = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GameServerPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameServerPing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataCenterPing {
    // message fields
    data_center_id: ::std::option::Option<u32>,
    ping: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataCenterPing {
    fn default() -> &'a DataCenterPing {
        <DataCenterPing as ::protobuf::Message>::default_instance()
    }
}

impl DataCenterPing {
    pub fn new() -> DataCenterPing {
        ::std::default::Default::default()
    }

    // optional fixed32 data_center_id = 1;


    pub fn get_data_center_id(&self) -> u32 {
        self.data_center_id.unwrap_or(0)
    }
    pub fn clear_data_center_id(&mut self) {
        self.data_center_id = ::std::option::Option::None;
    }

    pub fn has_data_center_id(&self) -> bool {
        self.data_center_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_center_id(&mut self, v: u32) {
        self.data_center_id = ::std::option::Option::Some(v);
    }

    // optional sint32 ping = 2;


    pub fn get_ping(&self) -> i32 {
        self.ping.unwrap_or(0)
    }
    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: i32) {
        self.ping = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DataCenterPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.data_center_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.ping = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_center_id {
            my_size += 5;
        }
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_center_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.ping {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataCenterPing {
        DataCenterPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "data_center_id",
                    |m: &DataCenterPing| { &m.data_center_id },
                    |m: &mut DataCenterPing| { &mut m.data_center_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "ping",
                    |m: &DataCenterPing| { &m.ping },
                    |m: &mut DataCenterPing| { &mut m.ping },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataCenterPing>(
                    "DataCenterPing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataCenterPing {
        static mut instance: ::protobuf::lazy::Lazy<DataCenterPing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataCenterPing,
        };
        unsafe {
            instance.get(DataCenterPing::new)
        }
    }
}

impl ::protobuf::Clear for DataCenterPing {
    fn clear(&mut self) {
        self.data_center_id = ::std::option::Option::None;
        self.ping = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataCenterPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataCenterPing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DetailedSearchStatistic {
    // message fields
    game_type: ::std::option::Option<u32>,
    search_time_avg: ::std::option::Option<u32>,
    players_searching: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DetailedSearchStatistic {
    fn default() -> &'a DetailedSearchStatistic {
        <DetailedSearchStatistic as ::protobuf::Message>::default_instance()
    }
}

impl DetailedSearchStatistic {
    pub fn new() -> DetailedSearchStatistic {
        ::std::default::Default::default()
    }

    // optional uint32 game_type = 1;


    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }
    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional uint32 search_time_avg = 2;


    pub fn get_search_time_avg(&self) -> u32 {
        self.search_time_avg.unwrap_or(0)
    }
    pub fn clear_search_time_avg(&mut self) {
        self.search_time_avg = ::std::option::Option::None;
    }

    pub fn has_search_time_avg(&self) -> bool {
        self.search_time_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_time_avg(&mut self, v: u32) {
        self.search_time_avg = ::std::option::Option::Some(v);
    }

    // optional uint32 players_searching = 4;


    pub fn get_players_searching(&self) -> u32 {
        self.players_searching.unwrap_or(0)
    }
    pub fn clear_players_searching(&mut self) {
        self.players_searching = ::std::option::Option::None;
    }

    pub fn has_players_searching(&self) -> bool {
        self.players_searching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_searching(&mut self, v: u32) {
        self.players_searching = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DetailedSearchStatistic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.search_time_avg = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.players_searching = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.search_time_avg {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.players_searching {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.search_time_avg {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.players_searching {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DetailedSearchStatistic {
        DetailedSearchStatistic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    |m: &DetailedSearchStatistic| { &m.game_type },
                    |m: &mut DetailedSearchStatistic| { &mut m.game_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "search_time_avg",
                    |m: &DetailedSearchStatistic| { &m.search_time_avg },
                    |m: &mut DetailedSearchStatistic| { &mut m.search_time_avg },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "players_searching",
                    |m: &DetailedSearchStatistic| { &m.players_searching },
                    |m: &mut DetailedSearchStatistic| { &mut m.players_searching },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DetailedSearchStatistic>(
                    "DetailedSearchStatistic",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DetailedSearchStatistic {
        static mut instance: ::protobuf::lazy::Lazy<DetailedSearchStatistic> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DetailedSearchStatistic,
        };
        unsafe {
            instance.get(DetailedSearchStatistic::new)
        }
    }
}

impl ::protobuf::Clear for DetailedSearchStatistic {
    fn clear(&mut self) {
        self.game_type = ::std::option::Option::None;
        self.search_time_avg = ::std::option::Option::None;
        self.players_searching = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DetailedSearchStatistic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetailedSearchStatistic {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TournamentPlayer {
    // message fields
    account_id: ::std::option::Option<u32>,
    player_nick: ::protobuf::SingularField<::std::string::String>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    player_dob: ::std::option::Option<u32>,
    player_flag: ::protobuf::SingularField<::std::string::String>,
    player_location: ::protobuf::SingularField<::std::string::String>,
    player_desc: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TournamentPlayer {
    fn default() -> &'a TournamentPlayer {
        <TournamentPlayer as ::protobuf::Message>::default_instance()
    }
}

impl TournamentPlayer {
    pub fn new() -> TournamentPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string player_nick = 2;


    pub fn get_player_nick(&self) -> &str {
        match self.player_nick.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_nick(&mut self) {
        self.player_nick.clear();
    }

    pub fn has_player_nick(&self) -> bool {
        self.player_nick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_nick(&mut self, v: ::std::string::String) {
        self.player_nick = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_nick(&mut self) -> &mut ::std::string::String {
        if self.player_nick.is_none() {
            self.player_nick.set_default();
        }
        self.player_nick.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_nick(&mut self) -> ::std::string::String {
        self.player_nick.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string player_name = 3;


    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 player_dob = 4;


    pub fn get_player_dob(&self) -> u32 {
        self.player_dob.unwrap_or(0)
    }
    pub fn clear_player_dob(&mut self) {
        self.player_dob = ::std::option::Option::None;
    }

    pub fn has_player_dob(&self) -> bool {
        self.player_dob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_dob(&mut self, v: u32) {
        self.player_dob = ::std::option::Option::Some(v);
    }

    // optional string player_flag = 5;


    pub fn get_player_flag(&self) -> &str {
        match self.player_flag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_flag(&mut self) {
        self.player_flag.clear();
    }

    pub fn has_player_flag(&self) -> bool {
        self.player_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_flag(&mut self, v: ::std::string::String) {
        self.player_flag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_flag(&mut self) -> &mut ::std::string::String {
        if self.player_flag.is_none() {
            self.player_flag.set_default();
        }
        self.player_flag.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_flag(&mut self) -> ::std::string::String {
        self.player_flag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string player_location = 6;


    pub fn get_player_location(&self) -> &str {
        match self.player_location.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_location(&mut self) {
        self.player_location.clear();
    }

    pub fn has_player_location(&self) -> bool {
        self.player_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_location(&mut self, v: ::std::string::String) {
        self.player_location = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_location(&mut self) -> &mut ::std::string::String {
        if self.player_location.is_none() {
            self.player_location.set_default();
        }
        self.player_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_location(&mut self) -> ::std::string::String {
        self.player_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string player_desc = 7;


    pub fn get_player_desc(&self) -> &str {
        match self.player_desc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_desc(&mut self) {
        self.player_desc.clear();
    }

    pub fn has_player_desc(&self) -> bool {
        self.player_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_desc(&mut self, v: ::std::string::String) {
        self.player_desc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_desc(&mut self) -> &mut ::std::string::String {
        if self.player_desc.is_none() {
            self.player_desc.set_default();
        }
        self.player_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_desc(&mut self) -> ::std::string::String {
        self.player_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TournamentPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_nick)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_dob = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_flag)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_location)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_desc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_nick.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.player_dob {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_flag.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.player_location.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.player_desc.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.player_nick.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.player_dob {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.player_flag.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.player_location.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.player_desc.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TournamentPlayer {
        TournamentPlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &TournamentPlayer| { &m.account_id },
                    |m: &mut TournamentPlayer| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_nick",
                    |m: &TournamentPlayer| { &m.player_nick },
                    |m: &mut TournamentPlayer| { &mut m.player_nick },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_name",
                    |m: &TournamentPlayer| { &m.player_name },
                    |m: &mut TournamentPlayer| { &mut m.player_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_dob",
                    |m: &TournamentPlayer| { &m.player_dob },
                    |m: &mut TournamentPlayer| { &mut m.player_dob },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_flag",
                    |m: &TournamentPlayer| { &m.player_flag },
                    |m: &mut TournamentPlayer| { &mut m.player_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_location",
                    |m: &TournamentPlayer| { &m.player_location },
                    |m: &mut TournamentPlayer| { &mut m.player_location },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_desc",
                    |m: &TournamentPlayer| { &m.player_desc },
                    |m: &mut TournamentPlayer| { &mut m.player_desc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TournamentPlayer>(
                    "TournamentPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TournamentPlayer {
        static mut instance: ::protobuf::lazy::Lazy<TournamentPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TournamentPlayer,
        };
        unsafe {
            instance.get(TournamentPlayer::new)
        }
    }
}

impl ::protobuf::Clear for TournamentPlayer {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.player_nick.clear();
        self.player_name.clear();
        self.player_dob = ::std::option::Option::None;
        self.player_flag.clear();
        self.player_location.clear();
        self.player_desc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TournamentPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TournamentTeam {
    // message fields
    team_id: ::std::option::Option<i32>,
    team_tag: ::protobuf::SingularField<::std::string::String>,
    team_flag: ::protobuf::SingularField<::std::string::String>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    players: ::protobuf::RepeatedField<TournamentPlayer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TournamentTeam {
    fn default() -> &'a TournamentTeam {
        <TournamentTeam as ::protobuf::Message>::default_instance()
    }
}

impl TournamentTeam {
    pub fn new() -> TournamentTeam {
        ::std::default::Default::default()
    }

    // optional int32 team_id = 1;


    pub fn get_team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }
    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional string team_tag = 2;


    pub fn get_team_tag(&self) -> &str {
        match self.team_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_team_tag(&mut self) {
        self.team_tag.clear();
    }

    pub fn has_team_tag(&self) -> bool {
        self.team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_tag(&mut self, v: ::std::string::String) {
        self.team_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
        if self.team_tag.is_none() {
            self.team_tag.set_default();
        }
        self.team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_tag(&mut self) -> ::std::string::String {
        self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string team_flag = 3;


    pub fn get_team_flag(&self) -> &str {
        match self.team_flag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_team_flag(&mut self) {
        self.team_flag.clear();
    }

    pub fn has_team_flag(&self) -> bool {
        self.team_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_flag(&mut self, v: ::std::string::String) {
        self.team_flag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_flag(&mut self) -> &mut ::std::string::String {
        if self.team_flag.is_none() {
            self.team_flag.set_default();
        }
        self.team_flag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_flag(&mut self) -> ::std::string::String {
        self.team_flag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string team_name = 4;


    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .TournamentPlayer players = 5;


    pub fn get_players(&self) -> &[TournamentPlayer] {
        &self.players
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<TournamentPlayer>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<TournamentPlayer> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<TournamentPlayer> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TournamentTeam {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_tag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_flag)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.team_flag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.team_tag.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.team_flag.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.players {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TournamentTeam {
        TournamentTeam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id",
                    |m: &TournamentTeam| { &m.team_id },
                    |m: &mut TournamentTeam| { &mut m.team_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_tag",
                    |m: &TournamentTeam| { &m.team_tag },
                    |m: &mut TournamentTeam| { &mut m.team_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_flag",
                    |m: &TournamentTeam| { &m.team_flag },
                    |m: &mut TournamentTeam| { &mut m.team_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    |m: &TournamentTeam| { &m.team_name },
                    |m: &mut TournamentTeam| { &mut m.team_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentPlayer>>(
                    "players",
                    |m: &TournamentTeam| { &m.players },
                    |m: &mut TournamentTeam| { &mut m.players },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TournamentTeam>(
                    "TournamentTeam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TournamentTeam {
        static mut instance: ::protobuf::lazy::Lazy<TournamentTeam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TournamentTeam,
        };
        unsafe {
            instance.get(TournamentTeam::new)
        }
    }
}

impl ::protobuf::Clear for TournamentTeam {
    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.team_tag.clear();
        self.team_flag.clear();
        self.team_name.clear();
        self.players.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TournamentTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentTeam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TournamentEvent {
    // message fields
    event_id: ::std::option::Option<i32>,
    event_tag: ::protobuf::SingularField<::std::string::String>,
    event_name: ::protobuf::SingularField<::std::string::String>,
    event_time_start: ::std::option::Option<u32>,
    event_time_end: ::std::option::Option<u32>,
    event_public: ::std::option::Option<i32>,
    event_stage_id: ::std::option::Option<i32>,
    event_stage_name: ::protobuf::SingularField<::std::string::String>,
    active_section_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TournamentEvent {
    fn default() -> &'a TournamentEvent {
        <TournamentEvent as ::protobuf::Message>::default_instance()
    }
}

impl TournamentEvent {
    pub fn new() -> TournamentEvent {
        ::std::default::Default::default()
    }

    // optional int32 event_id = 1;


    pub fn get_event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional string event_tag = 2;


    pub fn get_event_tag(&self) -> &str {
        match self.event_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_event_tag(&mut self) {
        self.event_tag.clear();
    }

    pub fn has_event_tag(&self) -> bool {
        self.event_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_tag(&mut self, v: ::std::string::String) {
        self.event_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_tag(&mut self) -> &mut ::std::string::String {
        if self.event_tag.is_none() {
            self.event_tag.set_default();
        }
        self.event_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_tag(&mut self) -> ::std::string::String {
        self.event_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string event_name = 3;


    pub fn get_event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_event_name(&mut self) {
        self.event_name.clear();
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name.set_default();
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 event_time_start = 4;


    pub fn get_event_time_start(&self) -> u32 {
        self.event_time_start.unwrap_or(0)
    }
    pub fn clear_event_time_start(&mut self) {
        self.event_time_start = ::std::option::Option::None;
    }

    pub fn has_event_time_start(&self) -> bool {
        self.event_time_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time_start(&mut self, v: u32) {
        self.event_time_start = ::std::option::Option::Some(v);
    }

    // optional uint32 event_time_end = 5;


    pub fn get_event_time_end(&self) -> u32 {
        self.event_time_end.unwrap_or(0)
    }
    pub fn clear_event_time_end(&mut self) {
        self.event_time_end = ::std::option::Option::None;
    }

    pub fn has_event_time_end(&self) -> bool {
        self.event_time_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time_end(&mut self, v: u32) {
        self.event_time_end = ::std::option::Option::Some(v);
    }

    // optional int32 event_public = 6;


    pub fn get_event_public(&self) -> i32 {
        self.event_public.unwrap_or(0)
    }
    pub fn clear_event_public(&mut self) {
        self.event_public = ::std::option::Option::None;
    }

    pub fn has_event_public(&self) -> bool {
        self.event_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_public(&mut self, v: i32) {
        self.event_public = ::std::option::Option::Some(v);
    }

    // optional int32 event_stage_id = 7;


    pub fn get_event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }
    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    // optional string event_stage_name = 8;


    pub fn get_event_stage_name(&self) -> &str {
        match self.event_stage_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_event_stage_name(&mut self) {
        self.event_stage_name.clear();
    }

    pub fn has_event_stage_name(&self) -> bool {
        self.event_stage_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_name(&mut self, v: ::std::string::String) {
        self.event_stage_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stage_name(&mut self) -> &mut ::std::string::String {
        if self.event_stage_name.is_none() {
            self.event_stage_name.set_default();
        }
        self.event_stage_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stage_name(&mut self) -> ::std::string::String {
        self.event_stage_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 active_section_id = 9;


    pub fn get_active_section_id(&self) -> u32 {
        self.active_section_id.unwrap_or(0)
    }
    pub fn clear_active_section_id(&mut self) {
        self.active_section_id = ::std::option::Option::None;
    }

    pub fn has_active_section_id(&self) -> bool {
        self.active_section_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_section_id(&mut self, v: u32) {
        self.active_section_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TournamentEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.event_tag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.event_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_time_start = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_time_end = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_public = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_stage_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.event_stage_name)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_section_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.event_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.event_time_start {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_time_end {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_public {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.event_stage_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.active_section_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.event_tag.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.event_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.event_time_start {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_time_end {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.event_public {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(7, v)?;
        }
        if let Some(ref v) = self.event_stage_name.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.active_section_id {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TournamentEvent {
        TournamentEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_id",
                    |m: &TournamentEvent| { &m.event_id },
                    |m: &mut TournamentEvent| { &mut m.event_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "event_tag",
                    |m: &TournamentEvent| { &m.event_tag },
                    |m: &mut TournamentEvent| { &mut m.event_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "event_name",
                    |m: &TournamentEvent| { &m.event_name },
                    |m: &mut TournamentEvent| { &mut m.event_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_time_start",
                    |m: &TournamentEvent| { &m.event_time_start },
                    |m: &mut TournamentEvent| { &mut m.event_time_start },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_time_end",
                    |m: &TournamentEvent| { &m.event_time_end },
                    |m: &mut TournamentEvent| { &mut m.event_time_end },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_public",
                    |m: &TournamentEvent| { &m.event_public },
                    |m: &mut TournamentEvent| { &mut m.event_public },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_stage_id",
                    |m: &TournamentEvent| { &m.event_stage_id },
                    |m: &mut TournamentEvent| { &mut m.event_stage_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "event_stage_name",
                    |m: &TournamentEvent| { &m.event_stage_name },
                    |m: &mut TournamentEvent| { &mut m.event_stage_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_section_id",
                    |m: &TournamentEvent| { &m.active_section_id },
                    |m: &mut TournamentEvent| { &mut m.active_section_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TournamentEvent>(
                    "TournamentEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TournamentEvent {
        static mut instance: ::protobuf::lazy::Lazy<TournamentEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TournamentEvent,
        };
        unsafe {
            instance.get(TournamentEvent::new)
        }
    }
}

impl ::protobuf::Clear for TournamentEvent {
    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.event_tag.clear();
        self.event_name.clear();
        self.event_time_start = ::std::option::Option::None;
        self.event_time_end = ::std::option::Option::None;
        self.event_public = ::std::option::Option::None;
        self.event_stage_id = ::std::option::Option::None;
        self.event_stage_name.clear();
        self.active_section_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TournamentEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalStatistics {
    // message fields
    players_online: ::std::option::Option<u32>,
    servers_online: ::std::option::Option<u32>,
    players_searching: ::std::option::Option<u32>,
    servers_available: ::std::option::Option<u32>,
    ongoing_matches: ::std::option::Option<u32>,
    search_time_avg: ::std::option::Option<u32>,
    search_statistics: ::protobuf::RepeatedField<DetailedSearchStatistic>,
    main_post_url: ::protobuf::SingularField<::std::string::String>,
    required_appid_version: ::std::option::Option<u32>,
    pricesheet_version: ::std::option::Option<u32>,
    twitch_streams_version: ::std::option::Option<u32>,
    active_tournament_eventid: ::std::option::Option<u32>,
    active_survey_id: ::std::option::Option<u32>,
    rtime32_cur: ::std::option::Option<u32>,
    rtime32_event_start: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalStatistics {
    fn default() -> &'a GlobalStatistics {
        <GlobalStatistics as ::protobuf::Message>::default_instance()
    }
}

impl GlobalStatistics {
    pub fn new() -> GlobalStatistics {
        ::std::default::Default::default()
    }

    // optional uint32 players_online = 1;


    pub fn get_players_online(&self) -> u32 {
        self.players_online.unwrap_or(0)
    }
    pub fn clear_players_online(&mut self) {
        self.players_online = ::std::option::Option::None;
    }

    pub fn has_players_online(&self) -> bool {
        self.players_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_online(&mut self, v: u32) {
        self.players_online = ::std::option::Option::Some(v);
    }

    // optional uint32 servers_online = 2;


    pub fn get_servers_online(&self) -> u32 {
        self.servers_online.unwrap_or(0)
    }
    pub fn clear_servers_online(&mut self) {
        self.servers_online = ::std::option::Option::None;
    }

    pub fn has_servers_online(&self) -> bool {
        self.servers_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servers_online(&mut self, v: u32) {
        self.servers_online = ::std::option::Option::Some(v);
    }

    // optional uint32 players_searching = 3;


    pub fn get_players_searching(&self) -> u32 {
        self.players_searching.unwrap_or(0)
    }
    pub fn clear_players_searching(&mut self) {
        self.players_searching = ::std::option::Option::None;
    }

    pub fn has_players_searching(&self) -> bool {
        self.players_searching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_searching(&mut self, v: u32) {
        self.players_searching = ::std::option::Option::Some(v);
    }

    // optional uint32 servers_available = 4;


    pub fn get_servers_available(&self) -> u32 {
        self.servers_available.unwrap_or(0)
    }
    pub fn clear_servers_available(&mut self) {
        self.servers_available = ::std::option::Option::None;
    }

    pub fn has_servers_available(&self) -> bool {
        self.servers_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servers_available(&mut self, v: u32) {
        self.servers_available = ::std::option::Option::Some(v);
    }

    // optional uint32 ongoing_matches = 5;


    pub fn get_ongoing_matches(&self) -> u32 {
        self.ongoing_matches.unwrap_or(0)
    }
    pub fn clear_ongoing_matches(&mut self) {
        self.ongoing_matches = ::std::option::Option::None;
    }

    pub fn has_ongoing_matches(&self) -> bool {
        self.ongoing_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ongoing_matches(&mut self, v: u32) {
        self.ongoing_matches = ::std::option::Option::Some(v);
    }

    // optional uint32 search_time_avg = 6;


    pub fn get_search_time_avg(&self) -> u32 {
        self.search_time_avg.unwrap_or(0)
    }
    pub fn clear_search_time_avg(&mut self) {
        self.search_time_avg = ::std::option::Option::None;
    }

    pub fn has_search_time_avg(&self) -> bool {
        self.search_time_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_time_avg(&mut self, v: u32) {
        self.search_time_avg = ::std::option::Option::Some(v);
    }

    // repeated .DetailedSearchStatistic search_statistics = 7;


    pub fn get_search_statistics(&self) -> &[DetailedSearchStatistic] {
        &self.search_statistics
    }
    pub fn clear_search_statistics(&mut self) {
        self.search_statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_search_statistics(&mut self, v: ::protobuf::RepeatedField<DetailedSearchStatistic>) {
        self.search_statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_search_statistics(&mut self) -> &mut ::protobuf::RepeatedField<DetailedSearchStatistic> {
        &mut self.search_statistics
    }

    // Take field
    pub fn take_search_statistics(&mut self) -> ::protobuf::RepeatedField<DetailedSearchStatistic> {
        ::std::mem::replace(&mut self.search_statistics, ::protobuf::RepeatedField::new())
    }

    // optional string main_post_url = 8;


    pub fn get_main_post_url(&self) -> &str {
        match self.main_post_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_main_post_url(&mut self) {
        self.main_post_url.clear();
    }

    pub fn has_main_post_url(&self) -> bool {
        self.main_post_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_post_url(&mut self, v: ::std::string::String) {
        self.main_post_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_post_url(&mut self) -> &mut ::std::string::String {
        if self.main_post_url.is_none() {
            self.main_post_url.set_default();
        }
        self.main_post_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_post_url(&mut self) -> ::std::string::String {
        self.main_post_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 required_appid_version = 9;


    pub fn get_required_appid_version(&self) -> u32 {
        self.required_appid_version.unwrap_or(0)
    }
    pub fn clear_required_appid_version(&mut self) {
        self.required_appid_version = ::std::option::Option::None;
    }

    pub fn has_required_appid_version(&self) -> bool {
        self.required_appid_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_appid_version(&mut self, v: u32) {
        self.required_appid_version = ::std::option::Option::Some(v);
    }

    // optional uint32 pricesheet_version = 10;


    pub fn get_pricesheet_version(&self) -> u32 {
        self.pricesheet_version.unwrap_or(0)
    }
    pub fn clear_pricesheet_version(&mut self) {
        self.pricesheet_version = ::std::option::Option::None;
    }

    pub fn has_pricesheet_version(&self) -> bool {
        self.pricesheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pricesheet_version(&mut self, v: u32) {
        self.pricesheet_version = ::std::option::Option::Some(v);
    }

    // optional uint32 twitch_streams_version = 11;


    pub fn get_twitch_streams_version(&self) -> u32 {
        self.twitch_streams_version.unwrap_or(0)
    }
    pub fn clear_twitch_streams_version(&mut self) {
        self.twitch_streams_version = ::std::option::Option::None;
    }

    pub fn has_twitch_streams_version(&self) -> bool {
        self.twitch_streams_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twitch_streams_version(&mut self, v: u32) {
        self.twitch_streams_version = ::std::option::Option::Some(v);
    }

    // optional uint32 active_tournament_eventid = 12;


    pub fn get_active_tournament_eventid(&self) -> u32 {
        self.active_tournament_eventid.unwrap_or(0)
    }
    pub fn clear_active_tournament_eventid(&mut self) {
        self.active_tournament_eventid = ::std::option::Option::None;
    }

    pub fn has_active_tournament_eventid(&self) -> bool {
        self.active_tournament_eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_tournament_eventid(&mut self, v: u32) {
        self.active_tournament_eventid = ::std::option::Option::Some(v);
    }

    // optional uint32 active_survey_id = 13;


    pub fn get_active_survey_id(&self) -> u32 {
        self.active_survey_id.unwrap_or(0)
    }
    pub fn clear_active_survey_id(&mut self) {
        self.active_survey_id = ::std::option::Option::None;
    }

    pub fn has_active_survey_id(&self) -> bool {
        self.active_survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_survey_id(&mut self, v: u32) {
        self.active_survey_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_cur = 14;


    pub fn get_rtime32_cur(&self) -> u32 {
        self.rtime32_cur.unwrap_or(0)
    }
    pub fn clear_rtime32_cur(&mut self) {
        self.rtime32_cur = ::std::option::Option::None;
    }

    pub fn has_rtime32_cur(&self) -> bool {
        self.rtime32_cur.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_cur(&mut self, v: u32) {
        self.rtime32_cur = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_event_start = 15;


    pub fn get_rtime32_event_start(&self) -> u32 {
        self.rtime32_event_start.unwrap_or(0)
    }
    pub fn clear_rtime32_event_start(&mut self) {
        self.rtime32_event_start = ::std::option::Option::None;
    }

    pub fn has_rtime32_event_start(&self) -> bool {
        self.rtime32_event_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_event_start(&mut self, v: u32) {
        self.rtime32_event_start = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GlobalStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.search_statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.players_online = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.servers_online = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.players_searching = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.servers_available = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ongoing_matches = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.search_time_avg = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.search_statistics)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.main_post_url)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.required_appid_version = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pricesheet_version = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.twitch_streams_version = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_tournament_eventid = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_survey_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime32_cur = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime32_event_start = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.players_online {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.servers_online {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.players_searching {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.servers_available {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ongoing_matches {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.search_time_avg {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.search_statistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.main_post_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.required_appid_version {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pricesheet_version {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.twitch_streams_version {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_tournament_eventid {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_survey_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime32_cur {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime32_event_start {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.players_online {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.servers_online {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.players_searching {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.servers_available {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ongoing_matches {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.search_time_avg {
            os.write_uint32(6, v)?;
        }
        for v in &self.search_statistics {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.main_post_url.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.required_appid_version {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.pricesheet_version {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.twitch_streams_version {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.active_tournament_eventid {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.active_survey_id {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.rtime32_cur {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.rtime32_event_start {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalStatistics {
        GlobalStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "players_online",
                    |m: &GlobalStatistics| { &m.players_online },
                    |m: &mut GlobalStatistics| { &mut m.players_online },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "servers_online",
                    |m: &GlobalStatistics| { &m.servers_online },
                    |m: &mut GlobalStatistics| { &mut m.servers_online },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "players_searching",
                    |m: &GlobalStatistics| { &m.players_searching },
                    |m: &mut GlobalStatistics| { &mut m.players_searching },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "servers_available",
                    |m: &GlobalStatistics| { &m.servers_available },
                    |m: &mut GlobalStatistics| { &mut m.servers_available },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ongoing_matches",
                    |m: &GlobalStatistics| { &m.ongoing_matches },
                    |m: &mut GlobalStatistics| { &mut m.ongoing_matches },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "search_time_avg",
                    |m: &GlobalStatistics| { &m.search_time_avg },
                    |m: &mut GlobalStatistics| { &mut m.search_time_avg },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DetailedSearchStatistic>>(
                    "search_statistics",
                    |m: &GlobalStatistics| { &m.search_statistics },
                    |m: &mut GlobalStatistics| { &mut m.search_statistics },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "main_post_url",
                    |m: &GlobalStatistics| { &m.main_post_url },
                    |m: &mut GlobalStatistics| { &mut m.main_post_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "required_appid_version",
                    |m: &GlobalStatistics| { &m.required_appid_version },
                    |m: &mut GlobalStatistics| { &mut m.required_appid_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pricesheet_version",
                    |m: &GlobalStatistics| { &m.pricesheet_version },
                    |m: &mut GlobalStatistics| { &mut m.pricesheet_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "twitch_streams_version",
                    |m: &GlobalStatistics| { &m.twitch_streams_version },
                    |m: &mut GlobalStatistics| { &mut m.twitch_streams_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_tournament_eventid",
                    |m: &GlobalStatistics| { &m.active_tournament_eventid },
                    |m: &mut GlobalStatistics| { &mut m.active_tournament_eventid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_survey_id",
                    |m: &GlobalStatistics| { &m.active_survey_id },
                    |m: &mut GlobalStatistics| { &mut m.active_survey_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rtime32_cur",
                    |m: &GlobalStatistics| { &m.rtime32_cur },
                    |m: &mut GlobalStatistics| { &mut m.rtime32_cur },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rtime32_event_start",
                    |m: &GlobalStatistics| { &m.rtime32_event_start },
                    |m: &mut GlobalStatistics| { &mut m.rtime32_event_start },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GlobalStatistics>(
                    "GlobalStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GlobalStatistics {
        static mut instance: ::protobuf::lazy::Lazy<GlobalStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GlobalStatistics,
        };
        unsafe {
            instance.get(GlobalStatistics::new)
        }
    }
}

impl ::protobuf::Clear for GlobalStatistics {
    fn clear(&mut self) {
        self.players_online = ::std::option::Option::None;
        self.servers_online = ::std::option::Option::None;
        self.players_searching = ::std::option::Option::None;
        self.servers_available = ::std::option::Option::None;
        self.ongoing_matches = ::std::option::Option::None;
        self.search_time_avg = ::std::option::Option::None;
        self.search_statistics.clear();
        self.main_post_url.clear();
        self.required_appid_version = ::std::option::Option::None;
        self.pricesheet_version = ::std::option::Option::None;
        self.twitch_streams_version = ::std::option::Option::None;
        self.active_tournament_eventid = ::std::option::Option::None;
        self.active_survey_id = ::std::option::Option::None;
        self.rtime32_cur = ::std::option::Option::None;
        self.rtime32_event_start = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationalStatisticDescription {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    idkey: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperationalStatisticDescription {
    fn default() -> &'a OperationalStatisticDescription {
        <OperationalStatisticDescription as ::protobuf::Message>::default_instance()
    }
}

impl OperationalStatisticDescription {
    pub fn new() -> OperationalStatisticDescription {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 idkey = 2;


    pub fn get_idkey(&self) -> u32 {
        self.idkey.unwrap_or(0)
    }
    pub fn clear_idkey(&mut self) {
        self.idkey = ::std::option::Option::None;
    }

    pub fn has_idkey(&self) -> bool {
        self.idkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idkey(&mut self, v: u32) {
        self.idkey = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OperationalStatisticDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.idkey = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.idkey {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.idkey {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationalStatisticDescription {
        OperationalStatisticDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &OperationalStatisticDescription| { &m.name },
                    |m: &mut OperationalStatisticDescription| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "idkey",
                    |m: &OperationalStatisticDescription| { &m.idkey },
                    |m: &mut OperationalStatisticDescription| { &mut m.idkey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationalStatisticDescription>(
                    "OperationalStatisticDescription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperationalStatisticDescription {
        static mut instance: ::protobuf::lazy::Lazy<OperationalStatisticDescription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationalStatisticDescription,
        };
        unsafe {
            instance.get(OperationalStatisticDescription::new)
        }
    }
}

impl ::protobuf::Clear for OperationalStatisticDescription {
    fn clear(&mut self) {
        self.name.clear();
        self.idkey = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationalStatisticDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationalStatisticElement {
    // message fields
    idkey: ::std::option::Option<u32>,
    values: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperationalStatisticElement {
    fn default() -> &'a OperationalStatisticElement {
        <OperationalStatisticElement as ::protobuf::Message>::default_instance()
    }
}

impl OperationalStatisticElement {
    pub fn new() -> OperationalStatisticElement {
        ::std::default::Default::default()
    }

    // optional uint32 idkey = 1;


    pub fn get_idkey(&self) -> u32 {
        self.idkey.unwrap_or(0)
    }
    pub fn clear_idkey(&mut self) {
        self.idkey = ::std::option::Option::None;
    }

    pub fn has_idkey(&self) -> bool {
        self.idkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idkey(&mut self, v: u32) {
        self.idkey = ::std::option::Option::Some(v);
    }

    // repeated int32 values = 2;


    pub fn get_values(&self) -> &[i32] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<i32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OperationalStatisticElement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.idkey = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.idkey {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.idkey {
            os.write_uint32(1, v)?;
        }
        for v in &self.values {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationalStatisticElement {
        OperationalStatisticElement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "idkey",
                    |m: &OperationalStatisticElement| { &m.idkey },
                    |m: &mut OperationalStatisticElement| { &mut m.idkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "values",
                    |m: &OperationalStatisticElement| { &m.values },
                    |m: &mut OperationalStatisticElement| { &mut m.values },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationalStatisticElement>(
                    "OperationalStatisticElement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperationalStatisticElement {
        static mut instance: ::protobuf::lazy::Lazy<OperationalStatisticElement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationalStatisticElement,
        };
        unsafe {
            instance.get(OperationalStatisticElement::new)
        }
    }
}

impl ::protobuf::Clear for OperationalStatisticElement {
    fn clear(&mut self) {
        self.idkey = ::std::option::Option::None;
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationalStatisticElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticElement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationalStatisticsPacket {
    // message fields
    packetid: ::std::option::Option<i32>,
    mstimestamp: ::std::option::Option<i32>,
    values: ::protobuf::RepeatedField<OperationalStatisticElement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperationalStatisticsPacket {
    fn default() -> &'a OperationalStatisticsPacket {
        <OperationalStatisticsPacket as ::protobuf::Message>::default_instance()
    }
}

impl OperationalStatisticsPacket {
    pub fn new() -> OperationalStatisticsPacket {
        ::std::default::Default::default()
    }

    // optional int32 packetid = 1;


    pub fn get_packetid(&self) -> i32 {
        self.packetid.unwrap_or(0)
    }
    pub fn clear_packetid(&mut self) {
        self.packetid = ::std::option::Option::None;
    }

    pub fn has_packetid(&self) -> bool {
        self.packetid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packetid(&mut self, v: i32) {
        self.packetid = ::std::option::Option::Some(v);
    }

    // optional int32 mstimestamp = 2;


    pub fn get_mstimestamp(&self) -> i32 {
        self.mstimestamp.unwrap_or(0)
    }
    pub fn clear_mstimestamp(&mut self) {
        self.mstimestamp = ::std::option::Option::None;
    }

    pub fn has_mstimestamp(&self) -> bool {
        self.mstimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mstimestamp(&mut self, v: i32) {
        self.mstimestamp = ::std::option::Option::Some(v);
    }

    // repeated .OperationalStatisticElement values = 3;


    pub fn get_values(&self) -> &[OperationalStatisticElement] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<OperationalStatisticElement>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<OperationalStatisticElement> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<OperationalStatisticElement> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OperationalStatisticsPacket {
    fn is_initialized(&self) -> bool {
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.packetid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mstimestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packetid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mstimestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packetid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mstimestamp {
            os.write_int32(2, v)?;
        }
        for v in &self.values {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationalStatisticsPacket {
        OperationalStatisticsPacket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "packetid",
                    |m: &OperationalStatisticsPacket| { &m.packetid },
                    |m: &mut OperationalStatisticsPacket| { &mut m.packetid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mstimestamp",
                    |m: &OperationalStatisticsPacket| { &m.mstimestamp },
                    |m: &mut OperationalStatisticsPacket| { &mut m.mstimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationalStatisticElement>>(
                    "values",
                    |m: &OperationalStatisticsPacket| { &m.values },
                    |m: &mut OperationalStatisticsPacket| { &mut m.values },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationalStatisticsPacket>(
                    "OperationalStatisticsPacket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperationalStatisticsPacket {
        static mut instance: ::protobuf::lazy::Lazy<OperationalStatisticsPacket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationalStatisticsPacket,
        };
        unsafe {
            instance.get(OperationalStatisticsPacket::new)
        }
    }
}

impl ::protobuf::Clear for OperationalStatisticsPacket {
    fn clear(&mut self) {
        self.packetid = ::std::option::Option::None;
        self.mstimestamp = ::std::option::Option::None;
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationalStatisticsPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticsPacket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerRankingInfo {
    // message fields
    account_id: ::std::option::Option<u32>,
    rank_id: ::std::option::Option<u32>,
    wins: ::std::option::Option<u32>,
    rank_change: ::std::option::Option<f32>,
    rank_type_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerRankingInfo {
    fn default() -> &'a PlayerRankingInfo {
        <PlayerRankingInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerRankingInfo {
    pub fn new() -> PlayerRankingInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_id = 2;


    pub fn get_rank_id(&self) -> u32 {
        self.rank_id.unwrap_or(0)
    }
    pub fn clear_rank_id(&mut self) {
        self.rank_id = ::std::option::Option::None;
    }

    pub fn has_rank_id(&self) -> bool {
        self.rank_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_id(&mut self, v: u32) {
        self.rank_id = ::std::option::Option::Some(v);
    }

    // optional uint32 wins = 3;


    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }
    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    // optional float rank_change = 4;


    pub fn get_rank_change(&self) -> f32 {
        self.rank_change.unwrap_or(0.)
    }
    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: f32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_type_id = 6;


    pub fn get_rank_type_id(&self) -> u32 {
        self.rank_type_id.unwrap_or(0)
    }
    pub fn clear_rank_type_id(&mut self) {
        self.rank_type_id = ::std::option::Option::None;
    }

    pub fn has_rank_type_id(&self) -> bool {
        self.rank_type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_type_id(&mut self, v: u32) {
        self.rank_type_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlayerRankingInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rank_change = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank_type_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_change {
            my_size += 5;
        }
        if let Some(v) = self.rank_type_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rank_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.rank_type_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerRankingInfo {
        PlayerRankingInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &PlayerRankingInfo| { &m.account_id },
                    |m: &mut PlayerRankingInfo| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank_id",
                    |m: &PlayerRankingInfo| { &m.rank_id },
                    |m: &mut PlayerRankingInfo| { &mut m.rank_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    |m: &PlayerRankingInfo| { &m.wins },
                    |m: &mut PlayerRankingInfo| { &mut m.wins },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rank_change",
                    |m: &PlayerRankingInfo| { &m.rank_change },
                    |m: &mut PlayerRankingInfo| { &mut m.rank_change },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank_type_id",
                    |m: &PlayerRankingInfo| { &m.rank_type_id },
                    |m: &mut PlayerRankingInfo| { &mut m.rank_type_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerRankingInfo>(
                    "PlayerRankingInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlayerRankingInfo {
        static mut instance: ::protobuf::lazy::Lazy<PlayerRankingInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerRankingInfo,
        };
        unsafe {
            instance.get(PlayerRankingInfo::new)
        }
    }
}

impl ::protobuf::Clear for PlayerRankingInfo {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rank_id = ::std::option::Option::None;
        self.wins = ::std::option::Option::None;
        self.rank_change = ::std::option::Option::None;
        self.rank_type_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerRankingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerRankingInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerCommendationInfo {
    // message fields
    cmd_friendly: ::std::option::Option<u32>,
    cmd_teaching: ::std::option::Option<u32>,
    cmd_leader: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerCommendationInfo {
    fn default() -> &'a PlayerCommendationInfo {
        <PlayerCommendationInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerCommendationInfo {
    pub fn new() -> PlayerCommendationInfo {
        ::std::default::Default::default()
    }

    // optional uint32 cmd_friendly = 1;


    pub fn get_cmd_friendly(&self) -> u32 {
        self.cmd_friendly.unwrap_or(0)
    }
    pub fn clear_cmd_friendly(&mut self) {
        self.cmd_friendly = ::std::option::Option::None;
    }

    pub fn has_cmd_friendly(&self) -> bool {
        self.cmd_friendly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_friendly(&mut self, v: u32) {
        self.cmd_friendly = ::std::option::Option::Some(v);
    }

    // optional uint32 cmd_teaching = 2;


    pub fn get_cmd_teaching(&self) -> u32 {
        self.cmd_teaching.unwrap_or(0)
    }
    pub fn clear_cmd_teaching(&mut self) {
        self.cmd_teaching = ::std::option::Option::None;
    }

    pub fn has_cmd_teaching(&self) -> bool {
        self.cmd_teaching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_teaching(&mut self, v: u32) {
        self.cmd_teaching = ::std::option::Option::Some(v);
    }

    // optional uint32 cmd_leader = 4;


    pub fn get_cmd_leader(&self) -> u32 {
        self.cmd_leader.unwrap_or(0)
    }
    pub fn clear_cmd_leader(&mut self) {
        self.cmd_leader = ::std::option::Option::None;
    }

    pub fn has_cmd_leader(&self) -> bool {
        self.cmd_leader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_leader(&mut self, v: u32) {
        self.cmd_leader = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlayerCommendationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd_friendly = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd_teaching = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd_leader = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cmd_friendly {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cmd_teaching {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cmd_leader {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cmd_friendly {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cmd_teaching {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cmd_leader {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerCommendationInfo {
        PlayerCommendationInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd_friendly",
                    |m: &PlayerCommendationInfo| { &m.cmd_friendly },
                    |m: &mut PlayerCommendationInfo| { &mut m.cmd_friendly },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd_teaching",
                    |m: &PlayerCommendationInfo| { &m.cmd_teaching },
                    |m: &mut PlayerCommendationInfo| { &mut m.cmd_teaching },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd_leader",
                    |m: &PlayerCommendationInfo| { &m.cmd_leader },
                    |m: &mut PlayerCommendationInfo| { &mut m.cmd_leader },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerCommendationInfo>(
                    "PlayerCommendationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlayerCommendationInfo {
        static mut instance: ::protobuf::lazy::Lazy<PlayerCommendationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerCommendationInfo,
        };
        unsafe {
            instance.get(PlayerCommendationInfo::new)
        }
    }
}

impl ::protobuf::Clear for PlayerCommendationInfo {
    fn clear(&mut self) {
        self.cmd_friendly = ::std::option::Option::None;
        self.cmd_teaching = ::std::option::Option::None;
        self.cmd_leader = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerCommendationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerCommendationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerMedalsInfo {
    // message fields
    display_items_defidx: ::std::vec::Vec<u32>,
    featured_display_item_defidx: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerMedalsInfo {
    fn default() -> &'a PlayerMedalsInfo {
        <PlayerMedalsInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerMedalsInfo {
    pub fn new() -> PlayerMedalsInfo {
        ::std::default::Default::default()
    }

    // repeated uint32 display_items_defidx = 7;


    pub fn get_display_items_defidx(&self) -> &[u32] {
        &self.display_items_defidx
    }
    pub fn clear_display_items_defidx(&mut self) {
        self.display_items_defidx.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_items_defidx(&mut self, v: ::std::vec::Vec<u32>) {
        self.display_items_defidx = v;
    }

    // Mutable pointer to the field.
    pub fn mut_display_items_defidx(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.display_items_defidx
    }

    // Take field
    pub fn take_display_items_defidx(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.display_items_defidx, ::std::vec::Vec::new())
    }

    // optional uint32 featured_display_item_defidx = 8;


    pub fn get_featured_display_item_defidx(&self) -> u32 {
        self.featured_display_item_defidx.unwrap_or(0)
    }
    pub fn clear_featured_display_item_defidx(&mut self) {
        self.featured_display_item_defidx = ::std::option::Option::None;
    }

    pub fn has_featured_display_item_defidx(&self) -> bool {
        self.featured_display_item_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_display_item_defidx(&mut self, v: u32) {
        self.featured_display_item_defidx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlayerMedalsInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.display_items_defidx)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.featured_display_item_defidx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.display_items_defidx {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.featured_display_item_defidx {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.display_items_defidx {
            os.write_uint32(7, *v)?;
        };
        if let Some(v) = self.featured_display_item_defidx {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerMedalsInfo {
        PlayerMedalsInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "display_items_defidx",
                    |m: &PlayerMedalsInfo| { &m.display_items_defidx },
                    |m: &mut PlayerMedalsInfo| { &mut m.display_items_defidx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "featured_display_item_defidx",
                    |m: &PlayerMedalsInfo| { &m.featured_display_item_defidx },
                    |m: &mut PlayerMedalsInfo| { &mut m.featured_display_item_defidx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerMedalsInfo>(
                    "PlayerMedalsInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlayerMedalsInfo {
        static mut instance: ::protobuf::lazy::Lazy<PlayerMedalsInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerMedalsInfo,
        };
        unsafe {
            instance.get(PlayerMedalsInfo::new)
        }
    }
}

impl ::protobuf::Clear for PlayerMedalsInfo {
    fn clear(&mut self) {
        self.display_items_defidx.clear();
        self.featured_display_item_defidx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerMedalsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerMedalsInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountActivity {
    // message fields
    activity: ::std::option::Option<u32>,
    mode: ::std::option::Option<u32>,
    map: ::std::option::Option<u32>,
    matchid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountActivity {
    fn default() -> &'a AccountActivity {
        <AccountActivity as ::protobuf::Message>::default_instance()
    }
}

impl AccountActivity {
    pub fn new() -> AccountActivity {
        ::std::default::Default::default()
    }

    // optional uint32 activity = 1;


    pub fn get_activity(&self) -> u32 {
        self.activity.unwrap_or(0)
    }
    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: u32) {
        self.activity = ::std::option::Option::Some(v);
    }

    // optional uint32 mode = 2;


    pub fn get_mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional uint32 map = 3;


    pub fn get_map(&self) -> u32 {
        self.map.unwrap_or(0)
    }
    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: u32) {
        self.map = ::std::option::Option::Some(v);
    }

    // optional uint64 matchid = 4;


    pub fn get_matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }
    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AccountActivity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.activity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.map = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.matchid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.activity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.map {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.matchid {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountActivity {
        AccountActivity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "activity",
                    |m: &AccountActivity| { &m.activity },
                    |m: &mut AccountActivity| { &mut m.activity },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mode",
                    |m: &AccountActivity| { &m.mode },
                    |m: &mut AccountActivity| { &mut m.mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "map",
                    |m: &AccountActivity| { &m.map },
                    |m: &mut AccountActivity| { &mut m.map },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "matchid",
                    |m: &AccountActivity| { &m.matchid },
                    |m: &mut AccountActivity| { &mut m.matchid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountActivity>(
                    "AccountActivity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountActivity {
        static mut instance: ::protobuf::lazy::Lazy<AccountActivity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountActivity,
        };
        unsafe {
            instance.get(AccountActivity::new)
        }
    }
}

impl ::protobuf::Clear for AccountActivity {
    fn clear(&mut self) {
        self.activity = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.map = ::std::option::Option::None;
        self.matchid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountActivity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TournamentMatchSetup {
    // message fields
    event_id: ::std::option::Option<i32>,
    team_id_ct: ::std::option::Option<i32>,
    team_id_t: ::std::option::Option<i32>,
    event_stage_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TournamentMatchSetup {
    fn default() -> &'a TournamentMatchSetup {
        <TournamentMatchSetup as ::protobuf::Message>::default_instance()
    }
}

impl TournamentMatchSetup {
    pub fn new() -> TournamentMatchSetup {
        ::std::default::Default::default()
    }

    // optional int32 event_id = 1;


    pub fn get_event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_ct = 2;


    pub fn get_team_id_ct(&self) -> i32 {
        self.team_id_ct.unwrap_or(0)
    }
    pub fn clear_team_id_ct(&mut self) {
        self.team_id_ct = ::std::option::Option::None;
    }

    pub fn has_team_id_ct(&self) -> bool {
        self.team_id_ct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_ct(&mut self, v: i32) {
        self.team_id_ct = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_t = 3;


    pub fn get_team_id_t(&self) -> i32 {
        self.team_id_t.unwrap_or(0)
    }
    pub fn clear_team_id_t(&mut self) {
        self.team_id_t = ::std::option::Option::None;
    }

    pub fn has_team_id_t(&self) -> bool {
        self.team_id_t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_t(&mut self, v: i32) {
        self.team_id_t = ::std::option::Option::Some(v);
    }

    // optional int32 event_stage_id = 4;


    pub fn get_event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }
    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TournamentMatchSetup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_ct = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_t = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_stage_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_ct {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_t {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id_ct {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team_id_t {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TournamentMatchSetup {
        TournamentMatchSetup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_id",
                    |m: &TournamentMatchSetup| { &m.event_id },
                    |m: &mut TournamentMatchSetup| { &mut m.event_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_ct",
                    |m: &TournamentMatchSetup| { &m.team_id_ct },
                    |m: &mut TournamentMatchSetup| { &mut m.team_id_ct },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_t",
                    |m: &TournamentMatchSetup| { &m.team_id_t },
                    |m: &mut TournamentMatchSetup| { &mut m.team_id_t },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_stage_id",
                    |m: &TournamentMatchSetup| { &m.event_stage_id },
                    |m: &mut TournamentMatchSetup| { &mut m.event_stage_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TournamentMatchSetup>(
                    "TournamentMatchSetup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TournamentMatchSetup {
        static mut instance: ::protobuf::lazy::Lazy<TournamentMatchSetup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TournamentMatchSetup,
        };
        unsafe {
            instance.get(TournamentMatchSetup::new)
        }
    }
}

impl ::protobuf::Clear for TournamentMatchSetup {
    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.team_id_ct = ::std::option::Option::None;
        self.team_id_t = ::std::option::Option::None;
        self.event_stage_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TournamentMatchSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentMatchSetup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerHltvInfo {
    // message fields
    tv_udp_port: ::std::option::Option<u32>,
    tv_watch_key: ::std::option::Option<u64>,
    tv_slots: ::std::option::Option<u32>,
    tv_clients: ::std::option::Option<u32>,
    tv_proxies: ::std::option::Option<u32>,
    tv_time: ::std::option::Option<u32>,
    game_type: ::std::option::Option<u32>,
    game_mapgroup: ::protobuf::SingularField<::std::string::String>,
    game_map: ::protobuf::SingularField<::std::string::String>,
    tv_master_steamid: ::std::option::Option<u64>,
    tv_local_slots: ::std::option::Option<u32>,
    tv_local_clients: ::std::option::Option<u32>,
    tv_local_proxies: ::std::option::Option<u32>,
    tv_relay_slots: ::std::option::Option<u32>,
    tv_relay_clients: ::std::option::Option<u32>,
    tv_relay_proxies: ::std::option::Option<u32>,
    tv_relay_address: ::std::option::Option<u32>,
    tv_relay_port: ::std::option::Option<u32>,
    tv_relay_steamid: ::std::option::Option<u64>,
    flags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerHltvInfo {
    fn default() -> &'a ServerHltvInfo {
        <ServerHltvInfo as ::protobuf::Message>::default_instance()
    }
}

impl ServerHltvInfo {
    pub fn new() -> ServerHltvInfo {
        ::std::default::Default::default()
    }

    // optional uint32 tv_udp_port = 1;


    pub fn get_tv_udp_port(&self) -> u32 {
        self.tv_udp_port.unwrap_or(0)
    }
    pub fn clear_tv_udp_port(&mut self) {
        self.tv_udp_port = ::std::option::Option::None;
    }

    pub fn has_tv_udp_port(&self) -> bool {
        self.tv_udp_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_udp_port(&mut self, v: u32) {
        self.tv_udp_port = ::std::option::Option::Some(v);
    }

    // optional uint64 tv_watch_key = 2;


    pub fn get_tv_watch_key(&self) -> u64 {
        self.tv_watch_key.unwrap_or(0)
    }
    pub fn clear_tv_watch_key(&mut self) {
        self.tv_watch_key = ::std::option::Option::None;
    }

    pub fn has_tv_watch_key(&self) -> bool {
        self.tv_watch_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_watch_key(&mut self, v: u64) {
        self.tv_watch_key = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_slots = 3;


    pub fn get_tv_slots(&self) -> u32 {
        self.tv_slots.unwrap_or(0)
    }
    pub fn clear_tv_slots(&mut self) {
        self.tv_slots = ::std::option::Option::None;
    }

    pub fn has_tv_slots(&self) -> bool {
        self.tv_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_slots(&mut self, v: u32) {
        self.tv_slots = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_clients = 4;


    pub fn get_tv_clients(&self) -> u32 {
        self.tv_clients.unwrap_or(0)
    }
    pub fn clear_tv_clients(&mut self) {
        self.tv_clients = ::std::option::Option::None;
    }

    pub fn has_tv_clients(&self) -> bool {
        self.tv_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_clients(&mut self, v: u32) {
        self.tv_clients = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_proxies = 5;


    pub fn get_tv_proxies(&self) -> u32 {
        self.tv_proxies.unwrap_or(0)
    }
    pub fn clear_tv_proxies(&mut self) {
        self.tv_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_proxies(&self) -> bool {
        self.tv_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_proxies(&mut self, v: u32) {
        self.tv_proxies = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_time = 6;


    pub fn get_tv_time(&self) -> u32 {
        self.tv_time.unwrap_or(0)
    }
    pub fn clear_tv_time(&mut self) {
        self.tv_time = ::std::option::Option::None;
    }

    pub fn has_tv_time(&self) -> bool {
        self.tv_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_time(&mut self, v: u32) {
        self.tv_time = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 8;


    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }
    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional string game_mapgroup = 9;


    pub fn get_game_mapgroup(&self) -> &str {
        match self.game_mapgroup.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_mapgroup(&mut self) {
        self.game_mapgroup.clear();
    }

    pub fn has_game_mapgroup(&self) -> bool {
        self.game_mapgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mapgroup(&mut self, v: ::std::string::String) {
        self.game_mapgroup = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mapgroup(&mut self) -> &mut ::std::string::String {
        if self.game_mapgroup.is_none() {
            self.game_mapgroup.set_default();
        }
        self.game_mapgroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mapgroup(&mut self) -> ::std::string::String {
        self.game_mapgroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_map = 10;


    pub fn get_game_map(&self) -> &str {
        match self.game_map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_map(&mut self) {
        self.game_map.clear();
    }

    pub fn has_game_map(&self) -> bool {
        self.game_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_map(&mut self, v: ::std::string::String) {
        self.game_map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_map(&mut self) -> &mut ::std::string::String {
        if self.game_map.is_none() {
            self.game_map.set_default();
        }
        self.game_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_map(&mut self) -> ::std::string::String {
        self.game_map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 tv_master_steamid = 11;


    pub fn get_tv_master_steamid(&self) -> u64 {
        self.tv_master_steamid.unwrap_or(0)
    }
    pub fn clear_tv_master_steamid(&mut self) {
        self.tv_master_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_master_steamid(&self) -> bool {
        self.tv_master_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_master_steamid(&mut self, v: u64) {
        self.tv_master_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_local_slots = 12;


    pub fn get_tv_local_slots(&self) -> u32 {
        self.tv_local_slots.unwrap_or(0)
    }
    pub fn clear_tv_local_slots(&mut self) {
        self.tv_local_slots = ::std::option::Option::None;
    }

    pub fn has_tv_local_slots(&self) -> bool {
        self.tv_local_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_slots(&mut self, v: u32) {
        self.tv_local_slots = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_local_clients = 13;


    pub fn get_tv_local_clients(&self) -> u32 {
        self.tv_local_clients.unwrap_or(0)
    }
    pub fn clear_tv_local_clients(&mut self) {
        self.tv_local_clients = ::std::option::Option::None;
    }

    pub fn has_tv_local_clients(&self) -> bool {
        self.tv_local_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_clients(&mut self, v: u32) {
        self.tv_local_clients = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_local_proxies = 14;


    pub fn get_tv_local_proxies(&self) -> u32 {
        self.tv_local_proxies.unwrap_or(0)
    }
    pub fn clear_tv_local_proxies(&mut self) {
        self.tv_local_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_local_proxies(&self) -> bool {
        self.tv_local_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_proxies(&mut self, v: u32) {
        self.tv_local_proxies = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_slots = 15;


    pub fn get_tv_relay_slots(&self) -> u32 {
        self.tv_relay_slots.unwrap_or(0)
    }
    pub fn clear_tv_relay_slots(&mut self) {
        self.tv_relay_slots = ::std::option::Option::None;
    }

    pub fn has_tv_relay_slots(&self) -> bool {
        self.tv_relay_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_slots(&mut self, v: u32) {
        self.tv_relay_slots = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_clients = 16;


    pub fn get_tv_relay_clients(&self) -> u32 {
        self.tv_relay_clients.unwrap_or(0)
    }
    pub fn clear_tv_relay_clients(&mut self) {
        self.tv_relay_clients = ::std::option::Option::None;
    }

    pub fn has_tv_relay_clients(&self) -> bool {
        self.tv_relay_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_clients(&mut self, v: u32) {
        self.tv_relay_clients = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_proxies = 17;


    pub fn get_tv_relay_proxies(&self) -> u32 {
        self.tv_relay_proxies.unwrap_or(0)
    }
    pub fn clear_tv_relay_proxies(&mut self) {
        self.tv_relay_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_relay_proxies(&self) -> bool {
        self.tv_relay_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_proxies(&mut self, v: u32) {
        self.tv_relay_proxies = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_address = 18;


    pub fn get_tv_relay_address(&self) -> u32 {
        self.tv_relay_address.unwrap_or(0)
    }
    pub fn clear_tv_relay_address(&mut self) {
        self.tv_relay_address = ::std::option::Option::None;
    }

    pub fn has_tv_relay_address(&self) -> bool {
        self.tv_relay_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_address(&mut self, v: u32) {
        self.tv_relay_address = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_port = 19;


    pub fn get_tv_relay_port(&self) -> u32 {
        self.tv_relay_port.unwrap_or(0)
    }
    pub fn clear_tv_relay_port(&mut self) {
        self.tv_relay_port = ::std::option::Option::None;
    }

    pub fn has_tv_relay_port(&self) -> bool {
        self.tv_relay_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_port(&mut self, v: u32) {
        self.tv_relay_port = ::std::option::Option::Some(v);
    }

    // optional uint64 tv_relay_steamid = 20;


    pub fn get_tv_relay_steamid(&self) -> u64 {
        self.tv_relay_steamid.unwrap_or(0)
    }
    pub fn clear_tv_relay_steamid(&mut self) {
        self.tv_relay_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_relay_steamid(&self) -> bool {
        self.tv_relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_steamid(&mut self, v: u64) {
        self.tv_relay_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 21;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServerHltvInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_udp_port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tv_watch_key = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_slots = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_clients = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_proxies = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_mapgroup)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_map)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tv_master_steamid = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_local_slots = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_local_clients = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_local_proxies = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_relay_slots = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_relay_clients = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_relay_proxies = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_relay_address = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_relay_port = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tv_relay_steamid = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tv_udp_port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_watch_key {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_slots {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_clients {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_proxies {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_time {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_mapgroup.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.game_map.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.tv_master_steamid {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_local_slots {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_local_clients {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_local_proxies {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_slots {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_clients {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_proxies {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_address {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_port {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_relay_steamid {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tv_udp_port {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tv_watch_key {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.tv_slots {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tv_clients {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tv_proxies {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tv_time {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(8, v)?;
        }
        if let Some(ref v) = self.game_mapgroup.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.game_map.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.tv_master_steamid {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.tv_local_slots {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.tv_local_clients {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.tv_local_proxies {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.tv_relay_slots {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.tv_relay_clients {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.tv_relay_proxies {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.tv_relay_address {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.tv_relay_port {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.tv_relay_steamid {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerHltvInfo {
        ServerHltvInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_udp_port",
                    |m: &ServerHltvInfo| { &m.tv_udp_port },
                    |m: &mut ServerHltvInfo| { &mut m.tv_udp_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tv_watch_key",
                    |m: &ServerHltvInfo| { &m.tv_watch_key },
                    |m: &mut ServerHltvInfo| { &mut m.tv_watch_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_slots",
                    |m: &ServerHltvInfo| { &m.tv_slots },
                    |m: &mut ServerHltvInfo| { &mut m.tv_slots },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_clients",
                    |m: &ServerHltvInfo| { &m.tv_clients },
                    |m: &mut ServerHltvInfo| { &mut m.tv_clients },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_proxies",
                    |m: &ServerHltvInfo| { &m.tv_proxies },
                    |m: &mut ServerHltvInfo| { &mut m.tv_proxies },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_time",
                    |m: &ServerHltvInfo| { &m.tv_time },
                    |m: &mut ServerHltvInfo| { &mut m.tv_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    |m: &ServerHltvInfo| { &m.game_type },
                    |m: &mut ServerHltvInfo| { &mut m.game_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_mapgroup",
                    |m: &ServerHltvInfo| { &m.game_mapgroup },
                    |m: &mut ServerHltvInfo| { &mut m.game_mapgroup },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_map",
                    |m: &ServerHltvInfo| { &m.game_map },
                    |m: &mut ServerHltvInfo| { &mut m.game_map },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tv_master_steamid",
                    |m: &ServerHltvInfo| { &m.tv_master_steamid },
                    |m: &mut ServerHltvInfo| { &mut m.tv_master_steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_local_slots",
                    |m: &ServerHltvInfo| { &m.tv_local_slots },
                    |m: &mut ServerHltvInfo| { &mut m.tv_local_slots },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_local_clients",
                    |m: &ServerHltvInfo| { &m.tv_local_clients },
                    |m: &mut ServerHltvInfo| { &mut m.tv_local_clients },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_local_proxies",
                    |m: &ServerHltvInfo| { &m.tv_local_proxies },
                    |m: &mut ServerHltvInfo| { &mut m.tv_local_proxies },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_relay_slots",
                    |m: &ServerHltvInfo| { &m.tv_relay_slots },
                    |m: &mut ServerHltvInfo| { &mut m.tv_relay_slots },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_relay_clients",
                    |m: &ServerHltvInfo| { &m.tv_relay_clients },
                    |m: &mut ServerHltvInfo| { &mut m.tv_relay_clients },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_relay_proxies",
                    |m: &ServerHltvInfo| { &m.tv_relay_proxies },
                    |m: &mut ServerHltvInfo| { &mut m.tv_relay_proxies },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_relay_address",
                    |m: &ServerHltvInfo| { &m.tv_relay_address },
                    |m: &mut ServerHltvInfo| { &mut m.tv_relay_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_relay_port",
                    |m: &ServerHltvInfo| { &m.tv_relay_port },
                    |m: &mut ServerHltvInfo| { &mut m.tv_relay_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tv_relay_steamid",
                    |m: &ServerHltvInfo| { &m.tv_relay_steamid },
                    |m: &mut ServerHltvInfo| { &mut m.tv_relay_steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    |m: &ServerHltvInfo| { &m.flags },
                    |m: &mut ServerHltvInfo| { &mut m.flags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerHltvInfo>(
                    "ServerHltvInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServerHltvInfo {
        static mut instance: ::protobuf::lazy::Lazy<ServerHltvInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerHltvInfo,
        };
        unsafe {
            instance.get(ServerHltvInfo::new)
        }
    }
}

impl ::protobuf::Clear for ServerHltvInfo {
    fn clear(&mut self) {
        self.tv_udp_port = ::std::option::Option::None;
        self.tv_watch_key = ::std::option::Option::None;
        self.tv_slots = ::std::option::Option::None;
        self.tv_clients = ::std::option::Option::None;
        self.tv_proxies = ::std::option::Option::None;
        self.tv_time = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.game_mapgroup.clear();
        self.game_map.clear();
        self.tv_master_steamid = ::std::option::Option::None;
        self.tv_local_slots = ::std::option::Option::None;
        self.tv_local_clients = ::std::option::Option::None;
        self.tv_local_proxies = ::std::option::Option::None;
        self.tv_relay_slots = ::std::option::Option::None;
        self.tv_relay_clients = ::std::option::Option::None;
        self.tv_relay_proxies = ::std::option::Option::None;
        self.tv_relay_address = ::std::option::Option::None;
        self.tv_relay_port = ::std::option::Option::None;
        self.tv_relay_steamid = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerHltvInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerHltvInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IpAddressMask {
    // message fields
    a: ::std::option::Option<u32>,
    b: ::std::option::Option<u32>,
    c: ::std::option::Option<u32>,
    d: ::std::option::Option<u32>,
    bits: ::std::option::Option<u32>,
    token: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IpAddressMask {
    fn default() -> &'a IpAddressMask {
        <IpAddressMask as ::protobuf::Message>::default_instance()
    }
}

impl IpAddressMask {
    pub fn new() -> IpAddressMask {
        ::std::default::Default::default()
    }

    // optional uint32 a = 1;


    pub fn get_a(&self) -> u32 {
        self.a.unwrap_or(0)
    }
    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: u32) {
        self.a = ::std::option::Option::Some(v);
    }

    // optional uint32 b = 2;


    pub fn get_b(&self) -> u32 {
        self.b.unwrap_or(0)
    }
    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: u32) {
        self.b = ::std::option::Option::Some(v);
    }

    // optional uint32 c = 3;


    pub fn get_c(&self) -> u32 {
        self.c.unwrap_or(0)
    }
    pub fn clear_c(&mut self) {
        self.c = ::std::option::Option::None;
    }

    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c(&mut self, v: u32) {
        self.c = ::std::option::Option::Some(v);
    }

    // optional uint32 d = 4;


    pub fn get_d(&self) -> u32 {
        self.d.unwrap_or(0)
    }
    pub fn clear_d(&mut self) {
        self.d = ::std::option::Option::None;
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: u32) {
        self.d = ::std::option::Option::Some(v);
    }

    // optional uint32 bits = 5;


    pub fn get_bits(&self) -> u32 {
        self.bits.unwrap_or(0)
    }
    pub fn clear_bits(&mut self) {
        self.bits = ::std::option::Option::None;
    }

    pub fn has_bits(&self) -> bool {
        self.bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bits(&mut self, v: u32) {
        self.bits = ::std::option::Option::Some(v);
    }

    // optional uint32 token = 6;


    pub fn get_token(&self) -> u32 {
        self.token.unwrap_or(0)
    }
    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IpAddressMask {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.a = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.b = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.c = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.d = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bits = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.a {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.b {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.c {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.d {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bits {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.a {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.b {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.c {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.d {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bits {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.token {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IpAddressMask {
        IpAddressMask::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "a",
                    |m: &IpAddressMask| { &m.a },
                    |m: &mut IpAddressMask| { &mut m.a },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "b",
                    |m: &IpAddressMask| { &m.b },
                    |m: &mut IpAddressMask| { &mut m.b },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "c",
                    |m: &IpAddressMask| { &m.c },
                    |m: &mut IpAddressMask| { &mut m.c },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "d",
                    |m: &IpAddressMask| { &m.d },
                    |m: &mut IpAddressMask| { &mut m.d },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bits",
                    |m: &IpAddressMask| { &m.bits },
                    |m: &mut IpAddressMask| { &mut m.bits },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "token",
                    |m: &IpAddressMask| { &m.token },
                    |m: &mut IpAddressMask| { &mut m.token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IpAddressMask>(
                    "IpAddressMask",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IpAddressMask {
        static mut instance: ::protobuf::lazy::Lazy<IpAddressMask> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IpAddressMask,
        };
        unsafe {
            instance.get(IpAddressMask::new)
        }
    }
}

impl ::protobuf::Clear for IpAddressMask {
    fn clear(&mut self) {
        self.a = ::std::option::Option::None;
        self.b = ::std::option::Option::None;
        self.c = ::std::option::Option::None;
        self.d = ::std::option::Option::None;
        self.bits = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IpAddressMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IpAddressMask {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCsgoSteamUserStatChange {
    // message fields
    ecsgosteamuserstat: ::std::option::Option<i32>,
    delta: ::std::option::Option<i32>,
    absolute: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCsgoSteamUserStatChange {
    fn default() -> &'a CMsgCsgoSteamUserStatChange {
        <CMsgCsgoSteamUserStatChange as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCsgoSteamUserStatChange {
    pub fn new() -> CMsgCsgoSteamUserStatChange {
        ::std::default::Default::default()
    }

    // optional int32 ecsgosteamuserstat = 1;


    pub fn get_ecsgosteamuserstat(&self) -> i32 {
        self.ecsgosteamuserstat.unwrap_or(0)
    }
    pub fn clear_ecsgosteamuserstat(&mut self) {
        self.ecsgosteamuserstat = ::std::option::Option::None;
    }

    pub fn has_ecsgosteamuserstat(&self) -> bool {
        self.ecsgosteamuserstat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecsgosteamuserstat(&mut self, v: i32) {
        self.ecsgosteamuserstat = ::std::option::Option::Some(v);
    }

    // optional int32 delta = 2;


    pub fn get_delta(&self) -> i32 {
        self.delta.unwrap_or(0)
    }
    pub fn clear_delta(&mut self) {
        self.delta = ::std::option::Option::None;
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: i32) {
        self.delta = ::std::option::Option::Some(v);
    }

    // optional bool absolute = 3;


    pub fn get_absolute(&self) -> bool {
        self.absolute.unwrap_or(false)
    }
    pub fn clear_absolute(&mut self) {
        self.absolute = ::std::option::Option::None;
    }

    pub fn has_absolute(&self) -> bool {
        self.absolute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_absolute(&mut self, v: bool) {
        self.absolute = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCsgoSteamUserStatChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ecsgosteamuserstat = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.delta = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.absolute = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ecsgosteamuserstat {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.delta {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.absolute {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ecsgosteamuserstat {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.delta {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.absolute {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCsgoSteamUserStatChange {
        CMsgCsgoSteamUserStatChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ecsgosteamuserstat",
                    |m: &CMsgCsgoSteamUserStatChange| { &m.ecsgosteamuserstat },
                    |m: &mut CMsgCsgoSteamUserStatChange| { &mut m.ecsgosteamuserstat },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "delta",
                    |m: &CMsgCsgoSteamUserStatChange| { &m.delta },
                    |m: &mut CMsgCsgoSteamUserStatChange| { &mut m.delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "absolute",
                    |m: &CMsgCsgoSteamUserStatChange| { &m.absolute },
                    |m: &mut CMsgCsgoSteamUserStatChange| { &mut m.absolute },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCsgoSteamUserStatChange>(
                    "CMsgCsgoSteamUserStatChange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgCsgoSteamUserStatChange {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCsgoSteamUserStatChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCsgoSteamUserStatChange,
        };
        unsafe {
            instance.get(CMsgCsgoSteamUserStatChange::new)
        }
    }
}

impl ::protobuf::Clear for CMsgCsgoSteamUserStatChange {
    fn clear(&mut self) {
        self.ecsgosteamuserstat = ::std::option::Option::None;
        self.delta = ::std::option::Option::None;
        self.absolute = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCsgoSteamUserStatChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCsgoSteamUserStatChange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct XpProgressData {
    // message fields
    xp_points: ::std::option::Option<u32>,
    xp_category: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a XpProgressData {
    fn default() -> &'a XpProgressData {
        <XpProgressData as ::protobuf::Message>::default_instance()
    }
}

impl XpProgressData {
    pub fn new() -> XpProgressData {
        ::std::default::Default::default()
    }

    // optional uint32 xp_points = 1;


    pub fn get_xp_points(&self) -> u32 {
        self.xp_points.unwrap_or(0)
    }
    pub fn clear_xp_points(&mut self) {
        self.xp_points = ::std::option::Option::None;
    }

    pub fn has_xp_points(&self) -> bool {
        self.xp_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_points(&mut self, v: u32) {
        self.xp_points = ::std::option::Option::Some(v);
    }

    // optional int32 xp_category = 2;


    pub fn get_xp_category(&self) -> i32 {
        self.xp_category.unwrap_or(0)
    }
    pub fn clear_xp_category(&mut self) {
        self.xp_category = ::std::option::Option::None;
    }

    pub fn has_xp_category(&self) -> bool {
        self.xp_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_category(&mut self, v: i32) {
        self.xp_category = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for XpProgressData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xp_points = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.xp_category = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.xp_points {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xp_category {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.xp_points {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.xp_category {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> XpProgressData {
        XpProgressData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xp_points",
                    |m: &XpProgressData| { &m.xp_points },
                    |m: &mut XpProgressData| { &mut m.xp_points },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "xp_category",
                    |m: &XpProgressData| { &m.xp_category },
                    |m: &mut XpProgressData| { &mut m.xp_category },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<XpProgressData>(
                    "XpProgressData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static XpProgressData {
        static mut instance: ::protobuf::lazy::Lazy<XpProgressData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const XpProgressData,
        };
        unsafe {
            instance.get(XpProgressData::new)
        }
    }
}

impl ::protobuf::Clear for XpProgressData {
    fn clear(&mut self) {
        self.xp_points = ::std::option::Option::None;
        self.xp_category = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for XpProgressData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for XpProgressData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchEndItemUpdates {
    // message fields
    item_id: ::std::option::Option<u64>,
    item_attr_defidx: ::std::option::Option<u32>,
    item_attr_delta_value: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MatchEndItemUpdates {
    fn default() -> &'a MatchEndItemUpdates {
        <MatchEndItemUpdates as ::protobuf::Message>::default_instance()
    }
}

impl MatchEndItemUpdates {
    pub fn new() -> MatchEndItemUpdates {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_attr_defidx = 2;


    pub fn get_item_attr_defidx(&self) -> u32 {
        self.item_attr_defidx.unwrap_or(0)
    }
    pub fn clear_item_attr_defidx(&mut self) {
        self.item_attr_defidx = ::std::option::Option::None;
    }

    pub fn has_item_attr_defidx(&self) -> bool {
        self.item_attr_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_attr_defidx(&mut self, v: u32) {
        self.item_attr_defidx = ::std::option::Option::Some(v);
    }

    // optional uint32 item_attr_delta_value = 3;


    pub fn get_item_attr_delta_value(&self) -> u32 {
        self.item_attr_delta_value.unwrap_or(0)
    }
    pub fn clear_item_attr_delta_value(&mut self) {
        self.item_attr_delta_value = ::std::option::Option::None;
    }

    pub fn has_item_attr_delta_value(&self) -> bool {
        self.item_attr_delta_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_attr_delta_value(&mut self, v: u32) {
        self.item_attr_delta_value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MatchEndItemUpdates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_attr_defidx = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_attr_delta_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_attr_defidx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_attr_delta_value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_attr_defidx {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_attr_delta_value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchEndItemUpdates {
        MatchEndItemUpdates::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    |m: &MatchEndItemUpdates| { &m.item_id },
                    |m: &mut MatchEndItemUpdates| { &mut m.item_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_attr_defidx",
                    |m: &MatchEndItemUpdates| { &m.item_attr_defidx },
                    |m: &mut MatchEndItemUpdates| { &mut m.item_attr_defidx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_attr_delta_value",
                    |m: &MatchEndItemUpdates| { &m.item_attr_delta_value },
                    |m: &mut MatchEndItemUpdates| { &mut m.item_attr_delta_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchEndItemUpdates>(
                    "MatchEndItemUpdates",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchEndItemUpdates {
        static mut instance: ::protobuf::lazy::Lazy<MatchEndItemUpdates> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchEndItemUpdates,
        };
        unsafe {
            instance.get(MatchEndItemUpdates::new)
        }
    }
}

impl ::protobuf::Clear for MatchEndItemUpdates {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.item_attr_defidx = ::std::option::Option::None;
        self.item_attr_delta_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchEndItemUpdates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchEndItemUpdates {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScoreLeaderboardData {
    // message fields
    quest_id: ::std::option::Option<u64>,
    score: ::std::option::Option<u32>,
    accountentries: ::protobuf::RepeatedField<ScoreLeaderboardData_AccountEntries>,
    matchentries: ::protobuf::RepeatedField<ScoreLeaderboardData_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScoreLeaderboardData {
    fn default() -> &'a ScoreLeaderboardData {
        <ScoreLeaderboardData as ::protobuf::Message>::default_instance()
    }
}

impl ScoreLeaderboardData {
    pub fn new() -> ScoreLeaderboardData {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 2;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // repeated .ScoreLeaderboardData.AccountEntries accountentries = 3;


    pub fn get_accountentries(&self) -> &[ScoreLeaderboardData_AccountEntries] {
        &self.accountentries
    }
    pub fn clear_accountentries(&mut self) {
        self.accountentries.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountentries(&mut self, v: ::protobuf::RepeatedField<ScoreLeaderboardData_AccountEntries>) {
        self.accountentries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accountentries(&mut self) -> &mut ::protobuf::RepeatedField<ScoreLeaderboardData_AccountEntries> {
        &mut self.accountentries
    }

    // Take field
    pub fn take_accountentries(&mut self) -> ::protobuf::RepeatedField<ScoreLeaderboardData_AccountEntries> {
        ::std::mem::replace(&mut self.accountentries, ::protobuf::RepeatedField::new())
    }

    // repeated .ScoreLeaderboardData.Entry matchentries = 5;


    pub fn get_matchentries(&self) -> &[ScoreLeaderboardData_Entry] {
        &self.matchentries
    }
    pub fn clear_matchentries(&mut self) {
        self.matchentries.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchentries(&mut self, v: ::protobuf::RepeatedField<ScoreLeaderboardData_Entry>) {
        self.matchentries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchentries(&mut self) -> &mut ::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        &mut self.matchentries
    }

    // Take field
    pub fn take_matchentries(&mut self) -> ::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        ::std::mem::replace(&mut self.matchentries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ScoreLeaderboardData {
    fn is_initialized(&self) -> bool {
        for v in &self.accountentries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.matchentries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accountentries)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchentries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.accountentries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.matchentries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        for v in &self.accountentries {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.matchentries {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScoreLeaderboardData {
        ScoreLeaderboardData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "quest_id",
                    |m: &ScoreLeaderboardData| { &m.quest_id },
                    |m: &mut ScoreLeaderboardData| { &mut m.quest_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    |m: &ScoreLeaderboardData| { &m.score },
                    |m: &mut ScoreLeaderboardData| { &mut m.score },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScoreLeaderboardData_AccountEntries>>(
                    "accountentries",
                    |m: &ScoreLeaderboardData| { &m.accountentries },
                    |m: &mut ScoreLeaderboardData| { &mut m.accountentries },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScoreLeaderboardData_Entry>>(
                    "matchentries",
                    |m: &ScoreLeaderboardData| { &m.matchentries },
                    |m: &mut ScoreLeaderboardData| { &mut m.matchentries },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScoreLeaderboardData>(
                    "ScoreLeaderboardData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScoreLeaderboardData {
        static mut instance: ::protobuf::lazy::Lazy<ScoreLeaderboardData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScoreLeaderboardData,
        };
        unsafe {
            instance.get(ScoreLeaderboardData::new)
        }
    }
}

impl ::protobuf::Clear for ScoreLeaderboardData {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.accountentries.clear();
        self.matchentries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScoreLeaderboardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreLeaderboardData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScoreLeaderboardData_Entry {
    // message fields
    tag: ::std::option::Option<u32>,
    val: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScoreLeaderboardData_Entry {
    fn default() -> &'a ScoreLeaderboardData_Entry {
        <ScoreLeaderboardData_Entry as ::protobuf::Message>::default_instance()
    }
}

impl ScoreLeaderboardData_Entry {
    pub fn new() -> ScoreLeaderboardData_Entry {
        ::std::default::Default::default()
    }

    // optional uint32 tag = 1;


    pub fn get_tag(&self) -> u32 {
        self.tag.unwrap_or(0)
    }
    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u32) {
        self.tag = ::std::option::Option::Some(v);
    }

    // optional uint32 val = 2;


    pub fn get_val(&self) -> u32 {
        self.val.unwrap_or(0)
    }
    pub fn clear_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: u32) {
        self.val = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScoreLeaderboardData_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tag = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.val = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.val {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tag {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.val {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScoreLeaderboardData_Entry {
        ScoreLeaderboardData_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tag",
                    |m: &ScoreLeaderboardData_Entry| { &m.tag },
                    |m: &mut ScoreLeaderboardData_Entry| { &mut m.tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "val",
                    |m: &ScoreLeaderboardData_Entry| { &m.val },
                    |m: &mut ScoreLeaderboardData_Entry| { &mut m.val },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScoreLeaderboardData_Entry>(
                    "ScoreLeaderboardData_Entry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScoreLeaderboardData_Entry {
        static mut instance: ::protobuf::lazy::Lazy<ScoreLeaderboardData_Entry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScoreLeaderboardData_Entry,
        };
        unsafe {
            instance.get(ScoreLeaderboardData_Entry::new)
        }
    }
}

impl ::protobuf::Clear for ScoreLeaderboardData_Entry {
    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScoreLeaderboardData_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreLeaderboardData_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScoreLeaderboardData_AccountEntries {
    // message fields
    accountid: ::std::option::Option<u32>,
    entries: ::protobuf::RepeatedField<ScoreLeaderboardData_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScoreLeaderboardData_AccountEntries {
    fn default() -> &'a ScoreLeaderboardData_AccountEntries {
        <ScoreLeaderboardData_AccountEntries as ::protobuf::Message>::default_instance()
    }
}

impl ScoreLeaderboardData_AccountEntries {
    pub fn new() -> ScoreLeaderboardData_AccountEntries {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // repeated .ScoreLeaderboardData.Entry entries = 2;


    pub fn get_entries(&self) -> &[ScoreLeaderboardData_Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<ScoreLeaderboardData_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<ScoreLeaderboardData_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ScoreLeaderboardData_AccountEntries {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        for v in &self.entries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScoreLeaderboardData_AccountEntries {
        ScoreLeaderboardData_AccountEntries::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &ScoreLeaderboardData_AccountEntries| { &m.accountid },
                    |m: &mut ScoreLeaderboardData_AccountEntries| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScoreLeaderboardData_Entry>>(
                    "entries",
                    |m: &ScoreLeaderboardData_AccountEntries| { &m.entries },
                    |m: &mut ScoreLeaderboardData_AccountEntries| { &mut m.entries },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScoreLeaderboardData_AccountEntries>(
                    "ScoreLeaderboardData_AccountEntries",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScoreLeaderboardData_AccountEntries {
        static mut instance: ::protobuf::lazy::Lazy<ScoreLeaderboardData_AccountEntries> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScoreLeaderboardData_AccountEntries,
        };
        unsafe {
            instance.get(ScoreLeaderboardData_AccountEntries::new)
        }
    }
}

impl ::protobuf::Clear for ScoreLeaderboardData_AccountEntries {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScoreLeaderboardData_AccountEntries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreLeaderboardData_AccountEntries {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerQuestData {
    // message fields
    quester_account_id: ::std::option::Option<u32>,
    quest_item_data: ::protobuf::RepeatedField<PlayerQuestData_QuestItemData>,
    xp_progress_data: ::protobuf::RepeatedField<XpProgressData>,
    time_played: ::std::option::Option<u32>,
    mm_game_mode: ::std::option::Option<u32>,
    item_updates: ::protobuf::RepeatedField<MatchEndItemUpdates>,
    operation_points_eligible: ::std::option::Option<bool>,
    userstatchanges: ::protobuf::RepeatedField<CMsgCsgoSteamUserStatChange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerQuestData {
    fn default() -> &'a PlayerQuestData {
        <PlayerQuestData as ::protobuf::Message>::default_instance()
    }
}

impl PlayerQuestData {
    pub fn new() -> PlayerQuestData {
        ::std::default::Default::default()
    }

    // optional uint32 quester_account_id = 1;


    pub fn get_quester_account_id(&self) -> u32 {
        self.quester_account_id.unwrap_or(0)
    }
    pub fn clear_quester_account_id(&mut self) {
        self.quester_account_id = ::std::option::Option::None;
    }

    pub fn has_quester_account_id(&self) -> bool {
        self.quester_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quester_account_id(&mut self, v: u32) {
        self.quester_account_id = ::std::option::Option::Some(v);
    }

    // repeated .PlayerQuestData.QuestItemData quest_item_data = 2;


    pub fn get_quest_item_data(&self) -> &[PlayerQuestData_QuestItemData] {
        &self.quest_item_data
    }
    pub fn clear_quest_item_data(&mut self) {
        self.quest_item_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_quest_item_data(&mut self, v: ::protobuf::RepeatedField<PlayerQuestData_QuestItemData>) {
        self.quest_item_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quest_item_data(&mut self) -> &mut ::protobuf::RepeatedField<PlayerQuestData_QuestItemData> {
        &mut self.quest_item_data
    }

    // Take field
    pub fn take_quest_item_data(&mut self) -> ::protobuf::RepeatedField<PlayerQuestData_QuestItemData> {
        ::std::mem::replace(&mut self.quest_item_data, ::protobuf::RepeatedField::new())
    }

    // repeated .XpProgressData xp_progress_data = 3;


    pub fn get_xp_progress_data(&self) -> &[XpProgressData] {
        &self.xp_progress_data
    }
    pub fn clear_xp_progress_data(&mut self) {
        self.xp_progress_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_xp_progress_data(&mut self, v: ::protobuf::RepeatedField<XpProgressData>) {
        self.xp_progress_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xp_progress_data(&mut self) -> &mut ::protobuf::RepeatedField<XpProgressData> {
        &mut self.xp_progress_data
    }

    // Take field
    pub fn take_xp_progress_data(&mut self) -> ::protobuf::RepeatedField<XpProgressData> {
        ::std::mem::replace(&mut self.xp_progress_data, ::protobuf::RepeatedField::new())
    }

    // optional uint32 time_played = 4;


    pub fn get_time_played(&self) -> u32 {
        self.time_played.unwrap_or(0)
    }
    pub fn clear_time_played(&mut self) {
        self.time_played = ::std::option::Option::None;
    }

    pub fn has_time_played(&self) -> bool {
        self.time_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_played(&mut self, v: u32) {
        self.time_played = ::std::option::Option::Some(v);
    }

    // optional uint32 mm_game_mode = 5;


    pub fn get_mm_game_mode(&self) -> u32 {
        self.mm_game_mode.unwrap_or(0)
    }
    pub fn clear_mm_game_mode(&mut self) {
        self.mm_game_mode = ::std::option::Option::None;
    }

    pub fn has_mm_game_mode(&self) -> bool {
        self.mm_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mm_game_mode(&mut self, v: u32) {
        self.mm_game_mode = ::std::option::Option::Some(v);
    }

    // repeated .MatchEndItemUpdates item_updates = 6;


    pub fn get_item_updates(&self) -> &[MatchEndItemUpdates] {
        &self.item_updates
    }
    pub fn clear_item_updates(&mut self) {
        self.item_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_updates(&mut self, v: ::protobuf::RepeatedField<MatchEndItemUpdates>) {
        self.item_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_updates(&mut self) -> &mut ::protobuf::RepeatedField<MatchEndItemUpdates> {
        &mut self.item_updates
    }

    // Take field
    pub fn take_item_updates(&mut self) -> ::protobuf::RepeatedField<MatchEndItemUpdates> {
        ::std::mem::replace(&mut self.item_updates, ::protobuf::RepeatedField::new())
    }

    // optional bool operation_points_eligible = 7;


    pub fn get_operation_points_eligible(&self) -> bool {
        self.operation_points_eligible.unwrap_or(false)
    }
    pub fn clear_operation_points_eligible(&mut self) {
        self.operation_points_eligible = ::std::option::Option::None;
    }

    pub fn has_operation_points_eligible(&self) -> bool {
        self.operation_points_eligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation_points_eligible(&mut self, v: bool) {
        self.operation_points_eligible = ::std::option::Option::Some(v);
    }

    // repeated .CMsgCsgoSteamUserStatChange userstatchanges = 8;


    pub fn get_userstatchanges(&self) -> &[CMsgCsgoSteamUserStatChange] {
        &self.userstatchanges
    }
    pub fn clear_userstatchanges(&mut self) {
        self.userstatchanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_userstatchanges(&mut self, v: ::protobuf::RepeatedField<CMsgCsgoSteamUserStatChange>) {
        self.userstatchanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_userstatchanges(&mut self) -> &mut ::protobuf::RepeatedField<CMsgCsgoSteamUserStatChange> {
        &mut self.userstatchanges
    }

    // Take field
    pub fn take_userstatchanges(&mut self) -> ::protobuf::RepeatedField<CMsgCsgoSteamUserStatChange> {
        ::std::mem::replace(&mut self.userstatchanges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PlayerQuestData {
    fn is_initialized(&self) -> bool {
        for v in &self.quest_item_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.xp_progress_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userstatchanges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quester_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.quest_item_data)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.xp_progress_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_played = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mm_game_mode = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item_updates)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.operation_points_eligible = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.userstatchanges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quester_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.quest_item_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.xp_progress_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.time_played {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mm_game_mode {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.operation_points_eligible {
            my_size += 2;
        }
        for value in &self.userstatchanges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quester_account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.quest_item_data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.xp_progress_data {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.time_played {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.mm_game_mode {
            os.write_uint32(5, v)?;
        }
        for v in &self.item_updates {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.operation_points_eligible {
            os.write_bool(7, v)?;
        }
        for v in &self.userstatchanges {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerQuestData {
        PlayerQuestData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quester_account_id",
                    |m: &PlayerQuestData| { &m.quester_account_id },
                    |m: &mut PlayerQuestData| { &mut m.quester_account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerQuestData_QuestItemData>>(
                    "quest_item_data",
                    |m: &PlayerQuestData| { &m.quest_item_data },
                    |m: &mut PlayerQuestData| { &mut m.quest_item_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<XpProgressData>>(
                    "xp_progress_data",
                    |m: &PlayerQuestData| { &m.xp_progress_data },
                    |m: &mut PlayerQuestData| { &mut m.xp_progress_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_played",
                    |m: &PlayerQuestData| { &m.time_played },
                    |m: &mut PlayerQuestData| { &mut m.time_played },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mm_game_mode",
                    |m: &PlayerQuestData| { &m.mm_game_mode },
                    |m: &mut PlayerQuestData| { &mut m.mm_game_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchEndItemUpdates>>(
                    "item_updates",
                    |m: &PlayerQuestData| { &m.item_updates },
                    |m: &mut PlayerQuestData| { &mut m.item_updates },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "operation_points_eligible",
                    |m: &PlayerQuestData| { &m.operation_points_eligible },
                    |m: &mut PlayerQuestData| { &mut m.operation_points_eligible },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgCsgoSteamUserStatChange>>(
                    "userstatchanges",
                    |m: &PlayerQuestData| { &m.userstatchanges },
                    |m: &mut PlayerQuestData| { &mut m.userstatchanges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerQuestData>(
                    "PlayerQuestData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlayerQuestData {
        static mut instance: ::protobuf::lazy::Lazy<PlayerQuestData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerQuestData,
        };
        unsafe {
            instance.get(PlayerQuestData::new)
        }
    }
}

impl ::protobuf::Clear for PlayerQuestData {
    fn clear(&mut self) {
        self.quester_account_id = ::std::option::Option::None;
        self.quest_item_data.clear();
        self.xp_progress_data.clear();
        self.time_played = ::std::option::Option::None;
        self.mm_game_mode = ::std::option::Option::None;
        self.item_updates.clear();
        self.operation_points_eligible = ::std::option::Option::None;
        self.userstatchanges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerQuestData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerQuestData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerQuestData_QuestItemData {
    // message fields
    quest_id: ::std::option::Option<u64>,
    quest_normal_points_earned: ::std::option::Option<i32>,
    quest_bonus_points_earned: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerQuestData_QuestItemData {
    fn default() -> &'a PlayerQuestData_QuestItemData {
        <PlayerQuestData_QuestItemData as ::protobuf::Message>::default_instance()
    }
}

impl PlayerQuestData_QuestItemData {
    pub fn new() -> PlayerQuestData_QuestItemData {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional int32 quest_normal_points_earned = 2;


    pub fn get_quest_normal_points_earned(&self) -> i32 {
        self.quest_normal_points_earned.unwrap_or(0)
    }
    pub fn clear_quest_normal_points_earned(&mut self) {
        self.quest_normal_points_earned = ::std::option::Option::None;
    }

    pub fn has_quest_normal_points_earned(&self) -> bool {
        self.quest_normal_points_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_normal_points_earned(&mut self, v: i32) {
        self.quest_normal_points_earned = ::std::option::Option::Some(v);
    }

    // optional int32 quest_bonus_points_earned = 3;


    pub fn get_quest_bonus_points_earned(&self) -> i32 {
        self.quest_bonus_points_earned.unwrap_or(0)
    }
    pub fn clear_quest_bonus_points_earned(&mut self) {
        self.quest_bonus_points_earned = ::std::option::Option::None;
    }

    pub fn has_quest_bonus_points_earned(&self) -> bool {
        self.quest_bonus_points_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_bonus_points_earned(&mut self, v: i32) {
        self.quest_bonus_points_earned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlayerQuestData_QuestItemData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quest_normal_points_earned = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quest_bonus_points_earned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_normal_points_earned {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_bonus_points_earned {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.quest_normal_points_earned {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.quest_bonus_points_earned {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerQuestData_QuestItemData {
        PlayerQuestData_QuestItemData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "quest_id",
                    |m: &PlayerQuestData_QuestItemData| { &m.quest_id },
                    |m: &mut PlayerQuestData_QuestItemData| { &mut m.quest_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "quest_normal_points_earned",
                    |m: &PlayerQuestData_QuestItemData| { &m.quest_normal_points_earned },
                    |m: &mut PlayerQuestData_QuestItemData| { &mut m.quest_normal_points_earned },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "quest_bonus_points_earned",
                    |m: &PlayerQuestData_QuestItemData| { &m.quest_bonus_points_earned },
                    |m: &mut PlayerQuestData_QuestItemData| { &mut m.quest_bonus_points_earned },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerQuestData_QuestItemData>(
                    "PlayerQuestData_QuestItemData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlayerQuestData_QuestItemData {
        static mut instance: ::protobuf::lazy::Lazy<PlayerQuestData_QuestItemData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerQuestData_QuestItemData,
        };
        unsafe {
            instance.get(PlayerQuestData_QuestItemData::new)
        }
    }
}

impl ::protobuf::Clear for PlayerQuestData_QuestItemData {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.quest_normal_points_earned = ::std::option::Option::None;
        self.quest_bonus_points_earned = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerQuestData_QuestItemData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerQuestData_QuestItemData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_ServerQuestUpdateData {
    // message fields
    player_quest_data: ::protobuf::RepeatedField<PlayerQuestData>,
    binary_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mm_game_mode: ::std::option::Option<u32>,
    missionlbsdata: ::protobuf::SingularPtrField<ScoreLeaderboardData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_ServerQuestUpdateData {
    fn default() -> &'a CMsgGC_ServerQuestUpdateData {
        <CMsgGC_ServerQuestUpdateData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_ServerQuestUpdateData {
    pub fn new() -> CMsgGC_ServerQuestUpdateData {
        ::std::default::Default::default()
    }

    // repeated .PlayerQuestData player_quest_data = 1;


    pub fn get_player_quest_data(&self) -> &[PlayerQuestData] {
        &self.player_quest_data
    }
    pub fn clear_player_quest_data(&mut self) {
        self.player_quest_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_quest_data(&mut self, v: ::protobuf::RepeatedField<PlayerQuestData>) {
        self.player_quest_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_quest_data(&mut self) -> &mut ::protobuf::RepeatedField<PlayerQuestData> {
        &mut self.player_quest_data
    }

    // Take field
    pub fn take_player_quest_data(&mut self) -> ::protobuf::RepeatedField<PlayerQuestData> {
        ::std::mem::replace(&mut self.player_quest_data, ::protobuf::RepeatedField::new())
    }

    // optional bytes binary_data = 2;


    pub fn get_binary_data(&self) -> &[u8] {
        match self.binary_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_binary_data(&mut self) {
        self.binary_data.clear();
    }

    pub fn has_binary_data(&self) -> bool {
        self.binary_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binary_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.binary_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binary_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.binary_data.is_none() {
            self.binary_data.set_default();
        }
        self.binary_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_binary_data(&mut self) -> ::std::vec::Vec<u8> {
        self.binary_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 mm_game_mode = 3;


    pub fn get_mm_game_mode(&self) -> u32 {
        self.mm_game_mode.unwrap_or(0)
    }
    pub fn clear_mm_game_mode(&mut self) {
        self.mm_game_mode = ::std::option::Option::None;
    }

    pub fn has_mm_game_mode(&self) -> bool {
        self.mm_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mm_game_mode(&mut self, v: u32) {
        self.mm_game_mode = ::std::option::Option::Some(v);
    }

    // optional .ScoreLeaderboardData missionlbsdata = 4;


    pub fn get_missionlbsdata(&self) -> &ScoreLeaderboardData {
        self.missionlbsdata.as_ref().unwrap_or_else(|| ScoreLeaderboardData::default_instance())
    }
    pub fn clear_missionlbsdata(&mut self) {
        self.missionlbsdata.clear();
    }

    pub fn has_missionlbsdata(&self) -> bool {
        self.missionlbsdata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missionlbsdata(&mut self, v: ScoreLeaderboardData) {
        self.missionlbsdata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_missionlbsdata(&mut self) -> &mut ScoreLeaderboardData {
        if self.missionlbsdata.is_none() {
            self.missionlbsdata.set_default();
        }
        self.missionlbsdata.as_mut().unwrap()
    }

    // Take field
    pub fn take_missionlbsdata(&mut self) -> ScoreLeaderboardData {
        self.missionlbsdata.take().unwrap_or_else(|| ScoreLeaderboardData::new())
    }
}

impl ::protobuf::Message for CMsgGC_ServerQuestUpdateData {
    fn is_initialized(&self) -> bool {
        for v in &self.player_quest_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.missionlbsdata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_quest_data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.binary_data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mm_game_mode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.missionlbsdata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_quest_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.binary_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.mm_game_mode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.missionlbsdata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_quest_data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.binary_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.mm_game_mode {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.missionlbsdata.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_ServerQuestUpdateData {
        CMsgGC_ServerQuestUpdateData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerQuestData>>(
                    "player_quest_data",
                    |m: &CMsgGC_ServerQuestUpdateData| { &m.player_quest_data },
                    |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.player_quest_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "binary_data",
                    |m: &CMsgGC_ServerQuestUpdateData| { &m.binary_data },
                    |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.binary_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mm_game_mode",
                    |m: &CMsgGC_ServerQuestUpdateData| { &m.mm_game_mode },
                    |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.mm_game_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScoreLeaderboardData>>(
                    "missionlbsdata",
                    |m: &CMsgGC_ServerQuestUpdateData| { &m.missionlbsdata },
                    |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.missionlbsdata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGC_ServerQuestUpdateData>(
                    "CMsgGC_ServerQuestUpdateData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGC_ServerQuestUpdateData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGC_ServerQuestUpdateData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGC_ServerQuestUpdateData,
        };
        unsafe {
            instance.get(CMsgGC_ServerQuestUpdateData::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGC_ServerQuestUpdateData {
    fn clear(&mut self) {
        self.player_quest_data.clear();
        self.binary_data.clear();
        self.mm_game_mode = ::std::option::Option::None;
        self.missionlbsdata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_ServerQuestUpdateData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_ServerQuestUpdateData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    // message fields
    packetid: ::std::option::Option<i32>,
    namekeys: ::protobuf::RepeatedField<OperationalStatisticDescription>,
    packets: ::protobuf::RepeatedField<OperationalStatisticsPacket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        <CMsgGCCStrike15_v2_MatchmakingGCOperationalStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        ::std::default::Default::default()
    }

    // optional int32 packetid = 1;


    pub fn get_packetid(&self) -> i32 {
        self.packetid.unwrap_or(0)
    }
    pub fn clear_packetid(&mut self) {
        self.packetid = ::std::option::Option::None;
    }

    pub fn has_packetid(&self) -> bool {
        self.packetid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packetid(&mut self, v: i32) {
        self.packetid = ::std::option::Option::Some(v);
    }

    // repeated .OperationalStatisticDescription namekeys = 2;


    pub fn get_namekeys(&self) -> &[OperationalStatisticDescription] {
        &self.namekeys
    }
    pub fn clear_namekeys(&mut self) {
        self.namekeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_namekeys(&mut self, v: ::protobuf::RepeatedField<OperationalStatisticDescription>) {
        self.namekeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_namekeys(&mut self) -> &mut ::protobuf::RepeatedField<OperationalStatisticDescription> {
        &mut self.namekeys
    }

    // Take field
    pub fn take_namekeys(&mut self) -> ::protobuf::RepeatedField<OperationalStatisticDescription> {
        ::std::mem::replace(&mut self.namekeys, ::protobuf::RepeatedField::new())
    }

    // repeated .OperationalStatisticsPacket packets = 3;


    pub fn get_packets(&self) -> &[OperationalStatisticsPacket] {
        &self.packets
    }
    pub fn clear_packets(&mut self) {
        self.packets.clear();
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: ::protobuf::RepeatedField<OperationalStatisticsPacket>) {
        self.packets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packets(&mut self) -> &mut ::protobuf::RepeatedField<OperationalStatisticsPacket> {
        &mut self.packets
    }

    // Take field
    pub fn take_packets(&mut self) -> ::protobuf::RepeatedField<OperationalStatisticsPacket> {
        ::std::mem::replace(&mut self.packets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn is_initialized(&self) -> bool {
        for v in &self.namekeys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.packets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.packetid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.namekeys)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.packets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packetid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.namekeys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.packets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packetid {
            os.write_int32(1, v)?;
        }
        for v in &self.namekeys {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.packets {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "packetid",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &m.packetid },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &mut m.packetid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationalStatisticDescription>>(
                    "namekeys",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &m.namekeys },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &mut m.namekeys },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationalStatisticsPacket>>(
                    "packets",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &m.packets },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &mut m.packets },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGCOperationalStats>(
                    "CMsgGCCStrike15_v2_MatchmakingGCOperationalStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGCOperationalStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGCOperationalStats,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn clear(&mut self) {
        self.packetid = ::std::option::Option::None;
        self.namekeys.clear();
        self.packets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    // message fields
    token: ::std::option::Option<u32>,
    stamp: ::std::option::Option<u32>,
    exchange: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        <CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        ::std::default::Default::default()
    }

    // optional uint32 token = 1;


    pub fn get_token(&self) -> u32 {
        self.token.unwrap_or(0)
    }
    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }

    // optional uint32 stamp = 2;


    pub fn get_stamp(&self) -> u32 {
        self.stamp.unwrap_or(0)
    }
    pub fn clear_stamp(&mut self) {
        self.stamp = ::std::option::Option::None;
    }

    pub fn has_stamp(&self) -> bool {
        self.stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stamp(&mut self, v: u32) {
        self.stamp = ::std::option::Option::Some(v);
    }

    // optional uint64 exchange = 3;


    pub fn get_exchange(&self) -> u64 {
        self.exchange.unwrap_or(0)
    }
    pub fn clear_exchange(&mut self) {
        self.exchange = ::std::option::Option::None;
    }

    pub fn has_exchange(&self) -> bool {
        self.exchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exchange(&mut self, v: u64) {
        self.exchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.token = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.exchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.exchange {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.token {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.exchange {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "token",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &m.token },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &mut m.token },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stamp",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &m.stamp },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &mut m.stamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "exchange",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &m.exchange },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &mut m.exchange },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.stamp = ::std::option::Option::None;
        self.exchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    // message fields
    viewers_external_total: ::std::option::Option<u32>,
    viewers_external_steam: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        <CMsgGCCStrike15_v2_GC2ServerReservationUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 viewers_external_total = 1;


    pub fn get_viewers_external_total(&self) -> u32 {
        self.viewers_external_total.unwrap_or(0)
    }
    pub fn clear_viewers_external_total(&mut self) {
        self.viewers_external_total = ::std::option::Option::None;
    }

    pub fn has_viewers_external_total(&self) -> bool {
        self.viewers_external_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_external_total(&mut self, v: u32) {
        self.viewers_external_total = ::std::option::Option::Some(v);
    }

    // optional uint32 viewers_external_steam = 2;


    pub fn get_viewers_external_steam(&self) -> u32 {
        self.viewers_external_steam.unwrap_or(0)
    }
    pub fn clear_viewers_external_steam(&mut self) {
        self.viewers_external_steam = ::std::option::Option::None;
    }

    pub fn has_viewers_external_steam(&self) -> bool {
        self.viewers_external_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_external_steam(&mut self, v: u32) {
        self.viewers_external_steam = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.viewers_external_total = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.viewers_external_steam = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.viewers_external_total {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.viewers_external_steam {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.viewers_external_total {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.viewers_external_steam {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        CMsgGCCStrike15_v2_GC2ServerReservationUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "viewers_external_total",
                    |m: &CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &m.viewers_external_total },
                    |m: &mut CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &mut m.viewers_external_total },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "viewers_external_steam",
                    |m: &CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &m.viewers_external_steam },
                    |m: &mut CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &mut m.viewers_external_steam },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GC2ServerReservationUpdate>(
                    "CMsgGCCStrike15_v2_GC2ServerReservationUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GC2ServerReservationUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GC2ServerReservationUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GC2ServerReservationUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn clear(&mut self) {
        self.viewers_external_total = ::std::option::Option::None;
        self.viewers_external_steam = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingStart {
    // message fields
    account_ids: ::std::vec::Vec<u32>,
    game_type: ::std::option::Option<u32>,
    ticket_data: ::protobuf::SingularField<::std::string::String>,
    client_version: ::std::option::Option<u32>,
    tournament_match: ::protobuf::SingularPtrField<TournamentMatchSetup>,
    prime_only: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingStart {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingStart {
        <CMsgGCCStrike15_v2_MatchmakingStart as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingStart {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingStart {
        ::std::default::Default::default()
    }

    // repeated uint32 account_ids = 1;


    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }
    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    // optional uint32 game_type = 2;


    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }
    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional string ticket_data = 3;


    pub fn get_ticket_data(&self) -> &str {
        match self.ticket_data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ticket_data(&mut self) {
        self.ticket_data.clear();
    }

    pub fn has_ticket_data(&self) -> bool {
        self.ticket_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_data(&mut self, v: ::std::string::String) {
        self.ticket_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket_data(&mut self) -> &mut ::std::string::String {
        if self.ticket_data.is_none() {
            self.ticket_data.set_default();
        }
        self.ticket_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket_data(&mut self) -> ::std::string::String {
        self.ticket_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_version = 4;


    pub fn get_client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }
    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional .TournamentMatchSetup tournament_match = 5;


    pub fn get_tournament_match(&self) -> &TournamentMatchSetup {
        self.tournament_match.as_ref().unwrap_or_else(|| TournamentMatchSetup::default_instance())
    }
    pub fn clear_tournament_match(&mut self) {
        self.tournament_match.clear();
    }

    pub fn has_tournament_match(&self) -> bool {
        self.tournament_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_match(&mut self, v: TournamentMatchSetup) {
        self.tournament_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_match(&mut self) -> &mut TournamentMatchSetup {
        if self.tournament_match.is_none() {
            self.tournament_match.set_default();
        }
        self.tournament_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournament_match(&mut self) -> TournamentMatchSetup {
        self.tournament_match.take().unwrap_or_else(|| TournamentMatchSetup::new())
    }

    // optional bool prime_only = 6;


    pub fn get_prime_only(&self) -> bool {
        self.prime_only.unwrap_or(false)
    }
    pub fn clear_prime_only(&mut self) {
        self.prime_only = ::std::option::Option::None;
    }

    pub fn has_prime_only(&self) -> bool {
        self.prime_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prime_only(&mut self, v: bool) {
        self.prime_only = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingStart {
    fn is_initialized(&self) -> bool {
        for v in &self.tournament_match {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ticket_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_version = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tournament_match)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prime_only = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ticket_data.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tournament_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.prime_only {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.game_type {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.ticket_data.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.tournament_match.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.prime_only {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingStart {
        CMsgGCCStrike15_v2_MatchmakingStart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.account_ids },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.account_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.game_type },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.game_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ticket_data",
                    |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.ticket_data },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.ticket_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "client_version",
                    |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.client_version },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.client_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentMatchSetup>>(
                    "tournament_match",
                    |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.tournament_match },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.tournament_match },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prime_only",
                    |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.prime_only },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.prime_only },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingStart>(
                    "CMsgGCCStrike15_v2_MatchmakingStart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingStart {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingStart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingStart,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingStart::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingStart {
    fn clear(&mut self) {
        self.account_ids.clear();
        self.game_type = ::std::option::Option::None;
        self.ticket_data.clear();
        self.client_version = ::std::option::Option::None;
        self.tournament_match.clear();
        self.prime_only = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingStart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingStop {
    // message fields
    abandon: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingStop {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingStop {
        <CMsgGCCStrike15_v2_MatchmakingStop as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingStop {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingStop {
        ::std::default::Default::default()
    }

    // optional int32 abandon = 1;


    pub fn get_abandon(&self) -> i32 {
        self.abandon.unwrap_or(0)
    }
    pub fn clear_abandon(&mut self) {
        self.abandon = ::std::option::Option::None;
    }

    pub fn has_abandon(&self) -> bool {
        self.abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandon(&mut self, v: i32) {
        self.abandon = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingStop {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.abandon = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.abandon {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.abandon {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingStop {
        CMsgGCCStrike15_v2_MatchmakingStop::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "abandon",
                    |m: &CMsgGCCStrike15_v2_MatchmakingStop| { &m.abandon },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingStop| { &mut m.abandon },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingStop>(
                    "CMsgGCCStrike15_v2_MatchmakingStop",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingStop {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingStop> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingStop,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingStop::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingStop {
    fn clear(&mut self) {
        self.abandon = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingStop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    // message fields
    gameserverpings: ::protobuf::RepeatedField<GameServerPing>,
    offset_index: ::std::option::Option<i32>,
    final_batch: ::std::option::Option<i32>,
    data_center_pings: ::protobuf::RepeatedField<DataCenterPing>,
    max_ping: ::std::option::Option<u32>,
    test_token: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        <CMsgGCCStrike15_v2_MatchmakingClient2ServerPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        ::std::default::Default::default()
    }

    // repeated .GameServerPing gameserverpings = 1;


    pub fn get_gameserverpings(&self) -> &[GameServerPing] {
        &self.gameserverpings
    }
    pub fn clear_gameserverpings(&mut self) {
        self.gameserverpings.clear();
    }

    // Param is passed by value, moved
    pub fn set_gameserverpings(&mut self, v: ::protobuf::RepeatedField<GameServerPing>) {
        self.gameserverpings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gameserverpings(&mut self) -> &mut ::protobuf::RepeatedField<GameServerPing> {
        &mut self.gameserverpings
    }

    // Take field
    pub fn take_gameserverpings(&mut self) -> ::protobuf::RepeatedField<GameServerPing> {
        ::std::mem::replace(&mut self.gameserverpings, ::protobuf::RepeatedField::new())
    }

    // optional int32 offset_index = 2;


    pub fn get_offset_index(&self) -> i32 {
        self.offset_index.unwrap_or(0)
    }
    pub fn clear_offset_index(&mut self) {
        self.offset_index = ::std::option::Option::None;
    }

    pub fn has_offset_index(&self) -> bool {
        self.offset_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset_index(&mut self, v: i32) {
        self.offset_index = ::std::option::Option::Some(v);
    }

    // optional int32 final_batch = 3;


    pub fn get_final_batch(&self) -> i32 {
        self.final_batch.unwrap_or(0)
    }
    pub fn clear_final_batch(&mut self) {
        self.final_batch = ::std::option::Option::None;
    }

    pub fn has_final_batch(&self) -> bool {
        self.final_batch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_final_batch(&mut self, v: i32) {
        self.final_batch = ::std::option::Option::Some(v);
    }

    // repeated .DataCenterPing data_center_pings = 4;


    pub fn get_data_center_pings(&self) -> &[DataCenterPing] {
        &self.data_center_pings
    }
    pub fn clear_data_center_pings(&mut self) {
        self.data_center_pings.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_center_pings(&mut self, v: ::protobuf::RepeatedField<DataCenterPing>) {
        self.data_center_pings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_center_pings(&mut self) -> &mut ::protobuf::RepeatedField<DataCenterPing> {
        &mut self.data_center_pings
    }

    // Take field
    pub fn take_data_center_pings(&mut self) -> ::protobuf::RepeatedField<DataCenterPing> {
        ::std::mem::replace(&mut self.data_center_pings, ::protobuf::RepeatedField::new())
    }

    // optional uint32 max_ping = 5;


    pub fn get_max_ping(&self) -> u32 {
        self.max_ping.unwrap_or(0)
    }
    pub fn clear_max_ping(&mut self) {
        self.max_ping = ::std::option::Option::None;
    }

    pub fn has_max_ping(&self) -> bool {
        self.max_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_ping(&mut self, v: u32) {
        self.max_ping = ::std::option::Option::Some(v);
    }

    // optional fixed32 test_token = 6;


    pub fn get_test_token(&self) -> u32 {
        self.test_token.unwrap_or(0)
    }
    pub fn clear_test_token(&mut self) {
        self.test_token = ::std::option::Option::None;
    }

    pub fn has_test_token(&self) -> bool {
        self.test_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_token(&mut self, v: u32) {
        self.test_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn is_initialized(&self) -> bool {
        for v in &self.gameserverpings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data_center_pings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gameserverpings)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offset_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_batch = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_center_pings)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_ping = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.test_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gameserverpings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.offset_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.final_batch {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.data_center_pings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.max_ping {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.test_token {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gameserverpings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.offset_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.final_batch {
            os.write_int32(3, v)?;
        }
        for v in &self.data_center_pings {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.max_ping {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.test_token {
            os.write_fixed32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GameServerPing>>(
                    "gameserverpings",
                    |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.gameserverpings },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.gameserverpings },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "offset_index",
                    |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.offset_index },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.offset_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "final_batch",
                    |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.final_batch },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.final_batch },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataCenterPing>>(
                    "data_center_pings",
                    |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.data_center_pings },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.data_center_pings },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_ping",
                    |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.max_ping },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.max_ping },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "test_token",
                    |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.test_token },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.test_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingClient2ServerPing>(
                    "CMsgGCCStrike15_v2_MatchmakingClient2ServerPing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingClient2ServerPing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingClient2ServerPing,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn clear(&mut self) {
        self.gameserverpings.clear();
        self.offset_index = ::std::option::Option::None;
        self.final_batch = ::std::option::Option::None;
        self.data_center_pings.clear();
        self.max_ping = ::std::option::Option::None;
        self.test_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    // message fields
    matchmaking: ::std::option::Option<i32>,
    waiting_account_id_sessions: ::std::vec::Vec<u32>,
    error: ::protobuf::SingularField<::std::string::String>,
    ongoingmatch_account_id_sessions: ::std::vec::Vec<u32>,
    global_stats: ::protobuf::SingularPtrField<GlobalStatistics>,
    failping_account_id_sessions: ::std::vec::Vec<u32>,
    penalty_account_id_sessions: ::std::vec::Vec<u32>,
    failready_account_id_sessions: ::std::vec::Vec<u32>,
    vacbanned_account_id_sessions: ::std::vec::Vec<u32>,
    server_ipaddress_mask: ::protobuf::SingularPtrField<IpAddressMask>,
    notes: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>,
    penalty_account_id_sessions_green: ::std::vec::Vec<u32>,
    insufficientlevel_sessions: ::std::vec::Vec<u32>,
    vsncheck_account_id_sessions: ::std::vec::Vec<u32>,
    launcher_mismatch_sessions: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        ::std::default::Default::default()
    }

    // optional int32 matchmaking = 1;


    pub fn get_matchmaking(&self) -> i32 {
        self.matchmaking.unwrap_or(0)
    }
    pub fn clear_matchmaking(&mut self) {
        self.matchmaking = ::std::option::Option::None;
    }

    pub fn has_matchmaking(&self) -> bool {
        self.matchmaking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking(&mut self, v: i32) {
        self.matchmaking = ::std::option::Option::Some(v);
    }

    // repeated uint32 waiting_account_id_sessions = 2;


    pub fn get_waiting_account_id_sessions(&self) -> &[u32] {
        &self.waiting_account_id_sessions
    }
    pub fn clear_waiting_account_id_sessions(&mut self) {
        self.waiting_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_waiting_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.waiting_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_waiting_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.waiting_account_id_sessions
    }

    // Take field
    pub fn take_waiting_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.waiting_account_id_sessions, ::std::vec::Vec::new())
    }

    // optional string error = 3;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint32 ongoingmatch_account_id_sessions = 6;


    pub fn get_ongoingmatch_account_id_sessions(&self) -> &[u32] {
        &self.ongoingmatch_account_id_sessions
    }
    pub fn clear_ongoingmatch_account_id_sessions(&mut self) {
        self.ongoingmatch_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_ongoingmatch_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.ongoingmatch_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ongoingmatch_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ongoingmatch_account_id_sessions
    }

    // Take field
    pub fn take_ongoingmatch_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ongoingmatch_account_id_sessions, ::std::vec::Vec::new())
    }

    // optional .GlobalStatistics global_stats = 7;


    pub fn get_global_stats(&self) -> &GlobalStatistics {
        self.global_stats.as_ref().unwrap_or_else(|| GlobalStatistics::default_instance())
    }
    pub fn clear_global_stats(&mut self) {
        self.global_stats.clear();
    }

    pub fn has_global_stats(&self) -> bool {
        self.global_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_stats(&mut self, v: GlobalStatistics) {
        self.global_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global_stats(&mut self) -> &mut GlobalStatistics {
        if self.global_stats.is_none() {
            self.global_stats.set_default();
        }
        self.global_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_global_stats(&mut self) -> GlobalStatistics {
        self.global_stats.take().unwrap_or_else(|| GlobalStatistics::new())
    }

    // repeated uint32 failping_account_id_sessions = 8;


    pub fn get_failping_account_id_sessions(&self) -> &[u32] {
        &self.failping_account_id_sessions
    }
    pub fn clear_failping_account_id_sessions(&mut self) {
        self.failping_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_failping_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.failping_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failping_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.failping_account_id_sessions
    }

    // Take field
    pub fn take_failping_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.failping_account_id_sessions, ::std::vec::Vec::new())
    }

    // repeated uint32 penalty_account_id_sessions = 9;


    pub fn get_penalty_account_id_sessions(&self) -> &[u32] {
        &self.penalty_account_id_sessions
    }
    pub fn clear_penalty_account_id_sessions(&mut self) {
        self.penalty_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_penalty_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.penalty_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_penalty_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.penalty_account_id_sessions
    }

    // Take field
    pub fn take_penalty_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.penalty_account_id_sessions, ::std::vec::Vec::new())
    }

    // repeated uint32 failready_account_id_sessions = 10;


    pub fn get_failready_account_id_sessions(&self) -> &[u32] {
        &self.failready_account_id_sessions
    }
    pub fn clear_failready_account_id_sessions(&mut self) {
        self.failready_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_failready_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.failready_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failready_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.failready_account_id_sessions
    }

    // Take field
    pub fn take_failready_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.failready_account_id_sessions, ::std::vec::Vec::new())
    }

    // repeated uint32 vacbanned_account_id_sessions = 11;


    pub fn get_vacbanned_account_id_sessions(&self) -> &[u32] {
        &self.vacbanned_account_id_sessions
    }
    pub fn clear_vacbanned_account_id_sessions(&mut self) {
        self.vacbanned_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_vacbanned_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.vacbanned_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vacbanned_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.vacbanned_account_id_sessions
    }

    // Take field
    pub fn take_vacbanned_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.vacbanned_account_id_sessions, ::std::vec::Vec::new())
    }

    // optional .IpAddressMask server_ipaddress_mask = 12;


    pub fn get_server_ipaddress_mask(&self) -> &IpAddressMask {
        self.server_ipaddress_mask.as_ref().unwrap_or_else(|| IpAddressMask::default_instance())
    }
    pub fn clear_server_ipaddress_mask(&mut self) {
        self.server_ipaddress_mask.clear();
    }

    pub fn has_server_ipaddress_mask(&self) -> bool {
        self.server_ipaddress_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ipaddress_mask(&mut self, v: IpAddressMask) {
        self.server_ipaddress_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_ipaddress_mask(&mut self) -> &mut IpAddressMask {
        if self.server_ipaddress_mask.is_none() {
            self.server_ipaddress_mask.set_default();
        }
        self.server_ipaddress_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_ipaddress_mask(&mut self) -> IpAddressMask {
        self.server_ipaddress_mask.take().unwrap_or_else(|| IpAddressMask::new())
    }

    // repeated .CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note notes = 13;


    pub fn get_notes(&self) -> &[CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note] {
        &self.notes
    }
    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note> {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note> {
        ::std::mem::replace(&mut self.notes, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 penalty_account_id_sessions_green = 14;


    pub fn get_penalty_account_id_sessions_green(&self) -> &[u32] {
        &self.penalty_account_id_sessions_green
    }
    pub fn clear_penalty_account_id_sessions_green(&mut self) {
        self.penalty_account_id_sessions_green.clear();
    }

    // Param is passed by value, moved
    pub fn set_penalty_account_id_sessions_green(&mut self, v: ::std::vec::Vec<u32>) {
        self.penalty_account_id_sessions_green = v;
    }

    // Mutable pointer to the field.
    pub fn mut_penalty_account_id_sessions_green(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.penalty_account_id_sessions_green
    }

    // Take field
    pub fn take_penalty_account_id_sessions_green(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.penalty_account_id_sessions_green, ::std::vec::Vec::new())
    }

    // repeated uint32 insufficientlevel_sessions = 15;


    pub fn get_insufficientlevel_sessions(&self) -> &[u32] {
        &self.insufficientlevel_sessions
    }
    pub fn clear_insufficientlevel_sessions(&mut self) {
        self.insufficientlevel_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_insufficientlevel_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.insufficientlevel_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_insufficientlevel_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.insufficientlevel_sessions
    }

    // Take field
    pub fn take_insufficientlevel_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.insufficientlevel_sessions, ::std::vec::Vec::new())
    }

    // repeated uint32 vsncheck_account_id_sessions = 16;


    pub fn get_vsncheck_account_id_sessions(&self) -> &[u32] {
        &self.vsncheck_account_id_sessions
    }
    pub fn clear_vsncheck_account_id_sessions(&mut self) {
        self.vsncheck_account_id_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_vsncheck_account_id_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.vsncheck_account_id_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vsncheck_account_id_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.vsncheck_account_id_sessions
    }

    // Take field
    pub fn take_vsncheck_account_id_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.vsncheck_account_id_sessions, ::std::vec::Vec::new())
    }

    // repeated uint32 launcher_mismatch_sessions = 17;


    pub fn get_launcher_mismatch_sessions(&self) -> &[u32] {
        &self.launcher_mismatch_sessions
    }
    pub fn clear_launcher_mismatch_sessions(&mut self) {
        self.launcher_mismatch_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_launcher_mismatch_sessions(&mut self, v: ::std::vec::Vec<u32>) {
        self.launcher_mismatch_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_launcher_mismatch_sessions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.launcher_mismatch_sessions
    }

    // Take field
    pub fn take_launcher_mismatch_sessions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.launcher_mismatch_sessions, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.global_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.server_ipaddress_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.notes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.matchmaking = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.waiting_account_id_sessions)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.ongoingmatch_account_id_sessions)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.global_stats)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.failping_account_id_sessions)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.penalty_account_id_sessions)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.failready_account_id_sessions)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.vacbanned_account_id_sessions)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_ipaddress_mask)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notes)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.penalty_account_id_sessions_green)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.insufficientlevel_sessions)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.vsncheck_account_id_sessions)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.launcher_mismatch_sessions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.matchmaking {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.waiting_account_id_sessions {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.ongoingmatch_account_id_sessions {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.failping_account_id_sessions {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.penalty_account_id_sessions {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.failready_account_id_sessions {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.vacbanned_account_id_sessions {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.server_ipaddress_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.notes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.penalty_account_id_sessions_green {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.insufficientlevel_sessions {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.vsncheck_account_id_sessions {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.launcher_mismatch_sessions {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.matchmaking {
            os.write_int32(1, v)?;
        }
        for v in &self.waiting_account_id_sessions {
            os.write_uint32(2, *v)?;
        };
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.ongoingmatch_account_id_sessions {
            os.write_uint32(6, *v)?;
        };
        if let Some(ref v) = self.global_stats.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.failping_account_id_sessions {
            os.write_uint32(8, *v)?;
        };
        for v in &self.penalty_account_id_sessions {
            os.write_uint32(9, *v)?;
        };
        for v in &self.failready_account_id_sessions {
            os.write_uint32(10, *v)?;
        };
        for v in &self.vacbanned_account_id_sessions {
            os.write_uint32(11, *v)?;
        };
        if let Some(ref v) = self.server_ipaddress_mask.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.notes {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.penalty_account_id_sessions_green {
            os.write_uint32(14, *v)?;
        };
        for v in &self.insufficientlevel_sessions {
            os.write_uint32(15, *v)?;
        };
        for v in &self.vsncheck_account_id_sessions {
            os.write_uint32(16, *v)?;
        };
        for v in &self.launcher_mismatch_sessions {
            os.write_uint32(17, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "matchmaking",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.matchmaking },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.matchmaking },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "waiting_account_id_sessions",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.waiting_account_id_sessions },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.waiting_account_id_sessions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.error },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ongoingmatch_account_id_sessions",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.ongoingmatch_account_id_sessions },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.ongoingmatch_account_id_sessions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlobalStatistics>>(
                    "global_stats",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.global_stats },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.global_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "failping_account_id_sessions",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.failping_account_id_sessions },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.failping_account_id_sessions },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_account_id_sessions",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.penalty_account_id_sessions },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.penalty_account_id_sessions },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "failready_account_id_sessions",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.failready_account_id_sessions },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.failready_account_id_sessions },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vacbanned_account_id_sessions",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.vacbanned_account_id_sessions },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.vacbanned_account_id_sessions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IpAddressMask>>(
                    "server_ipaddress_mask",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.server_ipaddress_mask },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.server_ipaddress_mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>>(
                    "notes",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.notes },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.notes },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_account_id_sessions_green",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.penalty_account_id_sessions_green },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.penalty_account_id_sessions_green },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "insufficientlevel_sessions",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.insufficientlevel_sessions },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.insufficientlevel_sessions },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vsncheck_account_id_sessions",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.vsncheck_account_id_sessions },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.vsncheck_account_id_sessions },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "launcher_mismatch_sessions",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.launcher_mismatch_sessions },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.launcher_mismatch_sessions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn clear(&mut self) {
        self.matchmaking = ::std::option::Option::None;
        self.waiting_account_id_sessions.clear();
        self.error.clear();
        self.ongoingmatch_account_id_sessions.clear();
        self.global_stats.clear();
        self.failping_account_id_sessions.clear();
        self.penalty_account_id_sessions.clear();
        self.failready_account_id_sessions.clear();
        self.vacbanned_account_id_sessions.clear();
        self.server_ipaddress_mask.clear();
        self.notes.clear();
        self.penalty_account_id_sessions_green.clear();
        self.insufficientlevel_sessions.clear();
        self.vsncheck_account_id_sessions.clear();
        self.launcher_mismatch_sessions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    // message fields
    field_type: ::std::option::Option<i32>,
    region_id: ::std::option::Option<i32>,
    region_r: ::std::option::Option<f32>,
    distance: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional int32 region_id = 2;


    pub fn get_region_id(&self) -> i32 {
        self.region_id.unwrap_or(0)
    }
    pub fn clear_region_id(&mut self) {
        self.region_id = ::std::option::Option::None;
    }

    pub fn has_region_id(&self) -> bool {
        self.region_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: i32) {
        self.region_id = ::std::option::Option::Some(v);
    }

    // optional float region_r = 3;


    pub fn get_region_r(&self) -> f32 {
        self.region_r.unwrap_or(0.)
    }
    pub fn clear_region_r(&mut self) {
        self.region_r = ::std::option::Option::None;
    }

    pub fn has_region_r(&self) -> bool {
        self.region_r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_r(&mut self, v: f32) {
        self.region_r = ::std::option::Option::Some(v);
    }

    // optional float distance = 4;


    pub fn get_distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }
    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.region_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.region_r = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.distance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.region_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.region_r {
            my_size += 5;
        }
        if let Some(v) = self.distance {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.region_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.region_r {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.distance {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &m.field_type },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "region_id",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &m.region_id },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &mut m.region_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "region_r",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &m.region_r },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &mut m.region_r },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "distance",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &m.distance },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &mut m.distance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.region_id = ::std::option::Option::None;
        self.region_r = ::std::option::Option::None;
        self.distance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentMatchDraft {
    // message fields
    event_id: ::std::option::Option<i32>,
    event_stage_id: ::std::option::Option<i32>,
    team_id_0: ::std::option::Option<i32>,
    team_id_1: ::std::option::Option<i32>,
    maps_count: ::std::option::Option<i32>,
    maps_current: ::std::option::Option<i32>,
    team_id_start: ::std::option::Option<i32>,
    team_id_veto1: ::std::option::Option<i32>,
    team_id_pickn: ::std::option::Option<i32>,
    drafts: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentMatchDraft_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentMatchDraft {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentMatchDraft {
        <CDataGCCStrike15_v2_TournamentMatchDraft as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentMatchDraft {
    pub fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft {
        ::std::default::Default::default()
    }

    // optional int32 event_id = 1;


    pub fn get_event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional int32 event_stage_id = 2;


    pub fn get_event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }
    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_0 = 3;


    pub fn get_team_id_0(&self) -> i32 {
        self.team_id_0.unwrap_or(0)
    }
    pub fn clear_team_id_0(&mut self) {
        self.team_id_0 = ::std::option::Option::None;
    }

    pub fn has_team_id_0(&self) -> bool {
        self.team_id_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_0(&mut self, v: i32) {
        self.team_id_0 = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_1 = 4;


    pub fn get_team_id_1(&self) -> i32 {
        self.team_id_1.unwrap_or(0)
    }
    pub fn clear_team_id_1(&mut self) {
        self.team_id_1 = ::std::option::Option::None;
    }

    pub fn has_team_id_1(&self) -> bool {
        self.team_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_1(&mut self, v: i32) {
        self.team_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 maps_count = 5;


    pub fn get_maps_count(&self) -> i32 {
        self.maps_count.unwrap_or(0)
    }
    pub fn clear_maps_count(&mut self) {
        self.maps_count = ::std::option::Option::None;
    }

    pub fn has_maps_count(&self) -> bool {
        self.maps_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maps_count(&mut self, v: i32) {
        self.maps_count = ::std::option::Option::Some(v);
    }

    // optional int32 maps_current = 6;


    pub fn get_maps_current(&self) -> i32 {
        self.maps_current.unwrap_or(0)
    }
    pub fn clear_maps_current(&mut self) {
        self.maps_current = ::std::option::Option::None;
    }

    pub fn has_maps_current(&self) -> bool {
        self.maps_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maps_current(&mut self, v: i32) {
        self.maps_current = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_start = 7;


    pub fn get_team_id_start(&self) -> i32 {
        self.team_id_start.unwrap_or(0)
    }
    pub fn clear_team_id_start(&mut self) {
        self.team_id_start = ::std::option::Option::None;
    }

    pub fn has_team_id_start(&self) -> bool {
        self.team_id_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_start(&mut self, v: i32) {
        self.team_id_start = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_veto1 = 8;


    pub fn get_team_id_veto1(&self) -> i32 {
        self.team_id_veto1.unwrap_or(0)
    }
    pub fn clear_team_id_veto1(&mut self) {
        self.team_id_veto1 = ::std::option::Option::None;
    }

    pub fn has_team_id_veto1(&self) -> bool {
        self.team_id_veto1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_veto1(&mut self, v: i32) {
        self.team_id_veto1 = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_pickn = 9;


    pub fn get_team_id_pickn(&self) -> i32 {
        self.team_id_pickn.unwrap_or(0)
    }
    pub fn clear_team_id_pickn(&mut self) {
        self.team_id_pickn = ::std::option::Option::None;
    }

    pub fn has_team_id_pickn(&self) -> bool {
        self.team_id_pickn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_pickn(&mut self, v: i32) {
        self.team_id_pickn = ::std::option::Option::Some(v);
    }

    // repeated .CDataGCCStrike15_v2_TournamentMatchDraft.Entry drafts = 10;


    pub fn get_drafts(&self) -> &[CDataGCCStrike15_v2_TournamentMatchDraft_Entry] {
        &self.drafts
    }
    pub fn clear_drafts(&mut self) {
        self.drafts.clear();
    }

    // Param is passed by value, moved
    pub fn set_drafts(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentMatchDraft_Entry>) {
        self.drafts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drafts(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentMatchDraft_Entry> {
        &mut self.drafts
    }

    // Take field
    pub fn take_drafts(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentMatchDraft_Entry> {
        ::std::mem::replace(&mut self.drafts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn is_initialized(&self) -> bool {
        for v in &self.drafts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_stage_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_0 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_1 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maps_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maps_current = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_start = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_veto1 = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_pickn = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.drafts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_0 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_1 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maps_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maps_current {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_start {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_veto1 {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_pickn {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.drafts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team_id_0 {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.team_id_1 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.maps_count {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.maps_current {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.team_id_start {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.team_id_veto1 {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.team_id_pickn {
            os.write_int32(9, v)?;
        }
        for v in &self.drafts {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft {
        CDataGCCStrike15_v2_TournamentMatchDraft::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_id",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.event_id },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.event_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_stage_id",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.event_stage_id },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.event_stage_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_0",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_0 },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_0 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_1",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_1 },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maps_count",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.maps_count },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.maps_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maps_current",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.maps_current },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.maps_current },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_start",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_start },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_start },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_veto1",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_veto1 },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_veto1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_pickn",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_pickn },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_pickn },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentMatchDraft_Entry>>(
                    "drafts",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.drafts },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.drafts },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentMatchDraft>(
                    "CDataGCCStrike15_v2_TournamentMatchDraft",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentMatchDraft {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentMatchDraft> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentMatchDraft,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentMatchDraft::new)
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.event_stage_id = ::std::option::Option::None;
        self.team_id_0 = ::std::option::Option::None;
        self.team_id_1 = ::std::option::Option::None;
        self.maps_count = ::std::option::Option::None;
        self.maps_current = ::std::option::Option::None;
        self.team_id_start = ::std::option::Option::None;
        self.team_id_veto1 = ::std::option::Option::None;
        self.team_id_pickn = ::std::option::Option::None;
        self.drafts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    // message fields
    mapid: ::std::option::Option<i32>,
    team_id_ct: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
        <CDataGCCStrike15_v2_TournamentMatchDraft_Entry as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    pub fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
        ::std::default::Default::default()
    }

    // optional int32 mapid = 1;


    pub fn get_mapid(&self) -> i32 {
        self.mapid.unwrap_or(0)
    }
    pub fn clear_mapid(&mut self) {
        self.mapid = ::std::option::Option::None;
    }

    pub fn has_mapid(&self) -> bool {
        self.mapid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mapid(&mut self, v: i32) {
        self.mapid = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_ct = 2;


    pub fn get_team_id_ct(&self) -> i32 {
        self.team_id_ct.unwrap_or(0)
    }
    pub fn clear_team_id_ct(&mut self) {
        self.team_id_ct = ::std::option::Option::None;
    }

    pub fn has_team_id_ct(&self) -> bool {
        self.team_id_ct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_ct(&mut self, v: i32) {
        self.team_id_ct = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mapid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id_ct = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mapid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id_ct {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mapid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id_ct {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
        CDataGCCStrike15_v2_TournamentMatchDraft_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mapid",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft_Entry| { &m.mapid },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft_Entry| { &mut m.mapid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id_ct",
                    |m: &CDataGCCStrike15_v2_TournamentMatchDraft_Entry| { &m.team_id_ct },
                    |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft_Entry| { &mut m.team_id_ct },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentMatchDraft_Entry>(
                    "CDataGCCStrike15_v2_TournamentMatchDraft_Entry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentMatchDraft_Entry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentMatchDraft_Entry,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentMatchDraft_Entry::new)
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    fn clear(&mut self) {
        self.mapid = ::std::option::Option::None;
        self.team_id_ct = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentMatchDraft_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPreMatchInfoData {
    // message fields
    predictions_pct: ::std::option::Option<i32>,
    draft: ::protobuf::SingularPtrField<CDataGCCStrike15_v2_TournamentMatchDraft>,
    stats: ::protobuf::RepeatedField<CPreMatchInfoData_TeamStats>,
    wins: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPreMatchInfoData {
    fn default() -> &'a CPreMatchInfoData {
        <CPreMatchInfoData as ::protobuf::Message>::default_instance()
    }
}

impl CPreMatchInfoData {
    pub fn new() -> CPreMatchInfoData {
        ::std::default::Default::default()
    }

    // optional int32 predictions_pct = 1;


    pub fn get_predictions_pct(&self) -> i32 {
        self.predictions_pct.unwrap_or(0)
    }
    pub fn clear_predictions_pct(&mut self) {
        self.predictions_pct = ::std::option::Option::None;
    }

    pub fn has_predictions_pct(&self) -> bool {
        self.predictions_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predictions_pct(&mut self, v: i32) {
        self.predictions_pct = ::std::option::Option::Some(v);
    }

    // optional .CDataGCCStrike15_v2_TournamentMatchDraft draft = 4;


    pub fn get_draft(&self) -> &CDataGCCStrike15_v2_TournamentMatchDraft {
        self.draft.as_ref().unwrap_or_else(|| CDataGCCStrike15_v2_TournamentMatchDraft::default_instance())
    }
    pub fn clear_draft(&mut self) {
        self.draft.clear();
    }

    pub fn has_draft(&self) -> bool {
        self.draft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_draft(&mut self, v: CDataGCCStrike15_v2_TournamentMatchDraft) {
        self.draft = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_draft(&mut self) -> &mut CDataGCCStrike15_v2_TournamentMatchDraft {
        if self.draft.is_none() {
            self.draft.set_default();
        }
        self.draft.as_mut().unwrap()
    }

    // Take field
    pub fn take_draft(&mut self) -> CDataGCCStrike15_v2_TournamentMatchDraft {
        self.draft.take().unwrap_or_else(|| CDataGCCStrike15_v2_TournamentMatchDraft::new())
    }

    // repeated .CPreMatchInfoData.TeamStats stats = 5;


    pub fn get_stats(&self) -> &[CPreMatchInfoData_TeamStats] {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CPreMatchInfoData_TeamStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CPreMatchInfoData_TeamStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CPreMatchInfoData_TeamStats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    // repeated int32 wins = 6;


    pub fn get_wins(&self) -> &[i32] {
        &self.wins
    }
    pub fn clear_wins(&mut self) {
        self.wins.clear();
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: ::std::vec::Vec<i32>) {
        self.wins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_wins(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.wins
    }

    // Take field
    pub fn take_wins(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.wins, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPreMatchInfoData {
    fn is_initialized(&self) -> bool {
        for v in &self.draft {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.predictions_pct = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.draft)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.wins)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.predictions_pct {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.draft.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.wins {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.predictions_pct {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.draft.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stats {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.wins {
            os.write_int32(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPreMatchInfoData {
        CPreMatchInfoData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "predictions_pct",
                    |m: &CPreMatchInfoData| { &m.predictions_pct },
                    |m: &mut CPreMatchInfoData| { &mut m.predictions_pct },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentMatchDraft>>(
                    "draft",
                    |m: &CPreMatchInfoData| { &m.draft },
                    |m: &mut CPreMatchInfoData| { &mut m.draft },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPreMatchInfoData_TeamStats>>(
                    "stats",
                    |m: &CPreMatchInfoData| { &m.stats },
                    |m: &mut CPreMatchInfoData| { &mut m.stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "wins",
                    |m: &CPreMatchInfoData| { &m.wins },
                    |m: &mut CPreMatchInfoData| { &mut m.wins },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPreMatchInfoData>(
                    "CPreMatchInfoData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPreMatchInfoData {
        static mut instance: ::protobuf::lazy::Lazy<CPreMatchInfoData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPreMatchInfoData,
        };
        unsafe {
            instance.get(CPreMatchInfoData::new)
        }
    }
}

impl ::protobuf::Clear for CPreMatchInfoData {
    fn clear(&mut self) {
        self.predictions_pct = ::std::option::Option::None;
        self.draft.clear();
        self.stats.clear();
        self.wins.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPreMatchInfoData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPreMatchInfoData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPreMatchInfoData_TeamStats {
    // message fields
    match_info_idxtxt: ::std::option::Option<i32>,
    match_info_txt: ::protobuf::SingularField<::std::string::String>,
    match_info_teams: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPreMatchInfoData_TeamStats {
    fn default() -> &'a CPreMatchInfoData_TeamStats {
        <CPreMatchInfoData_TeamStats as ::protobuf::Message>::default_instance()
    }
}

impl CPreMatchInfoData_TeamStats {
    pub fn new() -> CPreMatchInfoData_TeamStats {
        ::std::default::Default::default()
    }

    // optional int32 match_info_idxtxt = 1;


    pub fn get_match_info_idxtxt(&self) -> i32 {
        self.match_info_idxtxt.unwrap_or(0)
    }
    pub fn clear_match_info_idxtxt(&mut self) {
        self.match_info_idxtxt = ::std::option::Option::None;
    }

    pub fn has_match_info_idxtxt(&self) -> bool {
        self.match_info_idxtxt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_info_idxtxt(&mut self, v: i32) {
        self.match_info_idxtxt = ::std::option::Option::Some(v);
    }

    // optional string match_info_txt = 2;


    pub fn get_match_info_txt(&self) -> &str {
        match self.match_info_txt.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_match_info_txt(&mut self) {
        self.match_info_txt.clear();
    }

    pub fn has_match_info_txt(&self) -> bool {
        self.match_info_txt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_info_txt(&mut self, v: ::std::string::String) {
        self.match_info_txt = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_info_txt(&mut self) -> &mut ::std::string::String {
        if self.match_info_txt.is_none() {
            self.match_info_txt.set_default();
        }
        self.match_info_txt.as_mut().unwrap()
    }

    // Take field
    pub fn take_match_info_txt(&mut self) -> ::std::string::String {
        self.match_info_txt.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string match_info_teams = 3;


    pub fn get_match_info_teams(&self) -> &[::std::string::String] {
        &self.match_info_teams
    }
    pub fn clear_match_info_teams(&mut self) {
        self.match_info_teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_info_teams(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.match_info_teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_match_info_teams(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.match_info_teams
    }

    // Take field
    pub fn take_match_info_teams(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.match_info_teams, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPreMatchInfoData_TeamStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_info_idxtxt = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.match_info_txt)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.match_info_teams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_info_idxtxt {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.match_info_txt.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.match_info_teams {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_info_idxtxt {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.match_info_txt.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.match_info_teams {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPreMatchInfoData_TeamStats {
        CPreMatchInfoData_TeamStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "match_info_idxtxt",
                    |m: &CPreMatchInfoData_TeamStats| { &m.match_info_idxtxt },
                    |m: &mut CPreMatchInfoData_TeamStats| { &mut m.match_info_idxtxt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_info_txt",
                    |m: &CPreMatchInfoData_TeamStats| { &m.match_info_txt },
                    |m: &mut CPreMatchInfoData_TeamStats| { &mut m.match_info_txt },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_info_teams",
                    |m: &CPreMatchInfoData_TeamStats| { &m.match_info_teams },
                    |m: &mut CPreMatchInfoData_TeamStats| { &mut m.match_info_teams },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPreMatchInfoData_TeamStats>(
                    "CPreMatchInfoData_TeamStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPreMatchInfoData_TeamStats {
        static mut instance: ::protobuf::lazy::Lazy<CPreMatchInfoData_TeamStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPreMatchInfoData_TeamStats,
        };
        unsafe {
            instance.get(CPreMatchInfoData_TeamStats::new)
        }
    }
}

impl ::protobuf::Clear for CPreMatchInfoData_TeamStats {
    fn clear(&mut self) {
        self.match_info_idxtxt = ::std::option::Option::None;
        self.match_info_txt.clear();
        self.match_info_teams.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPreMatchInfoData_TeamStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPreMatchInfoData_TeamStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    // message fields
    account_ids: ::std::vec::Vec<u32>,
    game_type: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    server_version: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    rankings: ::protobuf::RepeatedField<PlayerRankingInfo>,
    encryption_key: ::std::option::Option<u64>,
    encryption_key_pub: ::std::option::Option<u64>,
    party_ids: ::std::vec::Vec<u32>,
    whitelist: ::protobuf::RepeatedField<IpAddressMask>,
    tv_master_steamid: ::std::option::Option<u64>,
    tournament_event: ::protobuf::SingularPtrField<TournamentEvent>,
    tournament_teams: ::protobuf::RepeatedField<TournamentTeam>,
    tournament_casters_account_ids: ::std::vec::Vec<u32>,
    tv_relay_steamid: ::std::option::Option<u64>,
    pre_match_data: ::protobuf::SingularPtrField<CPreMatchInfoData>,
    rtime32_event_start: ::std::option::Option<u32>,
    tv_control: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        <CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        ::std::default::Default::default()
    }

    // repeated uint32 account_ids = 1;


    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }
    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    // optional uint32 game_type = 2;


    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }
    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 3;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 4;


    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }
    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 18;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // repeated .PlayerRankingInfo rankings = 5;


    pub fn get_rankings(&self) -> &[PlayerRankingInfo] {
        &self.rankings
    }
    pub fn clear_rankings(&mut self) {
        self.rankings.clear();
    }

    // Param is passed by value, moved
    pub fn set_rankings(&mut self, v: ::protobuf::RepeatedField<PlayerRankingInfo>) {
        self.rankings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rankings(&mut self) -> &mut ::protobuf::RepeatedField<PlayerRankingInfo> {
        &mut self.rankings
    }

    // Take field
    pub fn take_rankings(&mut self) -> ::protobuf::RepeatedField<PlayerRankingInfo> {
        ::std::mem::replace(&mut self.rankings, ::protobuf::RepeatedField::new())
    }

    // optional uint64 encryption_key = 6;


    pub fn get_encryption_key(&self) -> u64 {
        self.encryption_key.unwrap_or(0)
    }
    pub fn clear_encryption_key(&mut self) {
        self.encryption_key = ::std::option::Option::None;
    }

    pub fn has_encryption_key(&self) -> bool {
        self.encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key(&mut self, v: u64) {
        self.encryption_key = ::std::option::Option::Some(v);
    }

    // optional uint64 encryption_key_pub = 7;


    pub fn get_encryption_key_pub(&self) -> u64 {
        self.encryption_key_pub.unwrap_or(0)
    }
    pub fn clear_encryption_key_pub(&mut self) {
        self.encryption_key_pub = ::std::option::Option::None;
    }

    pub fn has_encryption_key_pub(&self) -> bool {
        self.encryption_key_pub.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key_pub(&mut self, v: u64) {
        self.encryption_key_pub = ::std::option::Option::Some(v);
    }

    // repeated uint32 party_ids = 8;


    pub fn get_party_ids(&self) -> &[u32] {
        &self.party_ids
    }
    pub fn clear_party_ids(&mut self) {
        self.party_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_party_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.party_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_party_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.party_ids
    }

    // Take field
    pub fn take_party_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.party_ids, ::std::vec::Vec::new())
    }

    // repeated .IpAddressMask whitelist = 9;


    pub fn get_whitelist(&self) -> &[IpAddressMask] {
        &self.whitelist
    }
    pub fn clear_whitelist(&mut self) {
        self.whitelist.clear();
    }

    // Param is passed by value, moved
    pub fn set_whitelist(&mut self, v: ::protobuf::RepeatedField<IpAddressMask>) {
        self.whitelist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_whitelist(&mut self) -> &mut ::protobuf::RepeatedField<IpAddressMask> {
        &mut self.whitelist
    }

    // Take field
    pub fn take_whitelist(&mut self) -> ::protobuf::RepeatedField<IpAddressMask> {
        ::std::mem::replace(&mut self.whitelist, ::protobuf::RepeatedField::new())
    }

    // optional uint64 tv_master_steamid = 10;


    pub fn get_tv_master_steamid(&self) -> u64 {
        self.tv_master_steamid.unwrap_or(0)
    }
    pub fn clear_tv_master_steamid(&mut self) {
        self.tv_master_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_master_steamid(&self) -> bool {
        self.tv_master_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_master_steamid(&mut self, v: u64) {
        self.tv_master_steamid = ::std::option::Option::Some(v);
    }

    // optional .TournamentEvent tournament_event = 11;


    pub fn get_tournament_event(&self) -> &TournamentEvent {
        self.tournament_event.as_ref().unwrap_or_else(|| TournamentEvent::default_instance())
    }
    pub fn clear_tournament_event(&mut self) {
        self.tournament_event.clear();
    }

    pub fn has_tournament_event(&self) -> bool {
        self.tournament_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_event(&mut self, v: TournamentEvent) {
        self.tournament_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_event(&mut self) -> &mut TournamentEvent {
        if self.tournament_event.is_none() {
            self.tournament_event.set_default();
        }
        self.tournament_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournament_event(&mut self) -> TournamentEvent {
        self.tournament_event.take().unwrap_or_else(|| TournamentEvent::new())
    }

    // repeated .TournamentTeam tournament_teams = 12;


    pub fn get_tournament_teams(&self) -> &[TournamentTeam] {
        &self.tournament_teams
    }
    pub fn clear_tournament_teams(&mut self) {
        self.tournament_teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournament_teams(&mut self, v: ::protobuf::RepeatedField<TournamentTeam>) {
        self.tournament_teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tournament_teams(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.tournament_teams
    }

    // Take field
    pub fn take_tournament_teams(&mut self) -> ::protobuf::RepeatedField<TournamentTeam> {
        ::std::mem::replace(&mut self.tournament_teams, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 tournament_casters_account_ids = 13;


    pub fn get_tournament_casters_account_ids(&self) -> &[u32] {
        &self.tournament_casters_account_ids
    }
    pub fn clear_tournament_casters_account_ids(&mut self) {
        self.tournament_casters_account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournament_casters_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.tournament_casters_account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tournament_casters_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tournament_casters_account_ids
    }

    // Take field
    pub fn take_tournament_casters_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tournament_casters_account_ids, ::std::vec::Vec::new())
    }

    // optional uint64 tv_relay_steamid = 14;


    pub fn get_tv_relay_steamid(&self) -> u64 {
        self.tv_relay_steamid.unwrap_or(0)
    }
    pub fn clear_tv_relay_steamid(&mut self) {
        self.tv_relay_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_relay_steamid(&self) -> bool {
        self.tv_relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_steamid(&mut self, v: u64) {
        self.tv_relay_steamid = ::std::option::Option::Some(v);
    }

    // optional .CPreMatchInfoData pre_match_data = 15;


    pub fn get_pre_match_data(&self) -> &CPreMatchInfoData {
        self.pre_match_data.as_ref().unwrap_or_else(|| CPreMatchInfoData::default_instance())
    }
    pub fn clear_pre_match_data(&mut self) {
        self.pre_match_data.clear();
    }

    pub fn has_pre_match_data(&self) -> bool {
        self.pre_match_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_match_data(&mut self, v: CPreMatchInfoData) {
        self.pre_match_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_match_data(&mut self) -> &mut CPreMatchInfoData {
        if self.pre_match_data.is_none() {
            self.pre_match_data.set_default();
        }
        self.pre_match_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_pre_match_data(&mut self) -> CPreMatchInfoData {
        self.pre_match_data.take().unwrap_or_else(|| CPreMatchInfoData::new())
    }

    // optional uint32 rtime32_event_start = 16;


    pub fn get_rtime32_event_start(&self) -> u32 {
        self.rtime32_event_start.unwrap_or(0)
    }
    pub fn clear_rtime32_event_start(&mut self) {
        self.rtime32_event_start = ::std::option::Option::None;
    }

    pub fn has_rtime32_event_start(&self) -> bool {
        self.rtime32_event_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_event_start(&mut self, v: u32) {
        self.rtime32_event_start = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_control = 17;


    pub fn get_tv_control(&self) -> u32 {
        self.tv_control.unwrap_or(0)
    }
    pub fn clear_tv_control(&mut self) {
        self.tv_control = ::std::option::Option::None;
    }

    pub fn has_tv_control(&self) -> bool {
        self.tv_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_control(&mut self, v: u32) {
        self.tv_control = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn is_initialized(&self) -> bool {
        for v in &self.rankings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.whitelist {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tournament_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tournament_teams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pre_match_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rankings)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.encryption_key = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.encryption_key_pub = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.party_ids)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.whitelist)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tv_master_steamid = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tournament_event)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tournament_teams)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.tournament_casters_account_ids)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tv_relay_steamid = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pre_match_data)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime32_event_start = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_control = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.encryption_key {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encryption_key_pub {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.party_ids {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.whitelist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.tv_master_steamid {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tournament_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tournament_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tournament_casters_account_ids {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.tv_relay_steamid {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pre_match_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.rtime32_event_start {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_control {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.game_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(18, v)?;
        }
        for v in &self.rankings {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.encryption_key {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.encryption_key_pub {
            os.write_uint64(7, v)?;
        }
        for v in &self.party_ids {
            os.write_uint32(8, *v)?;
        };
        for v in &self.whitelist {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.tv_master_steamid {
            os.write_uint64(10, v)?;
        }
        if let Some(ref v) = self.tournament_event.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tournament_teams {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tournament_casters_account_ids {
            os.write_uint32(13, *v)?;
        };
        if let Some(v) = self.tv_relay_steamid {
            os.write_uint64(14, v)?;
        }
        if let Some(ref v) = self.pre_match_data.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.rtime32_event_start {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.tv_control {
            os.write_uint32(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.account_ids },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.account_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.game_type },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.game_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.match_id },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.match_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_version",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.server_version },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.server_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.flags },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerRankingInfo>>(
                    "rankings",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.rankings },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.rankings },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "encryption_key",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.encryption_key },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.encryption_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "encryption_key_pub",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.encryption_key_pub },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.encryption_key_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "party_ids",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.party_ids },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.party_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IpAddressMask>>(
                    "whitelist",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.whitelist },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.whitelist },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tv_master_steamid",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tv_master_steamid },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tv_master_steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentEvent>>(
                    "tournament_event",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tournament_event },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tournament_event },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentTeam>>(
                    "tournament_teams",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tournament_teams },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tournament_teams },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tournament_casters_account_ids",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tournament_casters_account_ids },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tournament_casters_account_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tv_relay_steamid",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tv_relay_steamid },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tv_relay_steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPreMatchInfoData>>(
                    "pre_match_data",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.pre_match_data },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.pre_match_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rtime32_event_start",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.rtime32_event_start },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.rtime32_event_start },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_control",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tv_control },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tv_control },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn clear(&mut self) {
        self.account_ids.clear();
        self.game_type = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.server_version = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.rankings.clear();
        self.encryption_key = ::std::option::Option::None;
        self.encryption_key_pub = ::std::option::Option::None;
        self.party_ids.clear();
        self.whitelist.clear();
        self.tv_master_steamid = ::std::option::Option::None;
        self.tournament_event.clear();
        self.tournament_teams.clear();
        self.tournament_casters_account_ids.clear();
        self.tv_relay_steamid = ::std::option::Option::None;
        self.pre_match_data.clear();
        self.rtime32_event_start = ::std::option::Option::None;
        self.tv_control = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    // message fields
    reservationid: ::std::option::Option<u64>,
    reservation: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    map: ::protobuf::SingularField<::std::string::String>,
    gc_reservation_sent: ::std::option::Option<u64>,
    server_version: ::std::option::Option<u32>,
    tv_info: ::protobuf::SingularPtrField<ServerHltvInfo>,
    reward_player_accounts: ::std::vec::Vec<u32>,
    idle_player_accounts: ::std::vec::Vec<u32>,
    reward_item_attr_def_idx: ::std::option::Option<u32>,
    reward_item_attr_value: ::std::option::Option<u32>,
    reward_item_attr_reward_idx: ::std::option::Option<u32>,
    reward_drop_list: ::std::option::Option<u32>,
    tournament_tag: ::protobuf::SingularField<::std::string::String>,
    legacy_steamdatagram_port: ::std::option::Option<u32>,
    steamdatagram_routing: ::std::option::Option<u32>,
    test_token: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        <CMsgGCCStrike15_v2_MatchmakingServerReservationResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        ::std::default::Default::default()
    }

    // optional uint64 reservationid = 1;


    pub fn get_reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }
    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve reservation = 2;


    pub fn get_reservation(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::default_instance())
    }
    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new())
    }

    // optional string map = 3;


    pub fn get_map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 gc_reservation_sent = 4;


    pub fn get_gc_reservation_sent(&self) -> u64 {
        self.gc_reservation_sent.unwrap_or(0)
    }
    pub fn clear_gc_reservation_sent(&mut self) {
        self.gc_reservation_sent = ::std::option::Option::None;
    }

    pub fn has_gc_reservation_sent(&self) -> bool {
        self.gc_reservation_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_reservation_sent(&mut self, v: u64) {
        self.gc_reservation_sent = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 5;


    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }
    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional .ServerHltvInfo tv_info = 6;


    pub fn get_tv_info(&self) -> &ServerHltvInfo {
        self.tv_info.as_ref().unwrap_or_else(|| ServerHltvInfo::default_instance())
    }
    pub fn clear_tv_info(&mut self) {
        self.tv_info.clear();
    }

    pub fn has_tv_info(&self) -> bool {
        self.tv_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_info(&mut self, v: ServerHltvInfo) {
        self.tv_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tv_info(&mut self) -> &mut ServerHltvInfo {
        if self.tv_info.is_none() {
            self.tv_info.set_default();
        }
        self.tv_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_tv_info(&mut self) -> ServerHltvInfo {
        self.tv_info.take().unwrap_or_else(|| ServerHltvInfo::new())
    }

    // repeated uint32 reward_player_accounts = 7;


    pub fn get_reward_player_accounts(&self) -> &[u32] {
        &self.reward_player_accounts
    }
    pub fn clear_reward_player_accounts(&mut self) {
        self.reward_player_accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_reward_player_accounts(&mut self, v: ::std::vec::Vec<u32>) {
        self.reward_player_accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reward_player_accounts(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.reward_player_accounts
    }

    // Take field
    pub fn take_reward_player_accounts(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.reward_player_accounts, ::std::vec::Vec::new())
    }

    // repeated uint32 idle_player_accounts = 8;


    pub fn get_idle_player_accounts(&self) -> &[u32] {
        &self.idle_player_accounts
    }
    pub fn clear_idle_player_accounts(&mut self) {
        self.idle_player_accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_idle_player_accounts(&mut self, v: ::std::vec::Vec<u32>) {
        self.idle_player_accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_idle_player_accounts(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.idle_player_accounts
    }

    // Take field
    pub fn take_idle_player_accounts(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.idle_player_accounts, ::std::vec::Vec::new())
    }

    // optional uint32 reward_item_attr_def_idx = 9;


    pub fn get_reward_item_attr_def_idx(&self) -> u32 {
        self.reward_item_attr_def_idx.unwrap_or(0)
    }
    pub fn clear_reward_item_attr_def_idx(&mut self) {
        self.reward_item_attr_def_idx = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_def_idx(&self) -> bool {
        self.reward_item_attr_def_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_def_idx(&mut self, v: u32) {
        self.reward_item_attr_def_idx = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_item_attr_value = 10;


    pub fn get_reward_item_attr_value(&self) -> u32 {
        self.reward_item_attr_value.unwrap_or(0)
    }
    pub fn clear_reward_item_attr_value(&mut self) {
        self.reward_item_attr_value = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_value(&self) -> bool {
        self.reward_item_attr_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_value(&mut self, v: u32) {
        self.reward_item_attr_value = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_item_attr_reward_idx = 11;


    pub fn get_reward_item_attr_reward_idx(&self) -> u32 {
        self.reward_item_attr_reward_idx.unwrap_or(0)
    }
    pub fn clear_reward_item_attr_reward_idx(&mut self) {
        self.reward_item_attr_reward_idx = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_reward_idx(&self) -> bool {
        self.reward_item_attr_reward_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_reward_idx(&mut self, v: u32) {
        self.reward_item_attr_reward_idx = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_drop_list = 12;


    pub fn get_reward_drop_list(&self) -> u32 {
        self.reward_drop_list.unwrap_or(0)
    }
    pub fn clear_reward_drop_list(&mut self) {
        self.reward_drop_list = ::std::option::Option::None;
    }

    pub fn has_reward_drop_list(&self) -> bool {
        self.reward_drop_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_drop_list(&mut self, v: u32) {
        self.reward_drop_list = ::std::option::Option::Some(v);
    }

    // optional string tournament_tag = 13;


    pub fn get_tournament_tag(&self) -> &str {
        match self.tournament_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tournament_tag(&mut self) {
        self.tournament_tag.clear();
    }

    pub fn has_tournament_tag(&self) -> bool {
        self.tournament_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_tag(&mut self, v: ::std::string::String) {
        self.tournament_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_tag(&mut self) -> &mut ::std::string::String {
        if self.tournament_tag.is_none() {
            self.tournament_tag.set_default();
        }
        self.tournament_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournament_tag(&mut self) -> ::std::string::String {
        self.tournament_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 legacy_steamdatagram_port = 14;


    pub fn get_legacy_steamdatagram_port(&self) -> u32 {
        self.legacy_steamdatagram_port.unwrap_or(0)
    }
    pub fn clear_legacy_steamdatagram_port(&mut self) {
        self.legacy_steamdatagram_port = ::std::option::Option::None;
    }

    pub fn has_legacy_steamdatagram_port(&self) -> bool {
        self.legacy_steamdatagram_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_steamdatagram_port(&mut self, v: u32) {
        self.legacy_steamdatagram_port = ::std::option::Option::Some(v);
    }

    // optional uint32 steamdatagram_routing = 17;


    pub fn get_steamdatagram_routing(&self) -> u32 {
        self.steamdatagram_routing.unwrap_or(0)
    }
    pub fn clear_steamdatagram_routing(&mut self) {
        self.steamdatagram_routing = ::std::option::Option::None;
    }

    pub fn has_steamdatagram_routing(&self) -> bool {
        self.steamdatagram_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamdatagram_routing(&mut self, v: u32) {
        self.steamdatagram_routing = ::std::option::Option::Some(v);
    }

    // optional fixed32 test_token = 15;


    pub fn get_test_token(&self) -> u32 {
        self.test_token.unwrap_or(0)
    }
    pub fn clear_test_token(&mut self) {
        self.test_token = ::std::option::Option::None;
    }

    pub fn has_test_token(&self) -> bool {
        self.test_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_token(&mut self, v: u32) {
        self.test_token = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 16;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tv_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservationid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gc_reservation_sent = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tv_info)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.reward_player_accounts)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.idle_player_accounts)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_item_attr_def_idx = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_item_attr_value = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_item_attr_reward_idx = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_drop_list = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tournament_tag)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.legacy_steamdatagram_port = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.steamdatagram_routing = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.test_token = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.gc_reservation_sent {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tv_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.reward_player_accounts {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.idle_player_accounts {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.reward_item_attr_def_idx {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward_item_attr_value {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward_item_attr_reward_idx {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward_drop_list {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tournament_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.legacy_steamdatagram_port {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamdatagram_routing {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.test_token {
            my_size += 5;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reservationid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.map.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.gc_reservation_sent {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.tv_info.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.reward_player_accounts {
            os.write_uint32(7, *v)?;
        };
        for v in &self.idle_player_accounts {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.reward_item_attr_def_idx {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.reward_item_attr_value {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.reward_item_attr_reward_idx {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.reward_drop_list {
            os.write_uint32(12, v)?;
        }
        if let Some(ref v) = self.tournament_tag.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.legacy_steamdatagram_port {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.steamdatagram_routing {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.test_token {
            os.write_fixed32(15, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reservationid",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reservationid },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reservationid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>>(
                    "reservation",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reservation },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reservation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "map",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.map },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.map },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gc_reservation_sent",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.gc_reservation_sent },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.gc_reservation_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_version",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.server_version },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.server_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerHltvInfo>>(
                    "tv_info",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.tv_info },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.tv_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_player_accounts",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_player_accounts },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_player_accounts },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "idle_player_accounts",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.idle_player_accounts },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.idle_player_accounts },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_item_attr_def_idx",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_item_attr_def_idx },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_item_attr_def_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_item_attr_value",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_item_attr_value },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_item_attr_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_item_attr_reward_idx",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_item_attr_reward_idx },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_item_attr_reward_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_drop_list",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_drop_list },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_drop_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tournament_tag",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.tournament_tag },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.tournament_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "legacy_steamdatagram_port",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.legacy_steamdatagram_port },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.legacy_steamdatagram_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "steamdatagram_routing",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.steamdatagram_routing },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.steamdatagram_routing },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "test_token",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.test_token },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.test_token },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.flags },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.flags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>(
                    "CMsgGCCStrike15_v2_MatchmakingServerReservationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServerReservationResponse,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn clear(&mut self) {
        self.reservationid = ::std::option::Option::None;
        self.reservation.clear();
        self.map.clear();
        self.gc_reservation_sent = ::std::option::Option::None;
        self.server_version = ::std::option::Option::None;
        self.tv_info.clear();
        self.reward_player_accounts.clear();
        self.idle_player_accounts.clear();
        self.reward_item_attr_def_idx = ::std::option::Option::None;
        self.reward_item_attr_value = ::std::option::Option::None;
        self.reward_item_attr_reward_idx = ::std::option::Option::None;
        self.reward_drop_list = ::std::option::Option::None;
        self.tournament_tag.clear();
        self.legacy_steamdatagram_port = ::std::option::Option::None;
        self.steamdatagram_routing = ::std::option::Option::None;
        self.test_token = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    // message fields
    serverid: ::std::option::Option<u64>,
    direct_udp_ip: ::std::option::Option<u32>,
    direct_udp_port: ::std::option::Option<u32>,
    reservationid: ::std::option::Option<u64>,
    reservation: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    map: ::protobuf::SingularField<::std::string::String>,
    server_address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        ::std::default::Default::default()
    }

    // optional uint64 serverid = 1;


    pub fn get_serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }
    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    // optional uint32 direct_udp_ip = 2;


    pub fn get_direct_udp_ip(&self) -> u32 {
        self.direct_udp_ip.unwrap_or(0)
    }
    pub fn clear_direct_udp_ip(&mut self) {
        self.direct_udp_ip = ::std::option::Option::None;
    }

    pub fn has_direct_udp_ip(&self) -> bool {
        self.direct_udp_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direct_udp_ip(&mut self, v: u32) {
        self.direct_udp_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 direct_udp_port = 3;


    pub fn get_direct_udp_port(&self) -> u32 {
        self.direct_udp_port.unwrap_or(0)
    }
    pub fn clear_direct_udp_port(&mut self) {
        self.direct_udp_port = ::std::option::Option::None;
    }

    pub fn has_direct_udp_port(&self) -> bool {
        self.direct_udp_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direct_udp_port(&mut self, v: u32) {
        self.direct_udp_port = ::std::option::Option::Some(v);
    }

    // optional uint64 reservationid = 4;


    pub fn get_reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }
    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve reservation = 5;


    pub fn get_reservation(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::default_instance())
    }
    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new())
    }

    // optional string map = 6;


    pub fn get_map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string server_address = 7;


    pub fn get_server_address(&self) -> &str {
        match self.server_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_server_address(&mut self) {
        self.server_address.clear();
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: ::std::string::String) {
        self.server_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_address(&mut self) -> &mut ::std::string::String {
        if self.server_address.is_none() {
            self.server_address.set_default();
        }
        self.server_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_address(&mut self) -> ::std::string::String {
        self.server_address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn is_initialized(&self) -> bool {
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.serverid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.direct_udp_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.direct_udp_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservationid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.direct_udp_ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.direct_udp_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.server_address.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.serverid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.direct_udp_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.direct_udp_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.reservationid {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.map.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.server_address.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "serverid",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.serverid },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.serverid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "direct_udp_ip",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.direct_udp_ip },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.direct_udp_ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "direct_udp_port",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.direct_udp_port },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.direct_udp_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reservationid",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.reservationid },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.reservationid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>>(
                    "reservation",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.reservation },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.reservation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "map",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.map },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.map },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "server_address",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.server_address },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.server_address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn clear(&mut self) {
        self.serverid = ::std::option::Option::None;
        self.direct_udp_ip = ::std::option::Option::None;
        self.direct_udp_port = ::std::option::Option::None;
        self.reservationid = ::std::option::Option::None;
        self.reservation.clear();
        self.map.clear();
        self.server_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    // message fields
    reservationid: ::std::option::Option<u64>,
    reservation: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    map: ::protobuf::SingularField<::std::string::String>,
    round: ::std::option::Option<i32>,
    kills: ::std::vec::Vec<i32>,
    assists: ::std::vec::Vec<i32>,
    deaths: ::std::vec::Vec<i32>,
    scores: ::std::vec::Vec<i32>,
    pings: ::std::vec::Vec<i32>,
    round_result: ::std::option::Option<i32>,
    match_result: ::std::option::Option<i32>,
    team_scores: ::std::vec::Vec<i32>,
    confirm: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>,
    reservation_stage: ::std::option::Option<i32>,
    match_duration: ::std::option::Option<i32>,
    enemy_kills: ::std::vec::Vec<i32>,
    enemy_headshots: ::std::vec::Vec<i32>,
    enemy_3ks: ::std::vec::Vec<i32>,
    enemy_4ks: ::std::vec::Vec<i32>,
    enemy_5ks: ::std::vec::Vec<i32>,
    mvps: ::std::vec::Vec<i32>,
    spectators_count: ::std::option::Option<u32>,
    spectators_count_tv: ::std::option::Option<u32>,
    spectators_count_lnk: ::std::option::Option<u32>,
    enemy_kills_agg: ::std::vec::Vec<i32>,
    drop_info: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        <CMsgGCCStrike15_v2_MatchmakingServerRoundStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        ::std::default::Default::default()
    }

    // optional uint64 reservationid = 1;


    pub fn get_reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }
    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve reservation = 2;


    pub fn get_reservation(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::default_instance())
    }
    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new())
    }

    // optional string map = 3;


    pub fn get_map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 round = 4;


    pub fn get_round(&self) -> i32 {
        self.round.unwrap_or(0)
    }
    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i32) {
        self.round = ::std::option::Option::Some(v);
    }

    // repeated int32 kills = 5;


    pub fn get_kills(&self) -> &[i32] {
        &self.kills
    }
    pub fn clear_kills(&mut self) {
        self.kills.clear();
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: ::std::vec::Vec<i32>) {
        self.kills = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kills(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.kills
    }

    // Take field
    pub fn take_kills(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.kills, ::std::vec::Vec::new())
    }

    // repeated int32 assists = 6;


    pub fn get_assists(&self) -> &[i32] {
        &self.assists
    }
    pub fn clear_assists(&mut self) {
        self.assists.clear();
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: ::std::vec::Vec<i32>) {
        self.assists = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assists(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.assists
    }

    // Take field
    pub fn take_assists(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.assists, ::std::vec::Vec::new())
    }

    // repeated int32 deaths = 7;


    pub fn get_deaths(&self) -> &[i32] {
        &self.deaths
    }
    pub fn clear_deaths(&mut self) {
        self.deaths.clear();
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: ::std::vec::Vec<i32>) {
        self.deaths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deaths(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.deaths
    }

    // Take field
    pub fn take_deaths(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.deaths, ::std::vec::Vec::new())
    }

    // repeated int32 scores = 8;


    pub fn get_scores(&self) -> &[i32] {
        &self.scores
    }
    pub fn clear_scores(&mut self) {
        self.scores.clear();
    }

    // Param is passed by value, moved
    pub fn set_scores(&mut self, v: ::std::vec::Vec<i32>) {
        self.scores = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scores(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.scores
    }

    // Take field
    pub fn take_scores(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.scores, ::std::vec::Vec::new())
    }

    // repeated int32 pings = 9;


    pub fn get_pings(&self) -> &[i32] {
        &self.pings
    }
    pub fn clear_pings(&mut self) {
        self.pings.clear();
    }

    // Param is passed by value, moved
    pub fn set_pings(&mut self, v: ::std::vec::Vec<i32>) {
        self.pings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pings(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.pings
    }

    // Take field
    pub fn take_pings(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.pings, ::std::vec::Vec::new())
    }

    // optional int32 round_result = 10;


    pub fn get_round_result(&self) -> i32 {
        self.round_result.unwrap_or(0)
    }
    pub fn clear_round_result(&mut self) {
        self.round_result = ::std::option::Option::None;
    }

    pub fn has_round_result(&self) -> bool {
        self.round_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_result(&mut self, v: i32) {
        self.round_result = ::std::option::Option::Some(v);
    }

    // optional int32 match_result = 11;


    pub fn get_match_result(&self) -> i32 {
        self.match_result.unwrap_or(0)
    }
    pub fn clear_match_result(&mut self) {
        self.match_result = ::std::option::Option::None;
    }

    pub fn has_match_result(&self) -> bool {
        self.match_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_result(&mut self, v: i32) {
        self.match_result = ::std::option::Option::Some(v);
    }

    // repeated int32 team_scores = 12;


    pub fn get_team_scores(&self) -> &[i32] {
        &self.team_scores
    }
    pub fn clear_team_scores(&mut self) {
        self.team_scores.clear();
    }

    // Param is passed by value, moved
    pub fn set_team_scores(&mut self, v: ::std::vec::Vec<i32>) {
        self.team_scores = v;
    }

    // Mutable pointer to the field.
    pub fn mut_team_scores(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.team_scores
    }

    // Take field
    pub fn take_team_scores(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.team_scores, ::std::vec::Vec::new())
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm confirm = 13;


    pub fn get_confirm(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        self.confirm.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::default_instance())
    }
    pub fn clear_confirm(&mut self) {
        self.confirm.clear();
    }

    pub fn has_confirm(&self) -> bool {
        self.confirm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confirm(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm) {
        self.confirm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_confirm(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        if self.confirm.is_none() {
            self.confirm.set_default();
        }
        self.confirm.as_mut().unwrap()
    }

    // Take field
    pub fn take_confirm(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        self.confirm.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new())
    }

    // optional int32 reservation_stage = 14;


    pub fn get_reservation_stage(&self) -> i32 {
        self.reservation_stage.unwrap_or(0)
    }
    pub fn clear_reservation_stage(&mut self) {
        self.reservation_stage = ::std::option::Option::None;
    }

    pub fn has_reservation_stage(&self) -> bool {
        self.reservation_stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_stage(&mut self, v: i32) {
        self.reservation_stage = ::std::option::Option::Some(v);
    }

    // optional int32 match_duration = 15;


    pub fn get_match_duration(&self) -> i32 {
        self.match_duration.unwrap_or(0)
    }
    pub fn clear_match_duration(&mut self) {
        self.match_duration = ::std::option::Option::None;
    }

    pub fn has_match_duration(&self) -> bool {
        self.match_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_duration(&mut self, v: i32) {
        self.match_duration = ::std::option::Option::Some(v);
    }

    // repeated int32 enemy_kills = 16;


    pub fn get_enemy_kills(&self) -> &[i32] {
        &self.enemy_kills
    }
    pub fn clear_enemy_kills(&mut self) {
        self.enemy_kills.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_kills(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_kills = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_kills(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_kills
    }

    // Take field
    pub fn take_enemy_kills(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_kills, ::std::vec::Vec::new())
    }

    // repeated int32 enemy_headshots = 17;


    pub fn get_enemy_headshots(&self) -> &[i32] {
        &self.enemy_headshots
    }
    pub fn clear_enemy_headshots(&mut self) {
        self.enemy_headshots.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_headshots(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_headshots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_headshots(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_headshots
    }

    // Take field
    pub fn take_enemy_headshots(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_headshots, ::std::vec::Vec::new())
    }

    // repeated int32 enemy_3ks = 18;


    pub fn get_enemy_3ks(&self) -> &[i32] {
        &self.enemy_3ks
    }
    pub fn clear_enemy_3ks(&mut self) {
        self.enemy_3ks.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_3ks(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_3ks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_3ks(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_3ks
    }

    // Take field
    pub fn take_enemy_3ks(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_3ks, ::std::vec::Vec::new())
    }

    // repeated int32 enemy_4ks = 19;


    pub fn get_enemy_4ks(&self) -> &[i32] {
        &self.enemy_4ks
    }
    pub fn clear_enemy_4ks(&mut self) {
        self.enemy_4ks.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_4ks(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_4ks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_4ks(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_4ks
    }

    // Take field
    pub fn take_enemy_4ks(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_4ks, ::std::vec::Vec::new())
    }

    // repeated int32 enemy_5ks = 20;


    pub fn get_enemy_5ks(&self) -> &[i32] {
        &self.enemy_5ks
    }
    pub fn clear_enemy_5ks(&mut self) {
        self.enemy_5ks.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_5ks(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_5ks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_5ks(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_5ks
    }

    // Take field
    pub fn take_enemy_5ks(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_5ks, ::std::vec::Vec::new())
    }

    // repeated int32 mvps = 21;


    pub fn get_mvps(&self) -> &[i32] {
        &self.mvps
    }
    pub fn clear_mvps(&mut self) {
        self.mvps.clear();
    }

    // Param is passed by value, moved
    pub fn set_mvps(&mut self, v: ::std::vec::Vec<i32>) {
        self.mvps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mvps(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.mvps
    }

    // Take field
    pub fn take_mvps(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.mvps, ::std::vec::Vec::new())
    }

    // optional uint32 spectators_count = 22;


    pub fn get_spectators_count(&self) -> u32 {
        self.spectators_count.unwrap_or(0)
    }
    pub fn clear_spectators_count(&mut self) {
        self.spectators_count = ::std::option::Option::None;
    }

    pub fn has_spectators_count(&self) -> bool {
        self.spectators_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count(&mut self, v: u32) {
        self.spectators_count = ::std::option::Option::Some(v);
    }

    // optional uint32 spectators_count_tv = 23;


    pub fn get_spectators_count_tv(&self) -> u32 {
        self.spectators_count_tv.unwrap_or(0)
    }
    pub fn clear_spectators_count_tv(&mut self) {
        self.spectators_count_tv = ::std::option::Option::None;
    }

    pub fn has_spectators_count_tv(&self) -> bool {
        self.spectators_count_tv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count_tv(&mut self, v: u32) {
        self.spectators_count_tv = ::std::option::Option::Some(v);
    }

    // optional uint32 spectators_count_lnk = 24;


    pub fn get_spectators_count_lnk(&self) -> u32 {
        self.spectators_count_lnk.unwrap_or(0)
    }
    pub fn clear_spectators_count_lnk(&mut self) {
        self.spectators_count_lnk = ::std::option::Option::None;
    }

    pub fn has_spectators_count_lnk(&self) -> bool {
        self.spectators_count_lnk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count_lnk(&mut self, v: u32) {
        self.spectators_count_lnk = ::std::option::Option::Some(v);
    }

    // repeated int32 enemy_kills_agg = 25;


    pub fn get_enemy_kills_agg(&self) -> &[i32] {
        &self.enemy_kills_agg
    }
    pub fn clear_enemy_kills_agg(&mut self) {
        self.enemy_kills_agg.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_kills_agg(&mut self, v: ::std::vec::Vec<i32>) {
        self.enemy_kills_agg = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_kills_agg(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.enemy_kills_agg
    }

    // Take field
    pub fn take_enemy_kills_agg(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.enemy_kills_agg, ::std::vec::Vec::new())
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo drop_info = 26;


    pub fn get_drop_info(&self) -> &CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        self.drop_info.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo::default_instance())
    }
    pub fn clear_drop_info(&mut self) {
        self.drop_info.clear();
    }

    pub fn has_drop_info(&self) -> bool {
        self.drop_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drop_info(&mut self, v: CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo) {
        self.drop_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_drop_info(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        if self.drop_info.is_none() {
            self.drop_info.set_default();
        }
        self.drop_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_drop_info(&mut self) -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        self.drop_info.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn is_initialized(&self) -> bool {
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.confirm {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.drop_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservationid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.round = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.kills)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.assists)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.deaths)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.scores)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.pings)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.round_result = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_result = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.team_scores)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.confirm)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reservation_stage = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_duration = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_kills)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_headshots)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_3ks)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_4ks)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_5ks)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.mvps)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spectators_count = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spectators_count_tv = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spectators_count_lnk = ::std::option::Option::Some(tmp);
                },
                25 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.enemy_kills_agg)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.drop_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.round {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.kills {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.assists {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.deaths {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.scores {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.pings {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.round_result {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_result {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.team_scores {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.confirm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reservation_stage {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_duration {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.enemy_kills {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.enemy_headshots {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.enemy_3ks {
            my_size += ::protobuf::rt::value_size(18, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.enemy_4ks {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.enemy_5ks {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.mvps {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.spectators_count {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spectators_count_tv {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spectators_count_lnk {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.enemy_kills_agg {
            my_size += ::protobuf::rt::value_size(25, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.drop_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reservationid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.map.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.round {
            os.write_int32(4, v)?;
        }
        for v in &self.kills {
            os.write_int32(5, *v)?;
        };
        for v in &self.assists {
            os.write_int32(6, *v)?;
        };
        for v in &self.deaths {
            os.write_int32(7, *v)?;
        };
        for v in &self.scores {
            os.write_int32(8, *v)?;
        };
        for v in &self.pings {
            os.write_int32(9, *v)?;
        };
        if let Some(v) = self.round_result {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.match_result {
            os.write_int32(11, v)?;
        }
        for v in &self.team_scores {
            os.write_int32(12, *v)?;
        };
        if let Some(ref v) = self.confirm.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.reservation_stage {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.match_duration {
            os.write_int32(15, v)?;
        }
        for v in &self.enemy_kills {
            os.write_int32(16, *v)?;
        };
        for v in &self.enemy_headshots {
            os.write_int32(17, *v)?;
        };
        for v in &self.enemy_3ks {
            os.write_int32(18, *v)?;
        };
        for v in &self.enemy_4ks {
            os.write_int32(19, *v)?;
        };
        for v in &self.enemy_5ks {
            os.write_int32(20, *v)?;
        };
        for v in &self.mvps {
            os.write_int32(21, *v)?;
        };
        if let Some(v) = self.spectators_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.spectators_count_tv {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.spectators_count_lnk {
            os.write_uint32(24, v)?;
        }
        for v in &self.enemy_kills_agg {
            os.write_int32(25, *v)?;
        };
        if let Some(ref v) = self.drop_info.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        CMsgGCCStrike15_v2_MatchmakingServerRoundStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reservationid",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.reservationid },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.reservationid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>>(
                    "reservation",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.reservation },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.reservation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "map",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.map },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.map },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "round",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.round },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.round },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "kills",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.kills },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.kills },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "assists",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.assists },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.assists },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "deaths",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.deaths },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.deaths },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "scores",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.scores },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.scores },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pings",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.pings },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.pings },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "round_result",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.round_result },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.round_result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "match_result",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.match_result },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.match_result },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_scores",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.team_scores },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.team_scores },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>>(
                    "confirm",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.confirm },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.confirm },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "reservation_stage",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.reservation_stage },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.reservation_stage },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "match_duration",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.match_duration },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.match_duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_kills",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_kills },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_kills },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_headshots",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_headshots },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_headshots },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_3ks",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_3ks },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_3ks },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_4ks",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_4ks },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_4ks },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_5ks",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_5ks },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_5ks },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mvps",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.mvps },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.mvps },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spectators_count",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.spectators_count },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.spectators_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spectators_count_tv",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.spectators_count_tv },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.spectators_count_tv },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spectators_count_lnk",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.spectators_count_lnk },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.spectators_count_lnk },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "enemy_kills_agg",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_kills_agg },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_kills_agg },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo>>(
                    "drop_info",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.drop_info },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.drop_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>(
                    "CMsgGCCStrike15_v2_MatchmakingServerRoundStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServerRoundStats,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServerRoundStats::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn clear(&mut self) {
        self.reservationid = ::std::option::Option::None;
        self.reservation.clear();
        self.map.clear();
        self.round = ::std::option::Option::None;
        self.kills.clear();
        self.assists.clear();
        self.deaths.clear();
        self.scores.clear();
        self.pings.clear();
        self.round_result = ::std::option::Option::None;
        self.match_result = ::std::option::Option::None;
        self.team_scores.clear();
        self.confirm.clear();
        self.reservation_stage = ::std::option::Option::None;
        self.match_duration = ::std::option::Option::None;
        self.enemy_kills.clear();
        self.enemy_headshots.clear();
        self.enemy_3ks.clear();
        self.enemy_4ks.clear();
        self.enemy_5ks.clear();
        self.mvps.clear();
        self.spectators_count = ::std::option::Option::None;
        self.spectators_count_tv = ::std::option::Option::None;
        self.spectators_count_lnk = ::std::option::Option::None;
        self.enemy_kills_agg.clear();
        self.drop_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    // message fields
    account_mvp: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        <CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_mvp = 1;


    pub fn get_account_mvp(&self) -> u32 {
        self.account_mvp.unwrap_or(0)
    }
    pub fn clear_account_mvp(&mut self) {
        self.account_mvp = ::std::option::Option::None;
    }

    pub fn has_account_mvp(&self) -> bool {
        self.account_mvp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_mvp(&mut self, v: u32) {
        self.account_mvp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_mvp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_mvp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_mvp {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_mvp",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo| { &m.account_mvp },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo| { &mut m.account_mvp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo>(
                    "CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    fn clear(&mut self) {
        self.account_mvp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerRoundStats_DropInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    // message fields
    stats: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    confirm: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>,
    rematch: ::std::option::Option<u64>,
    replay_token: ::std::option::Option<u32>,
    replay_cluster_id: ::std::option::Option<u32>,
    aborted_match: ::std::option::Option<bool>,
    match_end_quest_data: ::protobuf::SingularPtrField<CMsgGC_ServerQuestUpdateData>,
    server_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        <CMsgGCCStrike15_v2_MatchmakingServerMatchEnd as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        ::std::default::Default::default()
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingServerRoundStats stats = 1;


    pub fn get_stats(&self) -> &CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        self.stats.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CMsgGCCStrike15_v2_MatchmakingServerRoundStats) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        self.stats.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats::new())
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm confirm = 3;


    pub fn get_confirm(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        self.confirm.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::default_instance())
    }
    pub fn clear_confirm(&mut self) {
        self.confirm.clear();
    }

    pub fn has_confirm(&self) -> bool {
        self.confirm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confirm(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm) {
        self.confirm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_confirm(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        if self.confirm.is_none() {
            self.confirm.set_default();
        }
        self.confirm.as_mut().unwrap()
    }

    // Take field
    pub fn take_confirm(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        self.confirm.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new())
    }

    // optional uint64 rematch = 4;


    pub fn get_rematch(&self) -> u64 {
        self.rematch.unwrap_or(0)
    }
    pub fn clear_rematch(&mut self) {
        self.rematch = ::std::option::Option::None;
    }

    pub fn has_rematch(&self) -> bool {
        self.rematch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rematch(&mut self, v: u64) {
        self.rematch = ::std::option::Option::Some(v);
    }

    // optional uint32 replay_token = 5;


    pub fn get_replay_token(&self) -> u32 {
        self.replay_token.unwrap_or(0)
    }
    pub fn clear_replay_token(&mut self) {
        self.replay_token = ::std::option::Option::None;
    }

    pub fn has_replay_token(&self) -> bool {
        self.replay_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_token(&mut self, v: u32) {
        self.replay_token = ::std::option::Option::Some(v);
    }

    // optional uint32 replay_cluster_id = 6;


    pub fn get_replay_cluster_id(&self) -> u32 {
        self.replay_cluster_id.unwrap_or(0)
    }
    pub fn clear_replay_cluster_id(&mut self) {
        self.replay_cluster_id = ::std::option::Option::None;
    }

    pub fn has_replay_cluster_id(&self) -> bool {
        self.replay_cluster_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_cluster_id(&mut self, v: u32) {
        self.replay_cluster_id = ::std::option::Option::Some(v);
    }

    // optional bool aborted_match = 7;


    pub fn get_aborted_match(&self) -> bool {
        self.aborted_match.unwrap_or(false)
    }
    pub fn clear_aborted_match(&mut self) {
        self.aborted_match = ::std::option::Option::None;
    }

    pub fn has_aborted_match(&self) -> bool {
        self.aborted_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aborted_match(&mut self, v: bool) {
        self.aborted_match = ::std::option::Option::Some(v);
    }

    // optional .CMsgGC_ServerQuestUpdateData match_end_quest_data = 8;


    pub fn get_match_end_quest_data(&self) -> &CMsgGC_ServerQuestUpdateData {
        self.match_end_quest_data.as_ref().unwrap_or_else(|| CMsgGC_ServerQuestUpdateData::default_instance())
    }
    pub fn clear_match_end_quest_data(&mut self) {
        self.match_end_quest_data.clear();
    }

    pub fn has_match_end_quest_data(&self) -> bool {
        self.match_end_quest_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_end_quest_data(&mut self, v: CMsgGC_ServerQuestUpdateData) {
        self.match_end_quest_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_end_quest_data(&mut self) -> &mut CMsgGC_ServerQuestUpdateData {
        if self.match_end_quest_data.is_none() {
            self.match_end_quest_data.set_default();
        }
        self.match_end_quest_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_match_end_quest_data(&mut self) -> CMsgGC_ServerQuestUpdateData {
        self.match_end_quest_data.take().unwrap_or_else(|| CMsgGC_ServerQuestUpdateData::new())
    }

    // optional uint32 server_version = 9;


    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }
    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.confirm {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.match_end_quest_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.confirm)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rematch = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replay_token = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replay_cluster_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.aborted_match = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.match_end_quest_data)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.confirm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.rematch {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replay_token {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replay_cluster_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.aborted_match {
            my_size += 2;
        }
        if let Some(ref v) = self.match_end_quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.confirm.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.rematch {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.replay_token {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.replay_cluster_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.aborted_match {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.match_end_quest_data.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>>(
                    "stats",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.stats },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>>(
                    "confirm",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.confirm },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.confirm },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rematch",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.rematch },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.rematch },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replay_token",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.replay_token },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.replay_token },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replay_cluster_id",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.replay_cluster_id },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.replay_cluster_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "aborted_match",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.aborted_match },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.aborted_match },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGC_ServerQuestUpdateData>>(
                    "match_end_quest_data",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.match_end_quest_data },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.match_end_quest_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_version",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.server_version },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.server_version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServerMatchEnd>(
                    "CMsgGCCStrike15_v2_MatchmakingServerMatchEnd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServerMatchEnd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServerMatchEnd,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn clear(&mut self) {
        self.stats.clear();
        self.confirm.clear();
        self.rematch = ::std::option::Option::None;
        self.replay_token = ::std::option::Option::None;
        self.replay_cluster_id = ::std::option::Option::None;
        self.aborted_match = ::std::option::Option::None;
        self.match_end_quest_data.clear();
        self.server_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
    // message fields
    reservationid: ::std::option::Option<u64>,
    reservation: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    confirm: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>,
    completed_player_quest_data: ::protobuf::SingularPtrField<CMsgGC_ServerQuestUpdateData>,
    server_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
        <CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
        ::std::default::Default::default()
    }

    // optional uint64 reservationid = 1;


    pub fn get_reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }
    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve reservation = 2;


    pub fn get_reservation(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::default_instance())
    }
    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new())
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm confirm = 3;


    pub fn get_confirm(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        self.confirm.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::default_instance())
    }
    pub fn clear_confirm(&mut self) {
        self.confirm.clear();
    }

    pub fn has_confirm(&self) -> bool {
        self.confirm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confirm(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm) {
        self.confirm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_confirm(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        if self.confirm.is_none() {
            self.confirm.set_default();
        }
        self.confirm.as_mut().unwrap()
    }

    // Take field
    pub fn take_confirm(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        self.confirm.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new())
    }

    // optional .CMsgGC_ServerQuestUpdateData completed_player_quest_data = 4;


    pub fn get_completed_player_quest_data(&self) -> &CMsgGC_ServerQuestUpdateData {
        self.completed_player_quest_data.as_ref().unwrap_or_else(|| CMsgGC_ServerQuestUpdateData::default_instance())
    }
    pub fn clear_completed_player_quest_data(&mut self) {
        self.completed_player_quest_data.clear();
    }

    pub fn has_completed_player_quest_data(&self) -> bool {
        self.completed_player_quest_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_player_quest_data(&mut self, v: CMsgGC_ServerQuestUpdateData) {
        self.completed_player_quest_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_completed_player_quest_data(&mut self) -> &mut CMsgGC_ServerQuestUpdateData {
        if self.completed_player_quest_data.is_none() {
            self.completed_player_quest_data.set_default();
        }
        self.completed_player_quest_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_completed_player_quest_data(&mut self) -> CMsgGC_ServerQuestUpdateData {
        self.completed_player_quest_data.take().unwrap_or_else(|| CMsgGC_ServerQuestUpdateData::new())
    }

    // optional uint32 server_version = 5;


    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }
    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
    fn is_initialized(&self) -> bool {
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.confirm {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.completed_player_quest_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservationid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.confirm)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.completed_player_quest_data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.confirm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.completed_player_quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reservationid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.confirm.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.completed_player_quest_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
        CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reservationid",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial| { &m.reservationid },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial| { &mut m.reservationid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>>(
                    "reservation",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial| { &m.reservation },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial| { &mut m.reservation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>>(
                    "confirm",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial| { &m.confirm },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial| { &mut m.confirm },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGC_ServerQuestUpdateData>>(
                    "completed_player_quest_data",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial| { &m.completed_player_quest_data },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial| { &mut m.completed_player_quest_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_version",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial| { &m.server_version },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial| { &mut m.server_version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial>(
                    "CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
    fn clear(&mut self) {
        self.reservationid = ::std::option::Option::None;
        self.reservation.clear();
        self.confirm.clear();
        self.completed_player_quest_data.clear();
        self.server_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        <CMsgGCCStrike15_v2_MatchmakingClient2GCHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        CMsgGCCStrike15_v2_MatchmakingClient2GCHello::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingClient2GCHello>(
                    "CMsgGCCStrike15_v2_MatchmakingClient2GCHello",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingClient2GCHello> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingClient2GCHello,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingClient2GCHello::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    // message fields
    account_id: ::std::option::Option<u32>,
    ongoingmatch: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    global_stats: ::protobuf::SingularPtrField<GlobalStatistics>,
    penalty_seconds: ::std::option::Option<u32>,
    penalty_reason: ::std::option::Option<u32>,
    vac_banned: ::std::option::Option<i32>,
    ranking: ::protobuf::SingularPtrField<PlayerRankingInfo>,
    commendation: ::protobuf::SingularPtrField<PlayerCommendationInfo>,
    medals: ::protobuf::SingularPtrField<PlayerMedalsInfo>,
    my_current_event: ::protobuf::SingularPtrField<TournamentEvent>,
    my_current_event_teams: ::protobuf::RepeatedField<TournamentTeam>,
    my_current_team: ::protobuf::SingularPtrField<TournamentTeam>,
    my_current_event_stages: ::protobuf::RepeatedField<TournamentEvent>,
    survey_vote: ::std::option::Option<u32>,
    activity: ::protobuf::SingularPtrField<AccountActivity>,
    player_level: ::std::option::Option<i32>,
    player_cur_xp: ::std::option::Option<i32>,
    player_xp_bonus_flags: ::std::option::Option<i32>,
    rankings: ::protobuf::RepeatedField<PlayerRankingInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve ongoingmatch = 2;


    pub fn get_ongoingmatch(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.ongoingmatch.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::default_instance())
    }
    pub fn clear_ongoingmatch(&mut self) {
        self.ongoingmatch.clear();
    }

    pub fn has_ongoingmatch(&self) -> bool {
        self.ongoingmatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ongoingmatch(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve) {
        self.ongoingmatch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ongoingmatch(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        if self.ongoingmatch.is_none() {
            self.ongoingmatch.set_default();
        }
        self.ongoingmatch.as_mut().unwrap()
    }

    // Take field
    pub fn take_ongoingmatch(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.ongoingmatch.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new())
    }

    // optional .GlobalStatistics global_stats = 3;


    pub fn get_global_stats(&self) -> &GlobalStatistics {
        self.global_stats.as_ref().unwrap_or_else(|| GlobalStatistics::default_instance())
    }
    pub fn clear_global_stats(&mut self) {
        self.global_stats.clear();
    }

    pub fn has_global_stats(&self) -> bool {
        self.global_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_stats(&mut self, v: GlobalStatistics) {
        self.global_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global_stats(&mut self) -> &mut GlobalStatistics {
        if self.global_stats.is_none() {
            self.global_stats.set_default();
        }
        self.global_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_global_stats(&mut self) -> GlobalStatistics {
        self.global_stats.take().unwrap_or_else(|| GlobalStatistics::new())
    }

    // optional uint32 penalty_seconds = 4;


    pub fn get_penalty_seconds(&self) -> u32 {
        self.penalty_seconds.unwrap_or(0)
    }
    pub fn clear_penalty_seconds(&mut self) {
        self.penalty_seconds = ::std::option::Option::None;
    }

    pub fn has_penalty_seconds(&self) -> bool {
        self.penalty_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_seconds(&mut self, v: u32) {
        self.penalty_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_reason = 5;


    pub fn get_penalty_reason(&self) -> u32 {
        self.penalty_reason.unwrap_or(0)
    }
    pub fn clear_penalty_reason(&mut self) {
        self.penalty_reason = ::std::option::Option::None;
    }

    pub fn has_penalty_reason(&self) -> bool {
        self.penalty_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_reason(&mut self, v: u32) {
        self.penalty_reason = ::std::option::Option::Some(v);
    }

    // optional int32 vac_banned = 6;


    pub fn get_vac_banned(&self) -> i32 {
        self.vac_banned.unwrap_or(0)
    }
    pub fn clear_vac_banned(&mut self) {
        self.vac_banned = ::std::option::Option::None;
    }

    pub fn has_vac_banned(&self) -> bool {
        self.vac_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vac_banned(&mut self, v: i32) {
        self.vac_banned = ::std::option::Option::Some(v);
    }

    // optional .PlayerRankingInfo ranking = 7;


    pub fn get_ranking(&self) -> &PlayerRankingInfo {
        self.ranking.as_ref().unwrap_or_else(|| PlayerRankingInfo::default_instance())
    }
    pub fn clear_ranking(&mut self) {
        self.ranking.clear();
    }

    pub fn has_ranking(&self) -> bool {
        self.ranking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranking(&mut self, v: PlayerRankingInfo) {
        self.ranking = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranking(&mut self) -> &mut PlayerRankingInfo {
        if self.ranking.is_none() {
            self.ranking.set_default();
        }
        self.ranking.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranking(&mut self) -> PlayerRankingInfo {
        self.ranking.take().unwrap_or_else(|| PlayerRankingInfo::new())
    }

    // optional .PlayerCommendationInfo commendation = 8;


    pub fn get_commendation(&self) -> &PlayerCommendationInfo {
        self.commendation.as_ref().unwrap_or_else(|| PlayerCommendationInfo::default_instance())
    }
    pub fn clear_commendation(&mut self) {
        self.commendation.clear();
    }

    pub fn has_commendation(&self) -> bool {
        self.commendation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commendation(&mut self, v: PlayerCommendationInfo) {
        self.commendation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commendation(&mut self) -> &mut PlayerCommendationInfo {
        if self.commendation.is_none() {
            self.commendation.set_default();
        }
        self.commendation.as_mut().unwrap()
    }

    // Take field
    pub fn take_commendation(&mut self) -> PlayerCommendationInfo {
        self.commendation.take().unwrap_or_else(|| PlayerCommendationInfo::new())
    }

    // optional .PlayerMedalsInfo medals = 9;


    pub fn get_medals(&self) -> &PlayerMedalsInfo {
        self.medals.as_ref().unwrap_or_else(|| PlayerMedalsInfo::default_instance())
    }
    pub fn clear_medals(&mut self) {
        self.medals.clear();
    }

    pub fn has_medals(&self) -> bool {
        self.medals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medals(&mut self, v: PlayerMedalsInfo) {
        self.medals = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_medals(&mut self) -> &mut PlayerMedalsInfo {
        if self.medals.is_none() {
            self.medals.set_default();
        }
        self.medals.as_mut().unwrap()
    }

    // Take field
    pub fn take_medals(&mut self) -> PlayerMedalsInfo {
        self.medals.take().unwrap_or_else(|| PlayerMedalsInfo::new())
    }

    // optional .TournamentEvent my_current_event = 10;


    pub fn get_my_current_event(&self) -> &TournamentEvent {
        self.my_current_event.as_ref().unwrap_or_else(|| TournamentEvent::default_instance())
    }
    pub fn clear_my_current_event(&mut self) {
        self.my_current_event.clear();
    }

    pub fn has_my_current_event(&self) -> bool {
        self.my_current_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_current_event(&mut self, v: TournamentEvent) {
        self.my_current_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_my_current_event(&mut self) -> &mut TournamentEvent {
        if self.my_current_event.is_none() {
            self.my_current_event.set_default();
        }
        self.my_current_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_my_current_event(&mut self) -> TournamentEvent {
        self.my_current_event.take().unwrap_or_else(|| TournamentEvent::new())
    }

    // repeated .TournamentTeam my_current_event_teams = 11;


    pub fn get_my_current_event_teams(&self) -> &[TournamentTeam] {
        &self.my_current_event_teams
    }
    pub fn clear_my_current_event_teams(&mut self) {
        self.my_current_event_teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_my_current_event_teams(&mut self, v: ::protobuf::RepeatedField<TournamentTeam>) {
        self.my_current_event_teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_my_current_event_teams(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.my_current_event_teams
    }

    // Take field
    pub fn take_my_current_event_teams(&mut self) -> ::protobuf::RepeatedField<TournamentTeam> {
        ::std::mem::replace(&mut self.my_current_event_teams, ::protobuf::RepeatedField::new())
    }

    // optional .TournamentTeam my_current_team = 12;


    pub fn get_my_current_team(&self) -> &TournamentTeam {
        self.my_current_team.as_ref().unwrap_or_else(|| TournamentTeam::default_instance())
    }
    pub fn clear_my_current_team(&mut self) {
        self.my_current_team.clear();
    }

    pub fn has_my_current_team(&self) -> bool {
        self.my_current_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_current_team(&mut self, v: TournamentTeam) {
        self.my_current_team = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_my_current_team(&mut self) -> &mut TournamentTeam {
        if self.my_current_team.is_none() {
            self.my_current_team.set_default();
        }
        self.my_current_team.as_mut().unwrap()
    }

    // Take field
    pub fn take_my_current_team(&mut self) -> TournamentTeam {
        self.my_current_team.take().unwrap_or_else(|| TournamentTeam::new())
    }

    // repeated .TournamentEvent my_current_event_stages = 13;


    pub fn get_my_current_event_stages(&self) -> &[TournamentEvent] {
        &self.my_current_event_stages
    }
    pub fn clear_my_current_event_stages(&mut self) {
        self.my_current_event_stages.clear();
    }

    // Param is passed by value, moved
    pub fn set_my_current_event_stages(&mut self, v: ::protobuf::RepeatedField<TournamentEvent>) {
        self.my_current_event_stages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_my_current_event_stages(&mut self) -> &mut ::protobuf::RepeatedField<TournamentEvent> {
        &mut self.my_current_event_stages
    }

    // Take field
    pub fn take_my_current_event_stages(&mut self) -> ::protobuf::RepeatedField<TournamentEvent> {
        ::std::mem::replace(&mut self.my_current_event_stages, ::protobuf::RepeatedField::new())
    }

    // optional uint32 survey_vote = 14;


    pub fn get_survey_vote(&self) -> u32 {
        self.survey_vote.unwrap_or(0)
    }
    pub fn clear_survey_vote(&mut self) {
        self.survey_vote = ::std::option::Option::None;
    }

    pub fn has_survey_vote(&self) -> bool {
        self.survey_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_vote(&mut self, v: u32) {
        self.survey_vote = ::std::option::Option::Some(v);
    }

    // optional .AccountActivity activity = 15;


    pub fn get_activity(&self) -> &AccountActivity {
        self.activity.as_ref().unwrap_or_else(|| AccountActivity::default_instance())
    }
    pub fn clear_activity(&mut self) {
        self.activity.clear();
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: AccountActivity) {
        self.activity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activity(&mut self) -> &mut AccountActivity {
        if self.activity.is_none() {
            self.activity.set_default();
        }
        self.activity.as_mut().unwrap()
    }

    // Take field
    pub fn take_activity(&mut self) -> AccountActivity {
        self.activity.take().unwrap_or_else(|| AccountActivity::new())
    }

    // optional int32 player_level = 17;


    pub fn get_player_level(&self) -> i32 {
        self.player_level.unwrap_or(0)
    }
    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: i32) {
        self.player_level = ::std::option::Option::Some(v);
    }

    // optional int32 player_cur_xp = 18;


    pub fn get_player_cur_xp(&self) -> i32 {
        self.player_cur_xp.unwrap_or(0)
    }
    pub fn clear_player_cur_xp(&mut self) {
        self.player_cur_xp = ::std::option::Option::None;
    }

    pub fn has_player_cur_xp(&self) -> bool {
        self.player_cur_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_cur_xp(&mut self, v: i32) {
        self.player_cur_xp = ::std::option::Option::Some(v);
    }

    // optional int32 player_xp_bonus_flags = 19;


    pub fn get_player_xp_bonus_flags(&self) -> i32 {
        self.player_xp_bonus_flags.unwrap_or(0)
    }
    pub fn clear_player_xp_bonus_flags(&mut self) {
        self.player_xp_bonus_flags = ::std::option::Option::None;
    }

    pub fn has_player_xp_bonus_flags(&self) -> bool {
        self.player_xp_bonus_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_xp_bonus_flags(&mut self, v: i32) {
        self.player_xp_bonus_flags = ::std::option::Option::Some(v);
    }

    // repeated .PlayerRankingInfo rankings = 20;


    pub fn get_rankings(&self) -> &[PlayerRankingInfo] {
        &self.rankings
    }
    pub fn clear_rankings(&mut self) {
        self.rankings.clear();
    }

    // Param is passed by value, moved
    pub fn set_rankings(&mut self, v: ::protobuf::RepeatedField<PlayerRankingInfo>) {
        self.rankings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rankings(&mut self) -> &mut ::protobuf::RepeatedField<PlayerRankingInfo> {
        &mut self.rankings
    }

    // Take field
    pub fn take_rankings(&mut self) -> ::protobuf::RepeatedField<PlayerRankingInfo> {
        ::std::mem::replace(&mut self.rankings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn is_initialized(&self) -> bool {
        for v in &self.ongoingmatch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.global_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranking {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commendation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.medals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.my_current_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.my_current_event_teams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.my_current_team {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.my_current_event_stages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rankings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ongoingmatch)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.global_stats)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty_seconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty_reason = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vac_banned = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ranking)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commendation)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.medals)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.my_current_event)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.my_current_event_teams)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.my_current_team)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.my_current_event_stages)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.survey_vote = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activity)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_level = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_cur_xp = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_xp_bonus_flags = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rankings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ongoingmatch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.penalty_seconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.penalty_reason {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vac_banned {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ranking.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.medals.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.my_current_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.my_current_event_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.my_current_team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.my_current_event_stages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.survey_vote {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.activity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_cur_xp {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_xp_bonus_flags {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.ongoingmatch.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.global_stats.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.penalty_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.penalty_reason {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.vac_banned {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.ranking.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commendation.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.medals.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.my_current_event.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.my_current_event_teams {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.my_current_team.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.my_current_event_stages {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.survey_vote {
            os.write_uint32(14, v)?;
        }
        if let Some(ref v) = self.activity.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.player_level {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.player_cur_xp {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.player_xp_bonus_flags {
            os.write_int32(19, v)?;
        }
        for v in &self.rankings {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>>(
                    "ongoingmatch",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.ongoingmatch },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.ongoingmatch },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlobalStatistics>>(
                    "global_stats",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.global_stats },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.global_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_seconds",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.penalty_seconds },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.penalty_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_reason",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.penalty_reason },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.penalty_reason },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "vac_banned",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.vac_banned },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.vac_banned },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerRankingInfo>>(
                    "ranking",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.ranking },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.ranking },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerCommendationInfo>>(
                    "commendation",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.commendation },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.commendation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerMedalsInfo>>(
                    "medals",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.medals },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.medals },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentEvent>>(
                    "my_current_event",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_event },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_event },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentTeam>>(
                    "my_current_event_teams",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_event_teams },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_event_teams },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentTeam>>(
                    "my_current_team",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_team },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_team },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentEvent>>(
                    "my_current_event_stages",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_event_stages },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_event_stages },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "survey_vote",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.survey_vote },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.survey_vote },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountActivity>>(
                    "activity",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.activity },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.activity },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_level",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.player_level },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.player_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_cur_xp",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.player_cur_xp },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.player_cur_xp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_xp_bonus_flags",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.player_xp_bonus_flags },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.player_xp_bonus_flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerRankingInfo>>(
                    "rankings",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.rankings },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.rankings },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ClientHello",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ClientHello,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.ongoingmatch.clear();
        self.global_stats.clear();
        self.penalty_seconds = ::std::option::Option::None;
        self.penalty_reason = ::std::option::Option::None;
        self.vac_banned = ::std::option::Option::None;
        self.ranking.clear();
        self.commendation.clear();
        self.medals.clear();
        self.my_current_event.clear();
        self.my_current_event_teams.clear();
        self.my_current_team.clear();
        self.my_current_event_stages.clear();
        self.survey_vote = ::std::option::Option::None;
        self.activity.clear();
        self.player_level = ::std::option::Option::None;
        self.player_cur_xp = ::std::option::Option::None;
        self.player_xp_bonus_flags = ::std::option::Option::None;
        self.rankings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_AccountPrivacySettings {
    // message fields
    settings: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn default() -> &'a CMsgGCCStrike15_v2_AccountPrivacySettings {
        <CMsgGCCStrike15_v2_AccountPrivacySettings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_AccountPrivacySettings {
    pub fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings {
        ::std::default::Default::default()
    }

    // repeated .CMsgGCCStrike15_v2_AccountPrivacySettings.Setting settings = 1;


    pub fn get_settings(&self) -> &[CMsgGCCStrike15_v2_AccountPrivacySettings_Setting] {
        &self.settings
    }
    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting>) {
        self.settings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_settings(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting> {
        &mut self.settings
    }

    // Take field
    pub fn take_settings(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting> {
        ::std::mem::replace(&mut self.settings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn is_initialized(&self) -> bool {
        for v in &self.settings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.settings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.settings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings {
        CMsgGCCStrike15_v2_AccountPrivacySettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting>>(
                    "settings",
                    |m: &CMsgGCCStrike15_v2_AccountPrivacySettings| { &m.settings },
                    |m: &mut CMsgGCCStrike15_v2_AccountPrivacySettings| { &mut m.settings },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_AccountPrivacySettings>(
                    "CMsgGCCStrike15_v2_AccountPrivacySettings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_AccountPrivacySettings {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_AccountPrivacySettings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_AccountPrivacySettings,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_AccountPrivacySettings::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn clear(&mut self) {
        self.settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    // message fields
    setting_type: ::std::option::Option<u32>,
    setting_value: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    fn default() -> &'a CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
        <CMsgGCCStrike15_v2_AccountPrivacySettings_Setting as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    pub fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
        ::std::default::Default::default()
    }

    // optional uint32 setting_type = 1;


    pub fn get_setting_type(&self) -> u32 {
        self.setting_type.unwrap_or(0)
    }
    pub fn clear_setting_type(&mut self) {
        self.setting_type = ::std::option::Option::None;
    }

    pub fn has_setting_type(&self) -> bool {
        self.setting_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setting_type(&mut self, v: u32) {
        self.setting_type = ::std::option::Option::Some(v);
    }

    // optional uint32 setting_value = 2;


    pub fn get_setting_value(&self) -> u32 {
        self.setting_value.unwrap_or(0)
    }
    pub fn clear_setting_value(&mut self) {
        self.setting_value = ::std::option::Option::None;
    }

    pub fn has_setting_value(&self) -> bool {
        self.setting_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setting_value(&mut self, v: u32) {
        self.setting_value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.setting_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.setting_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.setting_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.setting_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.setting_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.setting_value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
        CMsgGCCStrike15_v2_AccountPrivacySettings_Setting::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "setting_type",
                    |m: &CMsgGCCStrike15_v2_AccountPrivacySettings_Setting| { &m.setting_type },
                    |m: &mut CMsgGCCStrike15_v2_AccountPrivacySettings_Setting| { &mut m.setting_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "setting_value",
                    |m: &CMsgGCCStrike15_v2_AccountPrivacySettings_Setting| { &m.setting_value },
                    |m: &mut CMsgGCCStrike15_v2_AccountPrivacySettings_Setting| { &mut m.setting_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting>(
                    "CMsgGCCStrike15_v2_AccountPrivacySettings_Setting",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_AccountPrivacySettings_Setting> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_AccountPrivacySettings_Setting,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_AccountPrivacySettings_Setting::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    fn clear(&mut self) {
        self.setting_type = ::std::option::Option::None;
        self.setting_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_AccountPrivacySettings_Setting {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    // message fields
    account_id: ::std::option::Option<u32>,
    abandoned_match: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    penalty_seconds: ::std::option::Option<u32>,
    penalty_reason: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve abandoned_match = 2;


    pub fn get_abandoned_match(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.abandoned_match.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::default_instance())
    }
    pub fn clear_abandoned_match(&mut self) {
        self.abandoned_match.clear();
    }

    pub fn has_abandoned_match(&self) -> bool {
        self.abandoned_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandoned_match(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve) {
        self.abandoned_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_abandoned_match(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        if self.abandoned_match.is_none() {
            self.abandoned_match.set_default();
        }
        self.abandoned_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_abandoned_match(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.abandoned_match.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new())
    }

    // optional uint32 penalty_seconds = 3;


    pub fn get_penalty_seconds(&self) -> u32 {
        self.penalty_seconds.unwrap_or(0)
    }
    pub fn clear_penalty_seconds(&mut self) {
        self.penalty_seconds = ::std::option::Option::None;
    }

    pub fn has_penalty_seconds(&self) -> bool {
        self.penalty_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_seconds(&mut self, v: u32) {
        self.penalty_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_reason = 4;


    pub fn get_penalty_reason(&self) -> u32 {
        self.penalty_reason.unwrap_or(0)
    }
    pub fn clear_penalty_reason(&mut self) {
        self.penalty_reason = ::std::option::Option::None;
    }

    pub fn has_penalty_reason(&self) -> bool {
        self.penalty_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_reason(&mut self, v: u32) {
        self.penalty_reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn is_initialized(&self) -> bool {
        for v in &self.abandoned_match {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.abandoned_match)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty_seconds = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty_reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.abandoned_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.penalty_seconds {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.penalty_reason {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.abandoned_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.penalty_seconds {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.penalty_reason {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>>(
                    "abandoned_match",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.abandoned_match },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.abandoned_match },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_seconds",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.penalty_seconds },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.penalty_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "penalty_reason",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.penalty_reason },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.penalty_reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.abandoned_match.clear();
        self.penalty_seconds = ::std::option::Option::None;
        self.penalty_reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    // message fields
    account_id: ::std::option::Option<u32>,
    reservation: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    reason: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        <CMsgGCCStrike15_v2_MatchmakingServer2GCKick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve reservation = 2;


    pub fn get_reservation(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::default_instance())
    }
    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new())
    }

    // optional uint32 reason = 3;


    pub fn get_reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn is_initialized(&self) -> bool {
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        CMsgGCCStrike15_v2_MatchmakingServer2GCKick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>>(
                    "reservation",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &m.reservation },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &mut m.reservation },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reason",
                    |m: &CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &m.reason },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingServer2GCKick>(
                    "CMsgGCCStrike15_v2_MatchmakingServer2GCKick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingServer2GCKick> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingServer2GCKick,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingServer2GCKick::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.reservation.clear();
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    // message fields
    rankings: ::protobuf::RepeatedField<PlayerRankingInfo>,
    match_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        <CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        ::std::default::Default::default()
    }

    // repeated .PlayerRankingInfo rankings = 1;


    pub fn get_rankings(&self) -> &[PlayerRankingInfo] {
        &self.rankings
    }
    pub fn clear_rankings(&mut self) {
        self.rankings.clear();
    }

    // Param is passed by value, moved
    pub fn set_rankings(&mut self, v: ::protobuf::RepeatedField<PlayerRankingInfo>) {
        self.rankings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rankings(&mut self) -> &mut ::protobuf::RepeatedField<PlayerRankingInfo> {
        &mut self.rankings
    }

    // Take field
    pub fn take_rankings(&mut self) -> ::protobuf::RepeatedField<PlayerRankingInfo> {
        ::std::mem::replace(&mut self.rankings, ::protobuf::RepeatedField::new())
    }

    // optional uint64 match_id = 2;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.rankings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rankings)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rankings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerRankingInfo>>(
                    "rankings",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate| { &m.rankings },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate| { &mut m.rankings },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate| { &m.match_id },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate| { &mut m.match_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate>(
                    "CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn clear(&mut self) {
        self.rankings.clear();
        self.match_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientGCRankUpdate {
    // message fields
    rankings: ::protobuf::RepeatedField<PlayerRankingInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientGCRankUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientGCRankUpdate {
        <CMsgGCCStrike15_v2_ClientGCRankUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientGCRankUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_ClientGCRankUpdate {
        ::std::default::Default::default()
    }

    // repeated .PlayerRankingInfo rankings = 1;


    pub fn get_rankings(&self) -> &[PlayerRankingInfo] {
        &self.rankings
    }
    pub fn clear_rankings(&mut self) {
        self.rankings.clear();
    }

    // Param is passed by value, moved
    pub fn set_rankings(&mut self, v: ::protobuf::RepeatedField<PlayerRankingInfo>) {
        self.rankings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rankings(&mut self) -> &mut ::protobuf::RepeatedField<PlayerRankingInfo> {
        &mut self.rankings
    }

    // Take field
    pub fn take_rankings(&mut self) -> ::protobuf::RepeatedField<PlayerRankingInfo> {
        ::std::mem::replace(&mut self.rankings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientGCRankUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.rankings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rankings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rankings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientGCRankUpdate {
        CMsgGCCStrike15_v2_ClientGCRankUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerRankingInfo>>(
                    "rankings",
                    |m: &CMsgGCCStrike15_v2_ClientGCRankUpdate| { &m.rankings },
                    |m: &mut CMsgGCCStrike15_v2_ClientGCRankUpdate| { &mut m.rankings },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientGCRankUpdate>(
                    "CMsgGCCStrike15_v2_ClientGCRankUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientGCRankUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientGCRankUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientGCRankUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientGCRankUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientGCRankUpdate {
    fn clear(&mut self) {
        self.rankings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientGCRankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientGCRankUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    // message fields
    main_post_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        <CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        ::std::default::Default::default()
    }

    // optional string main_post_url = 1;


    pub fn get_main_post_url(&self) -> &str {
        match self.main_post_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_main_post_url(&mut self) {
        self.main_post_url.clear();
    }

    pub fn has_main_post_url(&self) -> bool {
        self.main_post_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_post_url(&mut self, v: ::std::string::String) {
        self.main_post_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_post_url(&mut self) -> &mut ::std::string::String {
        if self.main_post_url.is_none() {
            self.main_post_url.set_default();
        }
        self.main_post_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_post_url(&mut self) -> ::std::string::String {
        self.main_post_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.main_post_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.main_post_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.main_post_url.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "main_post_url",
                    |m: &CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate| { &m.main_post_url },
                    |m: &mut CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate| { &mut m.main_post_url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate>(
                    "CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn clear(&mut self) {
        self.main_post_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    // message fields
    account_id: ::std::option::Option<u32>,
    reason: ::std::option::Option<u32>,
    seconds: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn default() -> &'a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        <CMsgGCCStrike15_v2_ServerNotificationForUserPenalty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    pub fn new() -> CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reason = 2;


    pub fn get_reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds = 3;


    pub fn get_seconds(&self) -> u32 {
        self.seconds.unwrap_or(0)
    }
    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u32) {
        self.seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reason",
                    |m: &CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &m.reason },
                    |m: &mut CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &mut m.reason },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seconds",
                    |m: &CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &m.seconds },
                    |m: &mut CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &mut m.seconds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ServerNotificationForUserPenalty>(
                    "CMsgGCCStrike15_v2_ServerNotificationForUserPenalty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ServerNotificationForUserPenalty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ServerNotificationForUserPenalty,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientReportPlayer {
    // message fields
    account_id: ::std::option::Option<u32>,
    rpt_aimbot: ::std::option::Option<u32>,
    rpt_wallhack: ::std::option::Option<u32>,
    rpt_speedhack: ::std::option::Option<u32>,
    rpt_teamharm: ::std::option::Option<u32>,
    rpt_textabuse: ::std::option::Option<u32>,
    rpt_voiceabuse: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientReportPlayer {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientReportPlayer {
        <CMsgGCCStrike15_v2_ClientReportPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientReportPlayer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_aimbot = 2;


    pub fn get_rpt_aimbot(&self) -> u32 {
        self.rpt_aimbot.unwrap_or(0)
    }
    pub fn clear_rpt_aimbot(&mut self) {
        self.rpt_aimbot = ::std::option::Option::None;
    }

    pub fn has_rpt_aimbot(&self) -> bool {
        self.rpt_aimbot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_aimbot(&mut self, v: u32) {
        self.rpt_aimbot = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_wallhack = 3;


    pub fn get_rpt_wallhack(&self) -> u32 {
        self.rpt_wallhack.unwrap_or(0)
    }
    pub fn clear_rpt_wallhack(&mut self) {
        self.rpt_wallhack = ::std::option::Option::None;
    }

    pub fn has_rpt_wallhack(&self) -> bool {
        self.rpt_wallhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_wallhack(&mut self, v: u32) {
        self.rpt_wallhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_speedhack = 4;


    pub fn get_rpt_speedhack(&self) -> u32 {
        self.rpt_speedhack.unwrap_or(0)
    }
    pub fn clear_rpt_speedhack(&mut self) {
        self.rpt_speedhack = ::std::option::Option::None;
    }

    pub fn has_rpt_speedhack(&self) -> bool {
        self.rpt_speedhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_speedhack(&mut self, v: u32) {
        self.rpt_speedhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_teamharm = 5;


    pub fn get_rpt_teamharm(&self) -> u32 {
        self.rpt_teamharm.unwrap_or(0)
    }
    pub fn clear_rpt_teamharm(&mut self) {
        self.rpt_teamharm = ::std::option::Option::None;
    }

    pub fn has_rpt_teamharm(&self) -> bool {
        self.rpt_teamharm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_teamharm(&mut self, v: u32) {
        self.rpt_teamharm = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_textabuse = 6;


    pub fn get_rpt_textabuse(&self) -> u32 {
        self.rpt_textabuse.unwrap_or(0)
    }
    pub fn clear_rpt_textabuse(&mut self) {
        self.rpt_textabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_textabuse(&self) -> bool {
        self.rpt_textabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_textabuse(&mut self, v: u32) {
        self.rpt_textabuse = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_voiceabuse = 7;


    pub fn get_rpt_voiceabuse(&self) -> u32 {
        self.rpt_voiceabuse.unwrap_or(0)
    }
    pub fn clear_rpt_voiceabuse(&mut self) {
        self.rpt_voiceabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_voiceabuse(&self) -> bool {
        self.rpt_voiceabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_voiceabuse(&mut self, v: u32) {
        self.rpt_voiceabuse = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 8;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_aimbot = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_wallhack = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_speedhack = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_teamharm = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_textabuse = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_voiceabuse = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_aimbot {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_wallhack {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_speedhack {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_teamharm {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_textabuse {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_voiceabuse {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rpt_aimbot {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rpt_wallhack {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rpt_speedhack {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_teamharm {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rpt_textabuse {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rpt_voiceabuse {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientReportPlayer {
        CMsgGCCStrike15_v2_ClientReportPlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_aimbot",
                    |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_aimbot },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_aimbot },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_wallhack",
                    |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_wallhack },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_wallhack },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_speedhack",
                    |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_speedhack },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_speedhack },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_teamharm",
                    |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_teamharm },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_teamharm },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_textabuse",
                    |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_textabuse },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_textabuse },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_voiceabuse",
                    |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_voiceabuse },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_voiceabuse },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.match_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.match_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientReportPlayer>(
                    "CMsgGCCStrike15_v2_ClientReportPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportPlayer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientReportPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientReportPlayer,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientReportPlayer::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rpt_aimbot = ::std::option::Option::None;
        self.rpt_wallhack = ::std::option::Option::None;
        self.rpt_speedhack = ::std::option::Option::None;
        self.rpt_teamharm = ::std::option::Option::None;
        self.rpt_textabuse = ::std::option::Option::None;
        self.rpt_voiceabuse = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientCommendPlayer {
    // message fields
    account_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    commendation: ::protobuf::SingularPtrField<PlayerCommendationInfo>,
    tokens: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientCommendPlayer {
        <CMsgGCCStrike15_v2_ClientCommendPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientCommendPlayer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientCommendPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 8;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional .PlayerCommendationInfo commendation = 9;


    pub fn get_commendation(&self) -> &PlayerCommendationInfo {
        self.commendation.as_ref().unwrap_or_else(|| PlayerCommendationInfo::default_instance())
    }
    pub fn clear_commendation(&mut self) {
        self.commendation.clear();
    }

    pub fn has_commendation(&self) -> bool {
        self.commendation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commendation(&mut self, v: PlayerCommendationInfo) {
        self.commendation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commendation(&mut self) -> &mut PlayerCommendationInfo {
        if self.commendation.is_none() {
            self.commendation.set_default();
        }
        self.commendation.as_mut().unwrap()
    }

    // Take field
    pub fn take_commendation(&mut self) -> PlayerCommendationInfo {
        self.commendation.take().unwrap_or_else(|| PlayerCommendationInfo::new())
    }

    // optional uint32 tokens = 10;


    pub fn get_tokens(&self) -> u32 {
        self.tokens.unwrap_or(0)
    }
    pub fn clear_tokens(&mut self) {
        self.tokens = ::std::option::Option::None;
    }

    pub fn has_tokens(&self) -> bool {
        self.tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: u32) {
        self.tokens = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn is_initialized(&self) -> bool {
        for v in &self.commendation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commendation)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tokens = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tokens {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        if let Some(ref v) = self.commendation.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.tokens {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientCommendPlayer {
        CMsgGCCStrike15_v2_ClientCommendPlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.match_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.match_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerCommendationInfo>>(
                    "commendation",
                    |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.commendation },
                    |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.commendation },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tokens",
                    |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.tokens },
                    |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.tokens },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientCommendPlayer>(
                    "CMsgGCCStrike15_v2_ClientCommendPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientCommendPlayer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientCommendPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientCommendPlayer,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientCommendPlayer::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.commendation.clear();
        self.tokens = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientReportServer {
    // message fields
    rpt_poorperf: ::std::option::Option<u32>,
    rpt_abusivemodels: ::std::option::Option<u32>,
    rpt_badmotd: ::std::option::Option<u32>,
    rpt_listingabuse: ::std::option::Option<u32>,
    rpt_inventoryabuse: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientReportServer {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientReportServer {
        <CMsgGCCStrike15_v2_ClientReportServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientReportServer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportServer {
        ::std::default::Default::default()
    }

    // optional uint32 rpt_poorperf = 1;


    pub fn get_rpt_poorperf(&self) -> u32 {
        self.rpt_poorperf.unwrap_or(0)
    }
    pub fn clear_rpt_poorperf(&mut self) {
        self.rpt_poorperf = ::std::option::Option::None;
    }

    pub fn has_rpt_poorperf(&self) -> bool {
        self.rpt_poorperf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_poorperf(&mut self, v: u32) {
        self.rpt_poorperf = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_abusivemodels = 2;


    pub fn get_rpt_abusivemodels(&self) -> u32 {
        self.rpt_abusivemodels.unwrap_or(0)
    }
    pub fn clear_rpt_abusivemodels(&mut self) {
        self.rpt_abusivemodels = ::std::option::Option::None;
    }

    pub fn has_rpt_abusivemodels(&self) -> bool {
        self.rpt_abusivemodels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_abusivemodels(&mut self, v: u32) {
        self.rpt_abusivemodels = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_badmotd = 3;


    pub fn get_rpt_badmotd(&self) -> u32 {
        self.rpt_badmotd.unwrap_or(0)
    }
    pub fn clear_rpt_badmotd(&mut self) {
        self.rpt_badmotd = ::std::option::Option::None;
    }

    pub fn has_rpt_badmotd(&self) -> bool {
        self.rpt_badmotd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_badmotd(&mut self, v: u32) {
        self.rpt_badmotd = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_listingabuse = 4;


    pub fn get_rpt_listingabuse(&self) -> u32 {
        self.rpt_listingabuse.unwrap_or(0)
    }
    pub fn clear_rpt_listingabuse(&mut self) {
        self.rpt_listingabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_listingabuse(&self) -> bool {
        self.rpt_listingabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_listingabuse(&mut self, v: u32) {
        self.rpt_listingabuse = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_inventoryabuse = 5;


    pub fn get_rpt_inventoryabuse(&self) -> u32 {
        self.rpt_inventoryabuse.unwrap_or(0)
    }
    pub fn clear_rpt_inventoryabuse(&mut self) {
        self.rpt_inventoryabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_inventoryabuse(&self) -> bool {
        self.rpt_inventoryabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_inventoryabuse(&mut self, v: u32) {
        self.rpt_inventoryabuse = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 8;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_poorperf = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_abusivemodels = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_badmotd = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_listingabuse = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_inventoryabuse = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.rpt_poorperf {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_abusivemodels {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_badmotd {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_listingabuse {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_inventoryabuse {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rpt_poorperf {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rpt_abusivemodels {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rpt_badmotd {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rpt_listingabuse {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_inventoryabuse {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientReportServer {
        CMsgGCCStrike15_v2_ClientReportServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_poorperf",
                    |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_poorperf },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_poorperf },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_abusivemodels",
                    |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_abusivemodels },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_abusivemodels },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_badmotd",
                    |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_badmotd },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_badmotd },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_listingabuse",
                    |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_listingabuse },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_listingabuse },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_inventoryabuse",
                    |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_inventoryabuse },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_inventoryabuse },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.match_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.match_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientReportServer>(
                    "CMsgGCCStrike15_v2_ClientReportServer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportServer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientReportServer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientReportServer,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientReportServer::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientReportServer {
    fn clear(&mut self) {
        self.rpt_poorperf = ::std::option::Option::None;
        self.rpt_abusivemodels = ::std::option::Option::None;
        self.rpt_badmotd = ::std::option::Option::None;
        self.rpt_listingabuse = ::std::option::Option::None;
        self.rpt_inventoryabuse = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientReportServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportServer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientReportResponse {
    // message fields
    confirmation_id: ::std::option::Option<u64>,
    account_id: ::std::option::Option<u32>,
    server_ip: ::std::option::Option<u32>,
    response_type: ::std::option::Option<u32>,
    response_result: ::std::option::Option<u32>,
    tokens: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientReportResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientReportResponse {
        <CMsgGCCStrike15_v2_ClientReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientReportResponse {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportResponse {
        ::std::default::Default::default()
    }

    // optional uint64 confirmation_id = 1;


    pub fn get_confirmation_id(&self) -> u64 {
        self.confirmation_id.unwrap_or(0)
    }
    pub fn clear_confirmation_id(&mut self) {
        self.confirmation_id = ::std::option::Option::None;
    }

    pub fn has_confirmation_id(&self) -> bool {
        self.confirmation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confirmation_id(&mut self, v: u64) {
        self.confirmation_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_ip = 3;


    pub fn get_server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }
    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 response_type = 4;


    pub fn get_response_type(&self) -> u32 {
        self.response_type.unwrap_or(0)
    }
    pub fn clear_response_type(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_response_type(&self) -> bool {
        self.response_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_type(&mut self, v: u32) {
        self.response_type = ::std::option::Option::Some(v);
    }

    // optional uint32 response_result = 5;


    pub fn get_response_result(&self) -> u32 {
        self.response_result.unwrap_or(0)
    }
    pub fn clear_response_result(&mut self) {
        self.response_result = ::std::option::Option::None;
    }

    pub fn has_response_result(&self) -> bool {
        self.response_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_result(&mut self, v: u32) {
        self.response_result = ::std::option::Option::Some(v);
    }

    // optional uint32 tokens = 6;


    pub fn get_tokens(&self) -> u32 {
        self.tokens.unwrap_or(0)
    }
    pub fn clear_tokens(&mut self) {
        self.tokens = ::std::option::Option::None;
    }

    pub fn has_tokens(&self) -> bool {
        self.tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: u32) {
        self.tokens = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.confirmation_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_ip = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.response_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.response_result = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tokens = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.confirmation_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.response_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.response_result {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tokens {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.confirmation_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.response_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.response_result {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tokens {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientReportResponse {
        CMsgGCCStrike15_v2_ClientReportResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "confirmation_id",
                    |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.confirmation_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.confirmation_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_ip",
                    |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.server_ip },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.server_ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "response_type",
                    |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.response_type },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.response_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "response_result",
                    |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.response_result },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.response_result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tokens",
                    |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.tokens },
                    |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.tokens },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientReportResponse>(
                    "CMsgGCCStrike15_v2_ClientReportResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientReportResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientReportResponse,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientReportResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientReportResponse {
    fn clear(&mut self) {
        self.confirmation_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.server_ip = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_result = ::std::option::Option::None;
        self.tokens = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    // message fields
    request_id: ::std::option::Option<u32>,
    account_ids: ::std::vec::Vec<u32>,
    serverid: ::std::option::Option<u64>,
    matchid: ::std::option::Option<u64>,
    client_launcher: ::std::option::Option<u32>,
    data_center_pings: ::protobuf::RepeatedField<DataCenterPing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        <CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // repeated uint32 account_ids = 2;


    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }
    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    // optional uint64 serverid = 3;


    pub fn get_serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }
    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    // optional uint64 matchid = 4;


    pub fn get_matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }
    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    // optional uint32 client_launcher = 5;


    pub fn get_client_launcher(&self) -> u32 {
        self.client_launcher.unwrap_or(0)
    }
    pub fn clear_client_launcher(&mut self) {
        self.client_launcher = ::std::option::Option::None;
    }

    pub fn has_client_launcher(&self) -> bool {
        self.client_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_launcher(&mut self, v: u32) {
        self.client_launcher = ::std::option::Option::Some(v);
    }

    // repeated .DataCenterPing data_center_pings = 6;


    pub fn get_data_center_pings(&self) -> &[DataCenterPing] {
        &self.data_center_pings
    }
    pub fn clear_data_center_pings(&mut self) {
        self.data_center_pings.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_center_pings(&mut self, v: ::protobuf::RepeatedField<DataCenterPing>) {
        self.data_center_pings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_center_pings(&mut self) -> &mut ::protobuf::RepeatedField<DataCenterPing> {
        &mut self.data_center_pings
    }

    // Take field
    pub fn take_data_center_pings(&mut self) -> ::protobuf::RepeatedField<DataCenterPing> {
        ::std::mem::replace(&mut self.data_center_pings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn is_initialized(&self) -> bool {
        for v in &self.data_center_pings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.serverid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.matchid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_launcher = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_center_pings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_launcher {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.data_center_pings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.serverid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.matchid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.client_launcher {
            os.write_uint32(5, v)?;
        }
        for v in &self.data_center_pings {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.request_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.account_ids },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.account_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "serverid",
                    |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.serverid },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.serverid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "matchid",
                    |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.matchid },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.matchid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "client_launcher",
                    |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.client_launcher },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.client_launcher },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataCenterPing>>(
                    "data_center_pings",
                    |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.data_center_pings },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.data_center_pings },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends>(
                    "CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.serverid = ::std::option::Option::None;
        self.matchid = ::std::option::Option::None;
        self.client_launcher = ::std::option::Option::None;
        self.data_center_pings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchableMatchInfo {
    // message fields
    server_ip: ::std::option::Option<u32>,
    tv_port: ::std::option::Option<u32>,
    tv_spectators: ::std::option::Option<u32>,
    tv_time: ::std::option::Option<u32>,
    tv_watch_password: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    cl_decryptdata_key: ::std::option::Option<u64>,
    cl_decryptdata_key_pub: ::std::option::Option<u64>,
    game_type: ::std::option::Option<u32>,
    game_mapgroup: ::protobuf::SingularField<::std::string::String>,
    game_map: ::protobuf::SingularField<::std::string::String>,
    server_id: ::std::option::Option<u64>,
    match_id: ::std::option::Option<u64>,
    reservation_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchableMatchInfo {
    fn default() -> &'a WatchableMatchInfo {
        <WatchableMatchInfo as ::protobuf::Message>::default_instance()
    }
}

impl WatchableMatchInfo {
    pub fn new() -> WatchableMatchInfo {
        ::std::default::Default::default()
    }

    // optional uint32 server_ip = 1;


    pub fn get_server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }
    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_port = 2;


    pub fn get_tv_port(&self) -> u32 {
        self.tv_port.unwrap_or(0)
    }
    pub fn clear_tv_port(&mut self) {
        self.tv_port = ::std::option::Option::None;
    }

    pub fn has_tv_port(&self) -> bool {
        self.tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_port(&mut self, v: u32) {
        self.tv_port = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_spectators = 3;


    pub fn get_tv_spectators(&self) -> u32 {
        self.tv_spectators.unwrap_or(0)
    }
    pub fn clear_tv_spectators(&mut self) {
        self.tv_spectators = ::std::option::Option::None;
    }

    pub fn has_tv_spectators(&self) -> bool {
        self.tv_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_spectators(&mut self, v: u32) {
        self.tv_spectators = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_time = 4;


    pub fn get_tv_time(&self) -> u32 {
        self.tv_time.unwrap_or(0)
    }
    pub fn clear_tv_time(&mut self) {
        self.tv_time = ::std::option::Option::None;
    }

    pub fn has_tv_time(&self) -> bool {
        self.tv_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_time(&mut self, v: u32) {
        self.tv_time = ::std::option::Option::Some(v);
    }

    // optional bytes tv_watch_password = 5;


    pub fn get_tv_watch_password(&self) -> &[u8] {
        match self.tv_watch_password.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tv_watch_password(&mut self) {
        self.tv_watch_password.clear();
    }

    pub fn has_tv_watch_password(&self) -> bool {
        self.tv_watch_password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_watch_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.tv_watch_password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tv_watch_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tv_watch_password.is_none() {
            self.tv_watch_password.set_default();
        }
        self.tv_watch_password.as_mut().unwrap()
    }

    // Take field
    pub fn take_tv_watch_password(&mut self) -> ::std::vec::Vec<u8> {
        self.tv_watch_password.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 cl_decryptdata_key = 6;


    pub fn get_cl_decryptdata_key(&self) -> u64 {
        self.cl_decryptdata_key.unwrap_or(0)
    }
    pub fn clear_cl_decryptdata_key(&mut self) {
        self.cl_decryptdata_key = ::std::option::Option::None;
    }

    pub fn has_cl_decryptdata_key(&self) -> bool {
        self.cl_decryptdata_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cl_decryptdata_key(&mut self, v: u64) {
        self.cl_decryptdata_key = ::std::option::Option::Some(v);
    }

    // optional uint64 cl_decryptdata_key_pub = 7;


    pub fn get_cl_decryptdata_key_pub(&self) -> u64 {
        self.cl_decryptdata_key_pub.unwrap_or(0)
    }
    pub fn clear_cl_decryptdata_key_pub(&mut self) {
        self.cl_decryptdata_key_pub = ::std::option::Option::None;
    }

    pub fn has_cl_decryptdata_key_pub(&self) -> bool {
        self.cl_decryptdata_key_pub.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cl_decryptdata_key_pub(&mut self, v: u64) {
        self.cl_decryptdata_key_pub = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 8;


    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }
    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional string game_mapgroup = 9;


    pub fn get_game_mapgroup(&self) -> &str {
        match self.game_mapgroup.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_mapgroup(&mut self) {
        self.game_mapgroup.clear();
    }

    pub fn has_game_mapgroup(&self) -> bool {
        self.game_mapgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mapgroup(&mut self, v: ::std::string::String) {
        self.game_mapgroup = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mapgroup(&mut self) -> &mut ::std::string::String {
        if self.game_mapgroup.is_none() {
            self.game_mapgroup.set_default();
        }
        self.game_mapgroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mapgroup(&mut self) -> ::std::string::String {
        self.game_mapgroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_map = 10;


    pub fn get_game_map(&self) -> &str {
        match self.game_map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_map(&mut self) {
        self.game_map.clear();
    }

    pub fn has_game_map(&self) -> bool {
        self.game_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_map(&mut self, v: ::std::string::String) {
        self.game_map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_map(&mut self) -> &mut ::std::string::String {
        if self.game_map.is_none() {
            self.game_map.set_default();
        }
        self.game_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_map(&mut self) -> ::std::string::String {
        self.game_map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 server_id = 11;


    pub fn get_server_id(&self) -> u64 {
        self.server_id.unwrap_or(0)
    }
    pub fn clear_server_id(&mut self) {
        self.server_id = ::std::option::Option::None;
    }

    pub fn has_server_id(&self) -> bool {
        self.server_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_id(&mut self, v: u64) {
        self.server_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 12;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint64 reservation_id = 13;


    pub fn get_reservation_id(&self) -> u64 {
        self.reservation_id.unwrap_or(0)
    }
    pub fn clear_reservation_id(&mut self) {
        self.reservation_id = ::std::option::Option::None;
    }

    pub fn has_reservation_id(&self) -> bool {
        self.reservation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_id(&mut self, v: u64) {
        self.reservation_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for WatchableMatchInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_ip = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_spectators = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tv_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tv_watch_password)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cl_decryptdata_key = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cl_decryptdata_key_pub = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_mapgroup)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_map)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.server_id = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservation_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_spectators {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tv_watch_password.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.cl_decryptdata_key {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cl_decryptdata_key_pub {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_mapgroup.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.game_map.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.server_id {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reservation_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_ip {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tv_port {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tv_spectators {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tv_time {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.tv_watch_password.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.cl_decryptdata_key {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.cl_decryptdata_key_pub {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(8, v)?;
        }
        if let Some(ref v) = self.game_mapgroup.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.game_map.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.server_id {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.reservation_id {
            os.write_uint64(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchableMatchInfo {
        WatchableMatchInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_ip",
                    |m: &WatchableMatchInfo| { &m.server_ip },
                    |m: &mut WatchableMatchInfo| { &mut m.server_ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_port",
                    |m: &WatchableMatchInfo| { &m.tv_port },
                    |m: &mut WatchableMatchInfo| { &mut m.tv_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_spectators",
                    |m: &WatchableMatchInfo| { &m.tv_spectators },
                    |m: &mut WatchableMatchInfo| { &mut m.tv_spectators },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tv_time",
                    |m: &WatchableMatchInfo| { &m.tv_time },
                    |m: &mut WatchableMatchInfo| { &mut m.tv_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tv_watch_password",
                    |m: &WatchableMatchInfo| { &m.tv_watch_password },
                    |m: &mut WatchableMatchInfo| { &mut m.tv_watch_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cl_decryptdata_key",
                    |m: &WatchableMatchInfo| { &m.cl_decryptdata_key },
                    |m: &mut WatchableMatchInfo| { &mut m.cl_decryptdata_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cl_decryptdata_key_pub",
                    |m: &WatchableMatchInfo| { &m.cl_decryptdata_key_pub },
                    |m: &mut WatchableMatchInfo| { &mut m.cl_decryptdata_key_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    |m: &WatchableMatchInfo| { &m.game_type },
                    |m: &mut WatchableMatchInfo| { &mut m.game_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_mapgroup",
                    |m: &WatchableMatchInfo| { &m.game_mapgroup },
                    |m: &mut WatchableMatchInfo| { &mut m.game_mapgroup },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_map",
                    |m: &WatchableMatchInfo| { &m.game_map },
                    |m: &mut WatchableMatchInfo| { &mut m.game_map },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "server_id",
                    |m: &WatchableMatchInfo| { &m.server_id },
                    |m: &mut WatchableMatchInfo| { &mut m.server_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    |m: &WatchableMatchInfo| { &m.match_id },
                    |m: &mut WatchableMatchInfo| { &mut m.match_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reservation_id",
                    |m: &WatchableMatchInfo| { &m.reservation_id },
                    |m: &mut WatchableMatchInfo| { &mut m.reservation_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WatchableMatchInfo>(
                    "WatchableMatchInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WatchableMatchInfo {
        static mut instance: ::protobuf::lazy::Lazy<WatchableMatchInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WatchableMatchInfo,
        };
        unsafe {
            instance.get(WatchableMatchInfo::new)
        }
    }
}

impl ::protobuf::Clear for WatchableMatchInfo {
    fn clear(&mut self) {
        self.server_ip = ::std::option::Option::None;
        self.tv_port = ::std::option::Option::None;
        self.tv_spectators = ::std::option::Option::None;
        self.tv_time = ::std::option::Option::None;
        self.tv_watch_password.clear();
        self.cl_decryptdata_key = ::std::option::Option::None;
        self.cl_decryptdata_key_pub = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.game_mapgroup.clear();
        self.game_map.clear();
        self.server_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.reservation_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchableMatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchableMatchInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    // message fields
    version: ::std::option::Option<u32>,
    account_id: ::std::option::Option<u32>,
    join_token: ::std::option::Option<u32>,
    join_ipp: ::std::option::Option<u32>,
    res: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    errormsg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        <CMsgGCCStrike15_v2_ClientRequestJoinFriendData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 join_token = 3;


    pub fn get_join_token(&self) -> u32 {
        self.join_token.unwrap_or(0)
    }
    pub fn clear_join_token(&mut self) {
        self.join_token = ::std::option::Option::None;
    }

    pub fn has_join_token(&self) -> bool {
        self.join_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_token(&mut self, v: u32) {
        self.join_token = ::std::option::Option::Some(v);
    }

    // optional uint32 join_ipp = 4;


    pub fn get_join_ipp(&self) -> u32 {
        self.join_ipp.unwrap_or(0)
    }
    pub fn clear_join_ipp(&mut self) {
        self.join_ipp = ::std::option::Option::None;
    }

    pub fn has_join_ipp(&self) -> bool {
        self.join_ipp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_ipp(&mut self, v: u32) {
        self.join_ipp = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve res = 5;


    pub fn get_res(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.res.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::default_instance())
    }
    pub fn clear_res(&mut self) {
        self.res.clear();
    }

    pub fn has_res(&self) -> bool {
        self.res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_res(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve) {
        self.res = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_res(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        if self.res.is_none() {
            self.res.set_default();
        }
        self.res.as_mut().unwrap()
    }

    // Take field
    pub fn take_res(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.res.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new())
    }

    // optional string errormsg = 6;


    pub fn get_errormsg(&self) -> &str {
        match self.errormsg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_errormsg(&mut self) {
        self.errormsg.clear();
    }

    pub fn has_errormsg(&self) -> bool {
        self.errormsg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errormsg(&mut self, v: ::std::string::String) {
        self.errormsg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errormsg(&mut self) -> &mut ::std::string::String {
        if self.errormsg.is_none() {
            self.errormsg.set_default();
        }
        self.errormsg.as_mut().unwrap()
    }

    // Take field
    pub fn take_errormsg(&mut self) -> ::std::string::String {
        self.errormsg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn is_initialized(&self) -> bool {
        for v in &self.res {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.join_token = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.join_ipp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.res)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errormsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.join_token {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.join_ipp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.res.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.errormsg.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.join_token {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.join_ipp {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.res.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.errormsg.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        CMsgGCCStrike15_v2_ClientRequestJoinFriendData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.version },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "join_token",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.join_token },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.join_token },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "join_ipp",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.join_ipp },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.join_ipp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>>(
                    "res",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.res },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.res },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "errormsg",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.errormsg },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.errormsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientRequestJoinFriendData>(
                    "CMsgGCCStrike15_v2_ClientRequestJoinFriendData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientRequestJoinFriendData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientRequestJoinFriendData,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientRequestJoinFriendData::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.join_token = ::std::option::Option::None;
        self.join_ipp = ::std::option::Option::None;
        self.res.clear();
        self.errormsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    // message fields
    version: ::std::option::Option<u32>,
    account_id: ::std::option::Option<u32>,
    serverid: ::std::option::Option<u64>,
    server_ip: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    res: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    errormsg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        <CMsgGCCStrike15_v2_ClientRequestJoinServerData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 serverid = 3;


    pub fn get_serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }
    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    // optional uint32 server_ip = 4;


    pub fn get_server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }
    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 5;


    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }
    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve res = 6;


    pub fn get_res(&self) -> &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.res.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::default_instance())
    }
    pub fn clear_res(&mut self) {
        self.res.clear();
    }

    pub fn has_res(&self) -> bool {
        self.res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_res(&mut self, v: CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve) {
        self.res = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_res(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        if self.res.is_none() {
            self.res.set_default();
        }
        self.res.as_mut().unwrap()
    }

    // Take field
    pub fn take_res(&mut self) -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        self.res.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new())
    }

    // optional string errormsg = 7;


    pub fn get_errormsg(&self) -> &str {
        match self.errormsg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_errormsg(&mut self) {
        self.errormsg.clear();
    }

    pub fn has_errormsg(&self) -> bool {
        self.errormsg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errormsg(&mut self, v: ::std::string::String) {
        self.errormsg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errormsg(&mut self) -> &mut ::std::string::String {
        if self.errormsg.is_none() {
            self.errormsg.set_default();
        }
        self.errormsg.as_mut().unwrap()
    }

    // Take field
    pub fn take_errormsg(&mut self) -> ::std::string::String {
        self.errormsg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn is_initialized(&self) -> bool {
        for v in &self.res {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.serverid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_ip = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.res)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errormsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.res.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.errormsg.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.serverid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.res.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.errormsg.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        CMsgGCCStrike15_v2_ClientRequestJoinServerData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.version },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "serverid",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.serverid },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.serverid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_ip",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.server_ip },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.server_ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_port",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.server_port },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.server_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>>(
                    "res",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.res },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.res },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "errormsg",
                    |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.errormsg },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.errormsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientRequestJoinServerData>(
                    "CMsgGCCStrike15_v2_ClientRequestJoinServerData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientRequestJoinServerData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientRequestJoinServerData,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientRequestJoinServerData::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.serverid = ::std::option::Option::None;
        self.server_ip = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.res.clear();
        self.errormsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCstrike15_v2_ClientRequestNewMission {
    // message fields
    mission_id: ::std::option::Option<u32>,
    campaign_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn default() -> &'a CMsgGCCstrike15_v2_ClientRequestNewMission {
        <CMsgGCCstrike15_v2_ClientRequestNewMission as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCstrike15_v2_ClientRequestNewMission {
    pub fn new() -> CMsgGCCstrike15_v2_ClientRequestNewMission {
        ::std::default::Default::default()
    }

    // optional uint32 mission_id = 2;


    pub fn get_mission_id(&self) -> u32 {
        self.mission_id.unwrap_or(0)
    }
    pub fn clear_mission_id(&mut self) {
        self.mission_id = ::std::option::Option::None;
    }

    pub fn has_mission_id(&self) -> bool {
        self.mission_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_id(&mut self, v: u32) {
        self.mission_id = ::std::option::Option::Some(v);
    }

    // optional uint32 campaign_id = 3;


    pub fn get_campaign_id(&self) -> u32 {
        self.campaign_id.unwrap_or(0)
    }
    pub fn clear_campaign_id(&mut self) {
        self.campaign_id = ::std::option::Option::None;
    }

    pub fn has_campaign_id(&self) -> bool {
        self.campaign_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaign_id(&mut self, v: u32) {
        self.campaign_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mission_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.campaign_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mission_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.campaign_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mission_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.campaign_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCstrike15_v2_ClientRequestNewMission {
        CMsgGCCstrike15_v2_ClientRequestNewMission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mission_id",
                    |m: &CMsgGCCstrike15_v2_ClientRequestNewMission| { &m.mission_id },
                    |m: &mut CMsgGCCstrike15_v2_ClientRequestNewMission| { &mut m.mission_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "campaign_id",
                    |m: &CMsgGCCstrike15_v2_ClientRequestNewMission| { &m.campaign_id },
                    |m: &mut CMsgGCCstrike15_v2_ClientRequestNewMission| { &mut m.campaign_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCstrike15_v2_ClientRequestNewMission>(
                    "CMsgGCCstrike15_v2_ClientRequestNewMission",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCstrike15_v2_ClientRequestNewMission {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCstrike15_v2_ClientRequestNewMission> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCstrike15_v2_ClientRequestNewMission,
        };
        unsafe {
            instance.get(CMsgGCCstrike15_v2_ClientRequestNewMission::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn clear(&mut self) {
        self.mission_id = ::std::option::Option::None;
        self.campaign_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    // message fields
    xp_progress_data: ::protobuf::RepeatedField<XpProgressData>,
    account_id: ::std::option::Option<u32>,
    current_xp: ::std::option::Option<u32>,
    current_level: ::std::option::Option<u32>,
    upgraded_defidx: ::std::option::Option<u32>,
    operation_points_awarded: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn default() -> &'a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        <CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    pub fn new() -> CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        ::std::default::Default::default()
    }

    // repeated .XpProgressData xp_progress_data = 1;


    pub fn get_xp_progress_data(&self) -> &[XpProgressData] {
        &self.xp_progress_data
    }
    pub fn clear_xp_progress_data(&mut self) {
        self.xp_progress_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_xp_progress_data(&mut self, v: ::protobuf::RepeatedField<XpProgressData>) {
        self.xp_progress_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xp_progress_data(&mut self) -> &mut ::protobuf::RepeatedField<XpProgressData> {
        &mut self.xp_progress_data
    }

    // Take field
    pub fn take_xp_progress_data(&mut self) -> ::protobuf::RepeatedField<XpProgressData> {
        ::std::mem::replace(&mut self.xp_progress_data, ::protobuf::RepeatedField::new())
    }

    // optional uint32 account_id = 2;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 current_xp = 3;


    pub fn get_current_xp(&self) -> u32 {
        self.current_xp.unwrap_or(0)
    }
    pub fn clear_current_xp(&mut self) {
        self.current_xp = ::std::option::Option::None;
    }

    pub fn has_current_xp(&self) -> bool {
        self.current_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_xp(&mut self, v: u32) {
        self.current_xp = ::std::option::Option::Some(v);
    }

    // optional uint32 current_level = 4;


    pub fn get_current_level(&self) -> u32 {
        self.current_level.unwrap_or(0)
    }
    pub fn clear_current_level(&mut self) {
        self.current_level = ::std::option::Option::None;
    }

    pub fn has_current_level(&self) -> bool {
        self.current_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_level(&mut self, v: u32) {
        self.current_level = ::std::option::Option::Some(v);
    }

    // optional uint32 upgraded_defidx = 5;


    pub fn get_upgraded_defidx(&self) -> u32 {
        self.upgraded_defidx.unwrap_or(0)
    }
    pub fn clear_upgraded_defidx(&mut self) {
        self.upgraded_defidx = ::std::option::Option::None;
    }

    pub fn has_upgraded_defidx(&self) -> bool {
        self.upgraded_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgraded_defidx(&mut self, v: u32) {
        self.upgraded_defidx = ::std::option::Option::Some(v);
    }

    // optional uint32 operation_points_awarded = 6;


    pub fn get_operation_points_awarded(&self) -> u32 {
        self.operation_points_awarded.unwrap_or(0)
    }
    pub fn clear_operation_points_awarded(&mut self) {
        self.operation_points_awarded = ::std::option::Option::None;
    }

    pub fn has_operation_points_awarded(&self) -> bool {
        self.operation_points_awarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation_points_awarded(&mut self, v: u32) {
        self.operation_points_awarded = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn is_initialized(&self) -> bool {
        for v in &self.xp_progress_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.xp_progress_data)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current_xp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current_level = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.upgraded_defidx = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.operation_points_awarded = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.xp_progress_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current_xp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current_level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.upgraded_defidx {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.operation_points_awarded {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.xp_progress_data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.current_xp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.current_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.upgraded_defidx {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.operation_points_awarded {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<XpProgressData>>(
                    "xp_progress_data",
                    |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.xp_progress_data },
                    |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.xp_progress_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.account_id },
                    |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "current_xp",
                    |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.current_xp },
                    |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.current_xp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "current_level",
                    |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.current_level },
                    |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.current_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "upgraded_defidx",
                    |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.upgraded_defidx },
                    |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.upgraded_defidx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "operation_points_awarded",
                    |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.operation_points_awarded },
                    |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.operation_points_awarded },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>(
                    "CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded,
        };
        unsafe {
            instance.get(CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn clear(&mut self) {
        self.xp_progress_data.clear();
        self.account_id = ::std::option::Option::None;
        self.current_xp = ::std::option::Option::None;
        self.current_level = ::std::option::Option::None;
        self.upgraded_defidx = ::std::option::Option::None;
        self.operation_points_awarded = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_WatchInfoUsers {
    // message fields
    request_id: ::std::option::Option<u32>,
    account_ids: ::std::vec::Vec<u32>,
    watchable_match_infos: ::protobuf::RepeatedField<WatchableMatchInfo>,
    extended_timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_WatchInfoUsers {
    fn default() -> &'a CMsgGCCStrike15_v2_WatchInfoUsers {
        <CMsgGCCStrike15_v2_WatchInfoUsers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_WatchInfoUsers {
    pub fn new() -> CMsgGCCStrike15_v2_WatchInfoUsers {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // repeated uint32 account_ids = 2;


    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }
    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    // repeated .WatchableMatchInfo watchable_match_infos = 3;


    pub fn get_watchable_match_infos(&self) -> &[WatchableMatchInfo] {
        &self.watchable_match_infos
    }
    pub fn clear_watchable_match_infos(&mut self) {
        self.watchable_match_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_watchable_match_infos(&mut self, v: ::protobuf::RepeatedField<WatchableMatchInfo>) {
        self.watchable_match_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_watchable_match_infos(&mut self) -> &mut ::protobuf::RepeatedField<WatchableMatchInfo> {
        &mut self.watchable_match_infos
    }

    // Take field
    pub fn take_watchable_match_infos(&mut self) -> ::protobuf::RepeatedField<WatchableMatchInfo> {
        ::std::mem::replace(&mut self.watchable_match_infos, ::protobuf::RepeatedField::new())
    }

    // optional uint32 extended_timeout = 5;


    pub fn get_extended_timeout(&self) -> u32 {
        self.extended_timeout.unwrap_or(0)
    }
    pub fn clear_extended_timeout(&mut self) {
        self.extended_timeout = ::std::option::Option::None;
    }

    pub fn has_extended_timeout(&self) -> bool {
        self.extended_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extended_timeout(&mut self, v: u32) {
        self.extended_timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn is_initialized(&self) -> bool {
        for v in &self.watchable_match_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.watchable_match_infos)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extended_timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.watchable_match_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.extended_timeout {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.watchable_match_infos {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.extended_timeout {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_WatchInfoUsers {
        CMsgGCCStrike15_v2_WatchInfoUsers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.request_id },
                    |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.account_ids },
                    |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.account_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WatchableMatchInfo>>(
                    "watchable_match_infos",
                    |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.watchable_match_infos },
                    |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.watchable_match_infos },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "extended_timeout",
                    |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.extended_timeout },
                    |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.extended_timeout },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_WatchInfoUsers>(
                    "CMsgGCCStrike15_v2_WatchInfoUsers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_WatchInfoUsers {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_WatchInfoUsers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_WatchInfoUsers,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_WatchInfoUsers::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.watchable_match_infos.clear();
        self.extended_timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    // message fields
    request_id__deprecated: ::std::option::Option<u32>,
    account_ids__deprecated: ::std::vec::Vec<u32>,
    account_id: ::std::option::Option<u32>,
    request_level: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        <CMsgGCCStrike15_v2_ClientRequestPlayersProfile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        ::std::default::Default::default()
    }

    // optional uint32 request_id__deprecated = 1;


    pub fn get_request_id__deprecated(&self) -> u32 {
        self.request_id__deprecated.unwrap_or(0)
    }
    pub fn clear_request_id__deprecated(&mut self) {
        self.request_id__deprecated = ::std::option::Option::None;
    }

    pub fn has_request_id__deprecated(&self) -> bool {
        self.request_id__deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id__deprecated(&mut self, v: u32) {
        self.request_id__deprecated = ::std::option::Option::Some(v);
    }

    // repeated uint32 account_ids__deprecated = 2;


    pub fn get_account_ids__deprecated(&self) -> &[u32] {
        &self.account_ids__deprecated
    }
    pub fn clear_account_ids__deprecated(&mut self) {
        self.account_ids__deprecated.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids__deprecated(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids__deprecated = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids__deprecated(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids__deprecated
    }

    // Take field
    pub fn take_account_ids__deprecated(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids__deprecated, ::std::vec::Vec::new())
    }

    // optional uint32 account_id = 3;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 request_level = 4;


    pub fn get_request_level(&self) -> u32 {
        self.request_level.unwrap_or(0)
    }
    pub fn clear_request_level(&mut self) {
        self.request_level = ::std::option::Option::None;
    }

    pub fn has_request_level(&self) -> bool {
        self.request_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_level(&mut self, v: u32) {
        self.request_level = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id__deprecated = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids__deprecated)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id__deprecated {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_ids__deprecated {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id__deprecated {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids__deprecated {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.request_level {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        CMsgGCCStrike15_v2_ClientRequestPlayersProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id__deprecated",
                    |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.request_id__deprecated },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.request_id__deprecated },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids__deprecated",
                    |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.account_ids__deprecated },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.account_ids__deprecated },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_level",
                    |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.request_level },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.request_level },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientRequestPlayersProfile>(
                    "CMsgGCCStrike15_v2_ClientRequestPlayersProfile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientRequestPlayersProfile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientRequestPlayersProfile,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientRequestPlayersProfile::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn clear(&mut self) {
        self.request_id__deprecated = ::std::option::Option::None;
        self.account_ids__deprecated.clear();
        self.account_id = ::std::option::Option::None;
        self.request_level = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_PlayersProfile {
    // message fields
    request_id: ::std::option::Option<u32>,
    account_profiles: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayersProfile {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayersProfile {
        <CMsgGCCStrike15_v2_PlayersProfile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayersProfile {
    pub fn new() -> CMsgGCCStrike15_v2_PlayersProfile {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgGCCStrike15_v2_MatchmakingGC2ClientHello account_profiles = 2;


    pub fn get_account_profiles(&self) -> &[CMsgGCCStrike15_v2_MatchmakingGC2ClientHello] {
        &self.account_profiles
    }
    pub fn clear_account_profiles(&mut self) {
        self.account_profiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_profiles(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>) {
        self.account_profiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_profiles(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello> {
        &mut self.account_profiles
    }

    // Take field
    pub fn take_account_profiles(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello> {
        ::std::mem::replace(&mut self.account_profiles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayersProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.account_profiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.account_profiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_profiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_profiles {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_PlayersProfile {
        CMsgGCCStrike15_v2_PlayersProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    |m: &CMsgGCCStrike15_v2_PlayersProfile| { &m.request_id },
                    |m: &mut CMsgGCCStrike15_v2_PlayersProfile| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>>(
                    "account_profiles",
                    |m: &CMsgGCCStrike15_v2_PlayersProfile| { &m.account_profiles },
                    |m: &mut CMsgGCCStrike15_v2_PlayersProfile| { &mut m.account_profiles },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_PlayersProfile>(
                    "CMsgGCCStrike15_v2_PlayersProfile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayersProfile {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_PlayersProfile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_PlayersProfile,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_PlayersProfile::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_PlayersProfile {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.account_profiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_PlayersProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayersProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    // message fields
    caseid: ::std::option::Option<u64>,
    suspectid: ::std::option::Option<u32>,
    fractionid: ::std::option::Option<u32>,
    rpt_aimbot: ::std::option::Option<u32>,
    rpt_wallhack: ::std::option::Option<u32>,
    rpt_speedhack: ::std::option::Option<u32>,
    rpt_teamharm: ::std::option::Option<u32>,
    reason: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        <CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        ::std::default::Default::default()
    }

    // optional uint64 caseid = 1;


    pub fn get_caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }
    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    // optional uint32 suspectid = 3;


    pub fn get_suspectid(&self) -> u32 {
        self.suspectid.unwrap_or(0)
    }
    pub fn clear_suspectid(&mut self) {
        self.suspectid = ::std::option::Option::None;
    }

    pub fn has_suspectid(&self) -> bool {
        self.suspectid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suspectid(&mut self, v: u32) {
        self.suspectid = ::std::option::Option::Some(v);
    }

    // optional uint32 fractionid = 4;


    pub fn get_fractionid(&self) -> u32 {
        self.fractionid.unwrap_or(0)
    }
    pub fn clear_fractionid(&mut self) {
        self.fractionid = ::std::option::Option::None;
    }

    pub fn has_fractionid(&self) -> bool {
        self.fractionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionid(&mut self, v: u32) {
        self.fractionid = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_aimbot = 5;


    pub fn get_rpt_aimbot(&self) -> u32 {
        self.rpt_aimbot.unwrap_or(0)
    }
    pub fn clear_rpt_aimbot(&mut self) {
        self.rpt_aimbot = ::std::option::Option::None;
    }

    pub fn has_rpt_aimbot(&self) -> bool {
        self.rpt_aimbot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_aimbot(&mut self, v: u32) {
        self.rpt_aimbot = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_wallhack = 6;


    pub fn get_rpt_wallhack(&self) -> u32 {
        self.rpt_wallhack.unwrap_or(0)
    }
    pub fn clear_rpt_wallhack(&mut self) {
        self.rpt_wallhack = ::std::option::Option::None;
    }

    pub fn has_rpt_wallhack(&self) -> bool {
        self.rpt_wallhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_wallhack(&mut self, v: u32) {
        self.rpt_wallhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_speedhack = 7;


    pub fn get_rpt_speedhack(&self) -> u32 {
        self.rpt_speedhack.unwrap_or(0)
    }
    pub fn clear_rpt_speedhack(&mut self) {
        self.rpt_speedhack = ::std::option::Option::None;
    }

    pub fn has_rpt_speedhack(&self) -> bool {
        self.rpt_speedhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_speedhack(&mut self, v: u32) {
        self.rpt_speedhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_teamharm = 8;


    pub fn get_rpt_teamharm(&self) -> u32 {
        self.rpt_teamharm.unwrap_or(0)
    }
    pub fn clear_rpt_teamharm(&mut self) {
        self.rpt_teamharm = ::std::option::Option::None;
    }

    pub fn has_rpt_teamharm(&self) -> bool {
        self.rpt_teamharm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_teamharm(&mut self, v: u32) {
        self.rpt_teamharm = ::std::option::Option::Some(v);
    }

    // optional uint32 reason = 9;


    pub fn get_reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.caseid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.suspectid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fractionid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_aimbot = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_wallhack = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_speedhack = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rpt_teamharm = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.suspectid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fractionid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_aimbot {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_wallhack {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_speedhack {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rpt_teamharm {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.suspectid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.fractionid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_aimbot {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rpt_wallhack {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rpt_speedhack {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.rpt_teamharm {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "caseid",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.caseid },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.caseid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "suspectid",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.suspectid },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.suspectid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fractionid",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.fractionid },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.fractionid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_aimbot",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_aimbot },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_aimbot },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_wallhack",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_wallhack },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_wallhack },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_speedhack",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_speedhack },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_speedhack },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rpt_teamharm",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_teamharm },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_teamharm },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reason",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.reason },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate>(
                    "CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn clear(&mut self) {
        self.caseid = ::std::option::Option::None;
        self.suspectid = ::std::option::Option::None;
        self.fractionid = ::std::option::Option::None;
        self.rpt_aimbot = ::std::option::Option::None;
        self.rpt_wallhack = ::std::option::Option::None;
        self.rpt_speedhack = ::std::option::Option::None;
        self.rpt_teamharm = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    // message fields
    caseid: ::std::option::Option<u64>,
    caseurl: ::protobuf::SingularField<::std::string::String>,
    verdict: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    throttleseconds: ::std::option::Option<u32>,
    suspectid: ::std::option::Option<u32>,
    fractionid: ::std::option::Option<u32>,
    numrounds: ::std::option::Option<u32>,
    fractionrounds: ::std::option::Option<u32>,
    streakconvictions: ::std::option::Option<i32>,
    reason: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        <CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        ::std::default::Default::default()
    }

    // optional uint64 caseid = 1;


    pub fn get_caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }
    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    // optional string caseurl = 2;


    pub fn get_caseurl(&self) -> &str {
        match self.caseurl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caseurl(&mut self) {
        self.caseurl.clear();
    }

    pub fn has_caseurl(&self) -> bool {
        self.caseurl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseurl(&mut self, v: ::std::string::String) {
        self.caseurl = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caseurl(&mut self) -> &mut ::std::string::String {
        if self.caseurl.is_none() {
            self.caseurl.set_default();
        }
        self.caseurl.as_mut().unwrap()
    }

    // Take field
    pub fn take_caseurl(&mut self) -> ::std::string::String {
        self.caseurl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 verdict = 3;


    pub fn get_verdict(&self) -> u32 {
        self.verdict.unwrap_or(0)
    }
    pub fn clear_verdict(&mut self) {
        self.verdict = ::std::option::Option::None;
    }

    pub fn has_verdict(&self) -> bool {
        self.verdict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verdict(&mut self, v: u32) {
        self.verdict = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 4;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 throttleseconds = 5;


    pub fn get_throttleseconds(&self) -> u32 {
        self.throttleseconds.unwrap_or(0)
    }
    pub fn clear_throttleseconds(&mut self) {
        self.throttleseconds = ::std::option::Option::None;
    }

    pub fn has_throttleseconds(&self) -> bool {
        self.throttleseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttleseconds(&mut self, v: u32) {
        self.throttleseconds = ::std::option::Option::Some(v);
    }

    // optional uint32 suspectid = 6;


    pub fn get_suspectid(&self) -> u32 {
        self.suspectid.unwrap_or(0)
    }
    pub fn clear_suspectid(&mut self) {
        self.suspectid = ::std::option::Option::None;
    }

    pub fn has_suspectid(&self) -> bool {
        self.suspectid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suspectid(&mut self, v: u32) {
        self.suspectid = ::std::option::Option::Some(v);
    }

    // optional uint32 fractionid = 7;


    pub fn get_fractionid(&self) -> u32 {
        self.fractionid.unwrap_or(0)
    }
    pub fn clear_fractionid(&mut self) {
        self.fractionid = ::std::option::Option::None;
    }

    pub fn has_fractionid(&self) -> bool {
        self.fractionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionid(&mut self, v: u32) {
        self.fractionid = ::std::option::Option::Some(v);
    }

    // optional uint32 numrounds = 8;


    pub fn get_numrounds(&self) -> u32 {
        self.numrounds.unwrap_or(0)
    }
    pub fn clear_numrounds(&mut self) {
        self.numrounds = ::std::option::Option::None;
    }

    pub fn has_numrounds(&self) -> bool {
        self.numrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numrounds(&mut self, v: u32) {
        self.numrounds = ::std::option::Option::Some(v);
    }

    // optional uint32 fractionrounds = 9;


    pub fn get_fractionrounds(&self) -> u32 {
        self.fractionrounds.unwrap_or(0)
    }
    pub fn clear_fractionrounds(&mut self) {
        self.fractionrounds = ::std::option::Option::None;
    }

    pub fn has_fractionrounds(&self) -> bool {
        self.fractionrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionrounds(&mut self, v: u32) {
        self.fractionrounds = ::std::option::Option::Some(v);
    }

    // optional int32 streakconvictions = 10;


    pub fn get_streakconvictions(&self) -> i32 {
        self.streakconvictions.unwrap_or(0)
    }
    pub fn clear_streakconvictions(&mut self) {
        self.streakconvictions = ::std::option::Option::None;
    }

    pub fn has_streakconvictions(&self) -> bool {
        self.streakconvictions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streakconvictions(&mut self, v: i32) {
        self.streakconvictions = ::std::option::Option::Some(v);
    }

    // optional uint32 reason = 11;


    pub fn get_reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.caseid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caseurl)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.verdict = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.throttleseconds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.suspectid = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fractionid = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numrounds = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fractionrounds = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.streakconvictions = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.caseurl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.verdict {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.throttleseconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.suspectid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fractionid {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numrounds {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fractionrounds {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.streakconvictions {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.caseurl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.verdict {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.throttleseconds {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.suspectid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.fractionid {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.numrounds {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.fractionrounds {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.streakconvictions {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "caseid",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.caseid },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.caseid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "caseurl",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.caseurl },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.caseurl },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "verdict",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.verdict },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.verdict },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.timestamp },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "throttleseconds",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.throttleseconds },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.throttleseconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "suspectid",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.suspectid },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.suspectid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fractionid",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.fractionid },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.fractionid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "numrounds",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.numrounds },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.numrounds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fractionrounds",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.fractionrounds },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.fractionrounds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "streakconvictions",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.streakconvictions },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.streakconvictions },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reason",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.reason },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment>(
                    "CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn clear(&mut self) {
        self.caseid = ::std::option::Option::None;
        self.caseurl.clear();
        self.verdict = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.throttleseconds = ::std::option::Option::None;
        self.suspectid = ::std::option::Option::None;
        self.fractionid = ::std::option::Option::None;
        self.numrounds = ::std::option::Option::None;
        self.fractionrounds = ::std::option::Option::None;
        self.streakconvictions = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    // message fields
    caseid: ::std::option::Option<u64>,
    statusid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        <CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        ::std::default::Default::default()
    }

    // optional uint64 caseid = 1;


    pub fn get_caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }
    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    // optional uint32 statusid = 2;


    pub fn get_statusid(&self) -> u32 {
        self.statusid.unwrap_or(0)
    }
    pub fn clear_statusid(&mut self) {
        self.statusid = ::std::option::Option::None;
    }

    pub fn has_statusid(&self) -> bool {
        self.statusid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusid(&mut self, v: u32) {
        self.statusid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.caseid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.statusid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.statusid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.statusid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "caseid",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &m.caseid },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &mut m.caseid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "statusid",
                    |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &m.statusid },
                    |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &mut m.statusid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus>(
                    "CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn clear(&mut self) {
        self.caseid = ::std::option::Option::None;
        self.statusid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CClientHeaderOverwatchEvidence {
    // message fields
    accountid: ::std::option::Option<u32>,
    caseid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientHeaderOverwatchEvidence {
    fn default() -> &'a CClientHeaderOverwatchEvidence {
        <CClientHeaderOverwatchEvidence as ::protobuf::Message>::default_instance()
    }
}

impl CClientHeaderOverwatchEvidence {
    pub fn new() -> CClientHeaderOverwatchEvidence {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 caseid = 2;


    pub fn get_caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }
    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientHeaderOverwatchEvidence {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.caseid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.caseid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientHeaderOverwatchEvidence {
        CClientHeaderOverwatchEvidence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CClientHeaderOverwatchEvidence| { &m.accountid },
                    |m: &mut CClientHeaderOverwatchEvidence| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "caseid",
                    |m: &CClientHeaderOverwatchEvidence| { &m.caseid },
                    |m: &mut CClientHeaderOverwatchEvidence| { &mut m.caseid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClientHeaderOverwatchEvidence>(
                    "CClientHeaderOverwatchEvidence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CClientHeaderOverwatchEvidence {
        static mut instance: ::protobuf::lazy::Lazy<CClientHeaderOverwatchEvidence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClientHeaderOverwatchEvidence,
        };
        unsafe {
            instance.get(CClientHeaderOverwatchEvidence::new)
        }
    }
}

impl ::protobuf::Clear for CClientHeaderOverwatchEvidence {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.caseid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientHeaderOverwatchEvidence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientHeaderOverwatchEvidence {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GC2ClientTextMsg {
    // message fields
    id: ::std::option::Option<u32>,
    field_type: ::std::option::Option<u32>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ClientTextMsg {
        <CMsgGCCStrike15_v2_GC2ClientTextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ClientTextMsg {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 2;


    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ClientTextMsg {
        CMsgGCCStrike15_v2_GC2ClientTextMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    |m: &CMsgGCCStrike15_v2_GC2ClientTextMsg| { &m.id },
                    |m: &mut CMsgGCCStrike15_v2_GC2ClientTextMsg| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &CMsgGCCStrike15_v2_GC2ClientTextMsg| { &m.field_type },
                    |m: &mut CMsgGCCStrike15_v2_GC2ClientTextMsg| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &CMsgGCCStrike15_v2_GC2ClientTextMsg| { &m.payload },
                    |m: &mut CMsgGCCStrike15_v2_GC2ClientTextMsg| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GC2ClientTextMsg>(
                    "CMsgGCCStrike15_v2_GC2ClientTextMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientTextMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GC2ClientTextMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GC2ClientTextMsg,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GC2ClientTextMsg::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Client2GCTextMsg {
    // message fields
    id: ::std::option::Option<u32>,
    args: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCTextMsg {
        <CMsgGCCStrike15_v2_Client2GCTextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCTextMsg {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // repeated bytes args = 2;


    pub fn get_args(&self) -> &[::std::vec::Vec<u8>] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.args {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        for v in &self.args {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCTextMsg {
        CMsgGCCStrike15_v2_Client2GCTextMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    |m: &CMsgGCCStrike15_v2_Client2GCTextMsg| { &m.id },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCTextMsg| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "args",
                    |m: &CMsgGCCStrike15_v2_Client2GCTextMsg| { &m.args },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCTextMsg| { &mut m.args },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Client2GCTextMsg>(
                    "CMsgGCCStrike15_v2_Client2GCTextMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCTextMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Client2GCTextMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Client2GCTextMsg,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Client2GCTextMsg::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    // message fields
    serverinfo: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>,
    match_end_quest_data: ::protobuf::SingularPtrField<CMsgGC_ServerQuestUpdateData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        <CMsgGCCStrike15_v2_MatchEndRunRewardDrops as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    pub fn new() -> CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        ::std::default::Default::default()
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingServerReservationResponse serverinfo = 3;


    pub fn get_serverinfo(&self) -> &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        self.serverinfo.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::default_instance())
    }
    pub fn clear_serverinfo(&mut self) {
        self.serverinfo.clear();
    }

    pub fn has_serverinfo(&self) -> bool {
        self.serverinfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverinfo(&mut self, v: CMsgGCCStrike15_v2_MatchmakingServerReservationResponse) {
        self.serverinfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverinfo(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        if self.serverinfo.is_none() {
            self.serverinfo.set_default();
        }
        self.serverinfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverinfo(&mut self) -> CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        self.serverinfo.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::new())
    }

    // optional .CMsgGC_ServerQuestUpdateData match_end_quest_data = 4;


    pub fn get_match_end_quest_data(&self) -> &CMsgGC_ServerQuestUpdateData {
        self.match_end_quest_data.as_ref().unwrap_or_else(|| CMsgGC_ServerQuestUpdateData::default_instance())
    }
    pub fn clear_match_end_quest_data(&mut self) {
        self.match_end_quest_data.clear();
    }

    pub fn has_match_end_quest_data(&self) -> bool {
        self.match_end_quest_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_end_quest_data(&mut self, v: CMsgGC_ServerQuestUpdateData) {
        self.match_end_quest_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_end_quest_data(&mut self) -> &mut CMsgGC_ServerQuestUpdateData {
        if self.match_end_quest_data.is_none() {
            self.match_end_quest_data.set_default();
        }
        self.match_end_quest_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_match_end_quest_data(&mut self) -> CMsgGC_ServerQuestUpdateData {
        self.match_end_quest_data.take().unwrap_or_else(|| CMsgGC_ServerQuestUpdateData::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn is_initialized(&self) -> bool {
        for v in &self.serverinfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.match_end_quest_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverinfo)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.match_end_quest_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.serverinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.match_end_quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.serverinfo.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.match_end_quest_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        CMsgGCCStrike15_v2_MatchEndRunRewardDrops::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>>(
                    "serverinfo",
                    |m: &CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &m.serverinfo },
                    |m: &mut CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &mut m.serverinfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGC_ServerQuestUpdateData>>(
                    "match_end_quest_data",
                    |m: &CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &m.match_end_quest_data },
                    |m: &mut CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &mut m.match_end_quest_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchEndRunRewardDrops>(
                    "CMsgGCCStrike15_v2_MatchEndRunRewardDrops",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchEndRunRewardDrops> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchEndRunRewardDrops,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchEndRunRewardDrops::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn clear(&mut self) {
        self.serverinfo.clear();
        self.match_end_quest_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CEconItemPreviewDataBlock {
    // message fields
    accountid: ::std::option::Option<u32>,
    itemid: ::std::option::Option<u64>,
    defindex: ::std::option::Option<u32>,
    paintindex: ::std::option::Option<u32>,
    rarity: ::std::option::Option<u32>,
    quality: ::std::option::Option<u32>,
    paintwear: ::std::option::Option<u32>,
    paintseed: ::std::option::Option<u32>,
    killeaterscoretype: ::std::option::Option<u32>,
    killeatervalue: ::std::option::Option<u32>,
    customname: ::protobuf::SingularField<::std::string::String>,
    stickers: ::protobuf::RepeatedField<CEconItemPreviewDataBlock_Sticker>,
    inventory: ::std::option::Option<u32>,
    origin: ::std::option::Option<u32>,
    questid: ::std::option::Option<u32>,
    dropreason: ::std::option::Option<u32>,
    musicindex: ::std::option::Option<u32>,
    entindex: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CEconItemPreviewDataBlock {
    fn default() -> &'a CEconItemPreviewDataBlock {
        <CEconItemPreviewDataBlock as ::protobuf::Message>::default_instance()
    }
}

impl CEconItemPreviewDataBlock {
    pub fn new() -> CEconItemPreviewDataBlock {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 itemid = 2;


    pub fn get_itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }
    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 3;


    pub fn get_defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }
    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 paintindex = 4;


    pub fn get_paintindex(&self) -> u32 {
        self.paintindex.unwrap_or(0)
    }
    pub fn clear_paintindex(&mut self) {
        self.paintindex = ::std::option::Option::None;
    }

    pub fn has_paintindex(&self) -> bool {
        self.paintindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintindex(&mut self, v: u32) {
        self.paintindex = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 5;


    pub fn get_rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }
    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 6;


    pub fn get_quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }
    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 paintwear = 7;


    pub fn get_paintwear(&self) -> u32 {
        self.paintwear.unwrap_or(0)
    }
    pub fn clear_paintwear(&mut self) {
        self.paintwear = ::std::option::Option::None;
    }

    pub fn has_paintwear(&self) -> bool {
        self.paintwear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintwear(&mut self, v: u32) {
        self.paintwear = ::std::option::Option::Some(v);
    }

    // optional uint32 paintseed = 8;


    pub fn get_paintseed(&self) -> u32 {
        self.paintseed.unwrap_or(0)
    }
    pub fn clear_paintseed(&mut self) {
        self.paintseed = ::std::option::Option::None;
    }

    pub fn has_paintseed(&self) -> bool {
        self.paintseed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintseed(&mut self, v: u32) {
        self.paintseed = ::std::option::Option::Some(v);
    }

    // optional uint32 killeaterscoretype = 9;


    pub fn get_killeaterscoretype(&self) -> u32 {
        self.killeaterscoretype.unwrap_or(0)
    }
    pub fn clear_killeaterscoretype(&mut self) {
        self.killeaterscoretype = ::std::option::Option::None;
    }

    pub fn has_killeaterscoretype(&self) -> bool {
        self.killeaterscoretype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killeaterscoretype(&mut self, v: u32) {
        self.killeaterscoretype = ::std::option::Option::Some(v);
    }

    // optional uint32 killeatervalue = 10;


    pub fn get_killeatervalue(&self) -> u32 {
        self.killeatervalue.unwrap_or(0)
    }
    pub fn clear_killeatervalue(&mut self) {
        self.killeatervalue = ::std::option::Option::None;
    }

    pub fn has_killeatervalue(&self) -> bool {
        self.killeatervalue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killeatervalue(&mut self, v: u32) {
        self.killeatervalue = ::std::option::Option::Some(v);
    }

    // optional string customname = 11;


    pub fn get_customname(&self) -> &str {
        match self.customname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_customname(&mut self) {
        self.customname.clear();
    }

    pub fn has_customname(&self) -> bool {
        self.customname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_customname(&mut self, v: ::std::string::String) {
        self.customname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_customname(&mut self) -> &mut ::std::string::String {
        if self.customname.is_none() {
            self.customname.set_default();
        }
        self.customname.as_mut().unwrap()
    }

    // Take field
    pub fn take_customname(&mut self) -> ::std::string::String {
        self.customname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CEconItemPreviewDataBlock.Sticker stickers = 12;


    pub fn get_stickers(&self) -> &[CEconItemPreviewDataBlock_Sticker] {
        &self.stickers
    }
    pub fn clear_stickers(&mut self) {
        self.stickers.clear();
    }

    // Param is passed by value, moved
    pub fn set_stickers(&mut self, v: ::protobuf::RepeatedField<CEconItemPreviewDataBlock_Sticker>) {
        self.stickers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stickers(&mut self) -> &mut ::protobuf::RepeatedField<CEconItemPreviewDataBlock_Sticker> {
        &mut self.stickers
    }

    // Take field
    pub fn take_stickers(&mut self) -> ::protobuf::RepeatedField<CEconItemPreviewDataBlock_Sticker> {
        ::std::mem::replace(&mut self.stickers, ::protobuf::RepeatedField::new())
    }

    // optional uint32 inventory = 13;


    pub fn get_inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }
    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 14;


    pub fn get_origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }
    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional uint32 questid = 15;


    pub fn get_questid(&self) -> u32 {
        self.questid.unwrap_or(0)
    }
    pub fn clear_questid(&mut self) {
        self.questid = ::std::option::Option::None;
    }

    pub fn has_questid(&self) -> bool {
        self.questid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_questid(&mut self, v: u32) {
        self.questid = ::std::option::Option::Some(v);
    }

    // optional uint32 dropreason = 16;


    pub fn get_dropreason(&self) -> u32 {
        self.dropreason.unwrap_or(0)
    }
    pub fn clear_dropreason(&mut self) {
        self.dropreason = ::std::option::Option::None;
    }

    pub fn has_dropreason(&self) -> bool {
        self.dropreason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dropreason(&mut self, v: u32) {
        self.dropreason = ::std::option::Option::Some(v);
    }

    // optional uint32 musicindex = 17;


    pub fn get_musicindex(&self) -> u32 {
        self.musicindex.unwrap_or(0)
    }
    pub fn clear_musicindex(&mut self) {
        self.musicindex = ::std::option::Option::None;
    }

    pub fn has_musicindex(&self) -> bool {
        self.musicindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_musicindex(&mut self, v: u32) {
        self.musicindex = ::std::option::Option::Some(v);
    }

    // optional int32 entindex = 18;


    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }
    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CEconItemPreviewDataBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.stickers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defindex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.paintindex = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rarity = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.paintwear = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.paintseed = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.killeaterscoretype = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.killeatervalue = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.customname)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stickers)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.inventory = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.origin = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.questid = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dropreason = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.musicindex = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.paintindex {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.paintwear {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.paintseed {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.killeaterscoretype {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.killeatervalue {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.customname.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.stickers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.questid {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dropreason {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.musicindex {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.itemid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.paintindex {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.paintwear {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.paintseed {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.killeaterscoretype {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.killeatervalue {
            os.write_uint32(10, v)?;
        }
        if let Some(ref v) = self.customname.as_ref() {
            os.write_string(11, &v)?;
        }
        for v in &self.stickers {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.inventory {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.questid {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.dropreason {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.musicindex {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(18, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CEconItemPreviewDataBlock {
        CEconItemPreviewDataBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CEconItemPreviewDataBlock| { &m.accountid },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "itemid",
                    |m: &CEconItemPreviewDataBlock| { &m.itemid },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.itemid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "defindex",
                    |m: &CEconItemPreviewDataBlock| { &m.defindex },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.defindex },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "paintindex",
                    |m: &CEconItemPreviewDataBlock| { &m.paintindex },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.paintindex },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rarity",
                    |m: &CEconItemPreviewDataBlock| { &m.rarity },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.rarity },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quality",
                    |m: &CEconItemPreviewDataBlock| { &m.quality },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.quality },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "paintwear",
                    |m: &CEconItemPreviewDataBlock| { &m.paintwear },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.paintwear },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "paintseed",
                    |m: &CEconItemPreviewDataBlock| { &m.paintseed },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.paintseed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "killeaterscoretype",
                    |m: &CEconItemPreviewDataBlock| { &m.killeaterscoretype },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.killeaterscoretype },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "killeatervalue",
                    |m: &CEconItemPreviewDataBlock| { &m.killeatervalue },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.killeatervalue },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "customname",
                    |m: &CEconItemPreviewDataBlock| { &m.customname },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.customname },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CEconItemPreviewDataBlock_Sticker>>(
                    "stickers",
                    |m: &CEconItemPreviewDataBlock| { &m.stickers },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.stickers },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "inventory",
                    |m: &CEconItemPreviewDataBlock| { &m.inventory },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.inventory },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "origin",
                    |m: &CEconItemPreviewDataBlock| { &m.origin },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.origin },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "questid",
                    |m: &CEconItemPreviewDataBlock| { &m.questid },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.questid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dropreason",
                    |m: &CEconItemPreviewDataBlock| { &m.dropreason },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.dropreason },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "musicindex",
                    |m: &CEconItemPreviewDataBlock| { &m.musicindex },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.musicindex },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entindex",
                    |m: &CEconItemPreviewDataBlock| { &m.entindex },
                    |m: &mut CEconItemPreviewDataBlock| { &mut m.entindex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CEconItemPreviewDataBlock>(
                    "CEconItemPreviewDataBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CEconItemPreviewDataBlock {
        static mut instance: ::protobuf::lazy::Lazy<CEconItemPreviewDataBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CEconItemPreviewDataBlock,
        };
        unsafe {
            instance.get(CEconItemPreviewDataBlock::new)
        }
    }
}

impl ::protobuf::Clear for CEconItemPreviewDataBlock {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.itemid = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.paintindex = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.paintwear = ::std::option::Option::None;
        self.paintseed = ::std::option::Option::None;
        self.killeaterscoretype = ::std::option::Option::None;
        self.killeatervalue = ::std::option::Option::None;
        self.customname.clear();
        self.stickers.clear();
        self.inventory = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.questid = ::std::option::Option::None;
        self.dropreason = ::std::option::Option::None;
        self.musicindex = ::std::option::Option::None;
        self.entindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CEconItemPreviewDataBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEconItemPreviewDataBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CEconItemPreviewDataBlock_Sticker {
    // message fields
    slot: ::std::option::Option<u32>,
    sticker_id: ::std::option::Option<u32>,
    wear: ::std::option::Option<f32>,
    scale: ::std::option::Option<f32>,
    rotation: ::std::option::Option<f32>,
    tint_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CEconItemPreviewDataBlock_Sticker {
    fn default() -> &'a CEconItemPreviewDataBlock_Sticker {
        <CEconItemPreviewDataBlock_Sticker as ::protobuf::Message>::default_instance()
    }
}

impl CEconItemPreviewDataBlock_Sticker {
    pub fn new() -> CEconItemPreviewDataBlock_Sticker {
        ::std::default::Default::default()
    }

    // optional uint32 slot = 1;


    pub fn get_slot(&self) -> u32 {
        self.slot.unwrap_or(0)
    }
    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: u32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional uint32 sticker_id = 2;


    pub fn get_sticker_id(&self) -> u32 {
        self.sticker_id.unwrap_or(0)
    }
    pub fn clear_sticker_id(&mut self) {
        self.sticker_id = ::std::option::Option::None;
    }

    pub fn has_sticker_id(&self) -> bool {
        self.sticker_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_id(&mut self, v: u32) {
        self.sticker_id = ::std::option::Option::Some(v);
    }

    // optional float wear = 3;


    pub fn get_wear(&self) -> f32 {
        self.wear.unwrap_or(0.)
    }
    pub fn clear_wear(&mut self) {
        self.wear = ::std::option::Option::None;
    }

    pub fn has_wear(&self) -> bool {
        self.wear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wear(&mut self, v: f32) {
        self.wear = ::std::option::Option::Some(v);
    }

    // optional float scale = 4;


    pub fn get_scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }
    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float rotation = 5;


    pub fn get_rotation(&self) -> f32 {
        self.rotation.unwrap_or(0.)
    }
    pub fn clear_rotation(&mut self) {
        self.rotation = ::std::option::Option::None;
    }

    pub fn has_rotation(&self) -> bool {
        self.rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation(&mut self, v: f32) {
        self.rotation = ::std::option::Option::Some(v);
    }

    // optional uint32 tint_id = 6;


    pub fn get_tint_id(&self) -> u32 {
        self.tint_id.unwrap_or(0)
    }
    pub fn clear_tint_id(&mut self) {
        self.tint_id = ::std::option::Option::None;
    }

    pub fn has_tint_id(&self) -> bool {
        self.tint_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tint_id(&mut self, v: u32) {
        self.tint_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CEconItemPreviewDataBlock_Sticker {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sticker_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.wear = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scale = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rotation = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tint_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sticker_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wear {
            my_size += 5;
        }
        if let Some(v) = self.scale {
            my_size += 5;
        }
        if let Some(v) = self.rotation {
            my_size += 5;
        }
        if let Some(v) = self.tint_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.slot {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sticker_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.wear {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.rotation {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.tint_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CEconItemPreviewDataBlock_Sticker {
        CEconItemPreviewDataBlock_Sticker::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot",
                    |m: &CEconItemPreviewDataBlock_Sticker| { &m.slot },
                    |m: &mut CEconItemPreviewDataBlock_Sticker| { &mut m.slot },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sticker_id",
                    |m: &CEconItemPreviewDataBlock_Sticker| { &m.sticker_id },
                    |m: &mut CEconItemPreviewDataBlock_Sticker| { &mut m.sticker_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "wear",
                    |m: &CEconItemPreviewDataBlock_Sticker| { &m.wear },
                    |m: &mut CEconItemPreviewDataBlock_Sticker| { &mut m.wear },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scale",
                    |m: &CEconItemPreviewDataBlock_Sticker| { &m.scale },
                    |m: &mut CEconItemPreviewDataBlock_Sticker| { &mut m.scale },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rotation",
                    |m: &CEconItemPreviewDataBlock_Sticker| { &m.rotation },
                    |m: &mut CEconItemPreviewDataBlock_Sticker| { &mut m.rotation },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tint_id",
                    |m: &CEconItemPreviewDataBlock_Sticker| { &m.tint_id },
                    |m: &mut CEconItemPreviewDataBlock_Sticker| { &mut m.tint_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CEconItemPreviewDataBlock_Sticker>(
                    "CEconItemPreviewDataBlock_Sticker",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CEconItemPreviewDataBlock_Sticker {
        static mut instance: ::protobuf::lazy::Lazy<CEconItemPreviewDataBlock_Sticker> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CEconItemPreviewDataBlock_Sticker,
        };
        unsafe {
            instance.get(CEconItemPreviewDataBlock_Sticker::new)
        }
    }
}

impl ::protobuf::Clear for CEconItemPreviewDataBlock_Sticker {
    fn clear(&mut self) {
        self.slot = ::std::option::Option::None;
        self.sticker_id = ::std::option::Option::None;
        self.wear = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.rotation = ::std::option::Option::None;
        self.tint_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CEconItemPreviewDataBlock_Sticker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEconItemPreviewDataBlock_Sticker {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    // message fields
    iteminfo: ::protobuf::SingularPtrField<CEconItemPreviewDataBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        <CMsgGCCStrike15_v2_MatchEndRewardDropsNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    pub fn new() -> CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        ::std::default::Default::default()
    }

    // optional .CEconItemPreviewDataBlock iteminfo = 6;


    pub fn get_iteminfo(&self) -> &CEconItemPreviewDataBlock {
        self.iteminfo.as_ref().unwrap_or_else(|| CEconItemPreviewDataBlock::default_instance())
    }
    pub fn clear_iteminfo(&mut self) {
        self.iteminfo.clear();
    }

    pub fn has_iteminfo(&self) -> bool {
        self.iteminfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteminfo(&mut self, v: CEconItemPreviewDataBlock) {
        self.iteminfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iteminfo(&mut self) -> &mut CEconItemPreviewDataBlock {
        if self.iteminfo.is_none() {
            self.iteminfo.set_default();
        }
        self.iteminfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_iteminfo(&mut self) -> CEconItemPreviewDataBlock {
        self.iteminfo.take().unwrap_or_else(|| CEconItemPreviewDataBlock::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn is_initialized(&self) -> bool {
        for v in &self.iteminfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iteminfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iteminfo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        CMsgGCCStrike15_v2_MatchEndRewardDropsNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CEconItemPreviewDataBlock>>(
                    "iteminfo",
                    |m: &CMsgGCCStrike15_v2_MatchEndRewardDropsNotification| { &m.iteminfo },
                    |m: &mut CMsgGCCStrike15_v2_MatchEndRewardDropsNotification| { &mut m.iteminfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchEndRewardDropsNotification>(
                    "CMsgGCCStrike15_v2_MatchEndRewardDropsNotification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchEndRewardDropsNotification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchEndRewardDropsNotification,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchEndRewardDropsNotification::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn clear(&mut self) {
        self.iteminfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgItemAcknowledged {
    // message fields
    iteminfo: ::protobuf::SingularPtrField<CEconItemPreviewDataBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgItemAcknowledged {
    fn default() -> &'a CMsgItemAcknowledged {
        <CMsgItemAcknowledged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAcknowledged {
    pub fn new() -> CMsgItemAcknowledged {
        ::std::default::Default::default()
    }

    // optional .CEconItemPreviewDataBlock iteminfo = 1;


    pub fn get_iteminfo(&self) -> &CEconItemPreviewDataBlock {
        self.iteminfo.as_ref().unwrap_or_else(|| CEconItemPreviewDataBlock::default_instance())
    }
    pub fn clear_iteminfo(&mut self) {
        self.iteminfo.clear();
    }

    pub fn has_iteminfo(&self) -> bool {
        self.iteminfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteminfo(&mut self, v: CEconItemPreviewDataBlock) {
        self.iteminfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iteminfo(&mut self) -> &mut CEconItemPreviewDataBlock {
        if self.iteminfo.is_none() {
            self.iteminfo.set_default();
        }
        self.iteminfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_iteminfo(&mut self) -> CEconItemPreviewDataBlock {
        self.iteminfo.take().unwrap_or_else(|| CEconItemPreviewDataBlock::new())
    }
}

impl ::protobuf::Message for CMsgItemAcknowledged {
    fn is_initialized(&self) -> bool {
        for v in &self.iteminfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iteminfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iteminfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgItemAcknowledged {
        CMsgItemAcknowledged::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CEconItemPreviewDataBlock>>(
                    "iteminfo",
                    |m: &CMsgItemAcknowledged| { &m.iteminfo },
                    |m: &mut CMsgItemAcknowledged| { &mut m.iteminfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgItemAcknowledged>(
                    "CMsgItemAcknowledged",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgItemAcknowledged {
        static mut instance: ::protobuf::lazy::Lazy<CMsgItemAcknowledged> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgItemAcknowledged,
        };
        unsafe {
            instance.get(CMsgItemAcknowledged::new)
        }
    }
}

impl ::protobuf::Clear for CMsgItemAcknowledged {
    fn clear(&mut self) {
        self.iteminfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgItemAcknowledged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAcknowledged {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    // message fields
    param_s: ::std::option::Option<u64>,
    param_a: ::std::option::Option<u64>,
    param_d: ::std::option::Option<u64>,
    param_m: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        <CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        ::std::default::Default::default()
    }

    // optional uint64 param_s = 1;


    pub fn get_param_s(&self) -> u64 {
        self.param_s.unwrap_or(0)
    }
    pub fn clear_param_s(&mut self) {
        self.param_s = ::std::option::Option::None;
    }

    pub fn has_param_s(&self) -> bool {
        self.param_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_s(&mut self, v: u64) {
        self.param_s = ::std::option::Option::Some(v);
    }

    // optional uint64 param_a = 2;


    pub fn get_param_a(&self) -> u64 {
        self.param_a.unwrap_or(0)
    }
    pub fn clear_param_a(&mut self) {
        self.param_a = ::std::option::Option::None;
    }

    pub fn has_param_a(&self) -> bool {
        self.param_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_a(&mut self, v: u64) {
        self.param_a = ::std::option::Option::Some(v);
    }

    // optional uint64 param_d = 3;


    pub fn get_param_d(&self) -> u64 {
        self.param_d.unwrap_or(0)
    }
    pub fn clear_param_d(&mut self) {
        self.param_d = ::std::option::Option::None;
    }

    pub fn has_param_d(&self) -> bool {
        self.param_d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_d(&mut self, v: u64) {
        self.param_d = ::std::option::Option::Some(v);
    }

    // optional uint64 param_m = 4;


    pub fn get_param_m(&self) -> u64 {
        self.param_m.unwrap_or(0)
    }
    pub fn clear_param_m(&mut self) {
        self.param_m = ::std::option::Option::None;
    }

    pub fn has_param_m(&self) -> bool {
        self.param_m.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_m(&mut self, v: u64) {
        self.param_m = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_s = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_a = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_d = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_m = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.param_s {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.param_a {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.param_d {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.param_m {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.param_s {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.param_a {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.param_d {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.param_m {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "param_s",
                    |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_s },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "param_a",
                    |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_a },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_a },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "param_d",
                    |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_d },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_d },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "param_m",
                    |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_m },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_m },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest>(
                    "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn clear(&mut self) {
        self.param_s = ::std::option::Option::None;
        self.param_a = ::std::option::Option::None;
        self.param_d = ::std::option::Option::None;
        self.param_m = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    // message fields
    iteminfo: ::protobuf::SingularPtrField<CEconItemPreviewDataBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        <CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        ::std::default::Default::default()
    }

    // optional .CEconItemPreviewDataBlock iteminfo = 1;


    pub fn get_iteminfo(&self) -> &CEconItemPreviewDataBlock {
        self.iteminfo.as_ref().unwrap_or_else(|| CEconItemPreviewDataBlock::default_instance())
    }
    pub fn clear_iteminfo(&mut self) {
        self.iteminfo.clear();
    }

    pub fn has_iteminfo(&self) -> bool {
        self.iteminfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteminfo(&mut self, v: CEconItemPreviewDataBlock) {
        self.iteminfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iteminfo(&mut self) -> &mut CEconItemPreviewDataBlock {
        if self.iteminfo.is_none() {
            self.iteminfo.set_default();
        }
        self.iteminfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_iteminfo(&mut self) -> CEconItemPreviewDataBlock {
        self.iteminfo.take().unwrap_or_else(|| CEconItemPreviewDataBlock::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.iteminfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iteminfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iteminfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CEconItemPreviewDataBlock>>(
                    "iteminfo",
                    |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse| { &m.iteminfo },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse| { &mut m.iteminfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse>(
                    "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn clear(&mut self) {
        self.iteminfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    // message fields
    match_id: ::std::option::Option<u64>,
    defindex: ::std::option::Option<u32>,
    accountids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn default() -> &'a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        <CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    pub fn new() -> CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 2;


    pub fn get_defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }
    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // repeated uint32 accountids = 3;


    pub fn get_accountids(&self) -> &[u32] {
        &self.accountids
    }
    pub fn clear_accountids(&mut self) {
        self.accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountids(&mut self, v: ::std::vec::Vec<u32>) {
        self.accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accountids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.accountids
    }

    // Take field
    pub fn take_accountids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.accountids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defindex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.accountids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.accountids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(2, v)?;
        }
        for v in &self.accountids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    |m: &CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &m.match_id },
                    |m: &mut CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &mut m.match_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "defindex",
                    |m: &CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &m.defindex },
                    |m: &mut CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &mut m.defindex },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountids",
                    |m: &CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &m.accountids },
                    |m: &mut CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &mut m.accountids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification>(
                    "CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.accountids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        <CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames>(
                    "CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    // message fields
    accountid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        <CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser| { &mut m.accountid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser>(
                    "CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    // message fields
    accountid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        <CMsgGCCStrike15_v2_MatchListRequestRecentUserGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        CMsgGCCStrike15_v2_MatchListRequestRecentUserGames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_MatchListRequestRecentUserGames| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_MatchListRequestRecentUserGames| { &mut m.accountid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchListRequestRecentUserGames>(
                    "CMsgGCCStrike15_v2_MatchListRequestRecentUserGames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchListRequestRecentUserGames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchListRequestRecentUserGames,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchListRequestRecentUserGames::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    // message fields
    eventid: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        <CMsgGCCStrike15_v2_MatchListRequestTournamentGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        ::std::default::Default::default()
    }

    // optional int32 eventid = 1;


    pub fn get_eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }
    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eventid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventid {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        CMsgGCCStrike15_v2_MatchListRequestTournamentGames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "eventid",
                    |m: &CMsgGCCStrike15_v2_MatchListRequestTournamentGames| { &m.eventid },
                    |m: &mut CMsgGCCStrike15_v2_MatchListRequestTournamentGames| { &mut m.eventid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchListRequestTournamentGames>(
                    "CMsgGCCStrike15_v2_MatchListRequestTournamentGames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchListRequestTournamentGames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchListRequestTournamentGames,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchListRequestTournamentGames::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    // message fields
    matchid: ::std::option::Option<u64>,
    outcomeid: ::std::option::Option<u64>,
    token: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        <CMsgGCCStrike15_v2_MatchListRequestFullGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        ::std::default::Default::default()
    }

    // optional uint64 matchid = 1;


    pub fn get_matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }
    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    // optional uint64 outcomeid = 2;


    pub fn get_outcomeid(&self) -> u64 {
        self.outcomeid.unwrap_or(0)
    }
    pub fn clear_outcomeid(&mut self) {
        self.outcomeid = ::std::option::Option::None;
    }

    pub fn has_outcomeid(&self) -> bool {
        self.outcomeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outcomeid(&mut self, v: u64) {
        self.outcomeid = ::std::option::Option::Some(v);
    }

    // optional uint32 token = 3;


    pub fn get_token(&self) -> u32 {
        self.token.unwrap_or(0)
    }
    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.matchid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outcomeid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.outcomeid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.matchid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.outcomeid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.token {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "matchid",
                    |m: &CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &m.matchid },
                    |m: &mut CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &mut m.matchid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "outcomeid",
                    |m: &CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &m.outcomeid },
                    |m: &mut CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &mut m.outcomeid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "token",
                    |m: &CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &m.token },
                    |m: &mut CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &mut m.token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchListRequestFullGameInfo>(
                    "CMsgGCCStrike15_v2_MatchListRequestFullGameInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchListRequestFullGameInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchListRequestFullGameInfo,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn clear(&mut self) {
        self.matchid = ::std::option::Option::None;
        self.outcomeid = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_MatchInfo {
    // message fields
    matchid: ::std::option::Option<u64>,
    matchtime: ::std::option::Option<u32>,
    watchablematchinfo: ::protobuf::SingularPtrField<WatchableMatchInfo>,
    roundstats_legacy: ::protobuf::SingularPtrField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    roundstatsall: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_MatchInfo {
    fn default() -> &'a CDataGCCStrike15_v2_MatchInfo {
        <CDataGCCStrike15_v2_MatchInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_MatchInfo {
    pub fn new() -> CDataGCCStrike15_v2_MatchInfo {
        ::std::default::Default::default()
    }

    // optional uint64 matchid = 1;


    pub fn get_matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }
    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    // optional uint32 matchtime = 2;


    pub fn get_matchtime(&self) -> u32 {
        self.matchtime.unwrap_or(0)
    }
    pub fn clear_matchtime(&mut self) {
        self.matchtime = ::std::option::Option::None;
    }

    pub fn has_matchtime(&self) -> bool {
        self.matchtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchtime(&mut self, v: u32) {
        self.matchtime = ::std::option::Option::Some(v);
    }

    // optional .WatchableMatchInfo watchablematchinfo = 3;


    pub fn get_watchablematchinfo(&self) -> &WatchableMatchInfo {
        self.watchablematchinfo.as_ref().unwrap_or_else(|| WatchableMatchInfo::default_instance())
    }
    pub fn clear_watchablematchinfo(&mut self) {
        self.watchablematchinfo.clear();
    }

    pub fn has_watchablematchinfo(&self) -> bool {
        self.watchablematchinfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watchablematchinfo(&mut self, v: WatchableMatchInfo) {
        self.watchablematchinfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_watchablematchinfo(&mut self) -> &mut WatchableMatchInfo {
        if self.watchablematchinfo.is_none() {
            self.watchablematchinfo.set_default();
        }
        self.watchablematchinfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_watchablematchinfo(&mut self) -> WatchableMatchInfo {
        self.watchablematchinfo.take().unwrap_or_else(|| WatchableMatchInfo::new())
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundstats_legacy = 4;


    pub fn get_roundstats_legacy(&self) -> &CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        self.roundstats_legacy.as_ref().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats::default_instance())
    }
    pub fn clear_roundstats_legacy(&mut self) {
        self.roundstats_legacy.clear();
    }

    pub fn has_roundstats_legacy(&self) -> bool {
        self.roundstats_legacy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roundstats_legacy(&mut self, v: CMsgGCCStrike15_v2_MatchmakingServerRoundStats) {
        self.roundstats_legacy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_roundstats_legacy(&mut self) -> &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        if self.roundstats_legacy.is_none() {
            self.roundstats_legacy.set_default();
        }
        self.roundstats_legacy.as_mut().unwrap()
    }

    // Take field
    pub fn take_roundstats_legacy(&mut self) -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        self.roundstats_legacy.take().unwrap_or_else(|| CMsgGCCStrike15_v2_MatchmakingServerRoundStats::new())
    }

    // repeated .CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundstatsall = 5;


    pub fn get_roundstatsall(&self) -> &[CMsgGCCStrike15_v2_MatchmakingServerRoundStats] {
        &self.roundstatsall
    }
    pub fn clear_roundstatsall(&mut self) {
        self.roundstatsall.clear();
    }

    // Param is passed by value, moved
    pub fn set_roundstatsall(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>) {
        self.roundstatsall = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roundstatsall(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> {
        &mut self.roundstatsall
    }

    // Take field
    pub fn take_roundstatsall(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats> {
        ::std::mem::replace(&mut self.roundstatsall, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_MatchInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.watchablematchinfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.roundstats_legacy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.roundstatsall {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.matchid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchtime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.watchablematchinfo)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.roundstats_legacy)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.roundstatsall)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchtime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.watchablematchinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.roundstats_legacy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.roundstatsall {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.matchid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.matchtime {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.watchablematchinfo.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.roundstats_legacy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.roundstatsall {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDataGCCStrike15_v2_MatchInfo {
        CDataGCCStrike15_v2_MatchInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "matchid",
                    |m: &CDataGCCStrike15_v2_MatchInfo| { &m.matchid },
                    |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.matchid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matchtime",
                    |m: &CDataGCCStrike15_v2_MatchInfo| { &m.matchtime },
                    |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.matchtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WatchableMatchInfo>>(
                    "watchablematchinfo",
                    |m: &CDataGCCStrike15_v2_MatchInfo| { &m.watchablematchinfo },
                    |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.watchablematchinfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>>(
                    "roundstats_legacy",
                    |m: &CDataGCCStrike15_v2_MatchInfo| { &m.roundstats_legacy },
                    |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.roundstats_legacy },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>>(
                    "roundstatsall",
                    |m: &CDataGCCStrike15_v2_MatchInfo| { &m.roundstatsall },
                    |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.roundstatsall },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_MatchInfo>(
                    "CDataGCCStrike15_v2_MatchInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_MatchInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_MatchInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_MatchInfo,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_MatchInfo::new)
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_MatchInfo {
    fn clear(&mut self) {
        self.matchid = ::std::option::Option::None;
        self.matchtime = ::std::option::Option::None;
        self.watchablematchinfo.clear();
        self.roundstats_legacy.clear();
        self.roundstatsall.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_MatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_MatchInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentGroupTeam {
    // message fields
    team_id: ::std::option::Option<i32>,
    score: ::std::option::Option<i32>,
    correctpick: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentGroupTeam {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentGroupTeam {
        <CDataGCCStrike15_v2_TournamentGroupTeam as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentGroupTeam {
    pub fn new() -> CDataGCCStrike15_v2_TournamentGroupTeam {
        ::std::default::Default::default()
    }

    // optional int32 team_id = 1;


    pub fn get_team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }
    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional int32 score = 2;


    pub fn get_score(&self) -> i32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional bool correctpick = 3;


    pub fn get_correctpick(&self) -> bool {
        self.correctpick.unwrap_or(false)
    }
    pub fn clear_correctpick(&mut self) {
        self.correctpick = ::std::option::Option::None;
    }

    pub fn has_correctpick(&self) -> bool {
        self.correctpick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correctpick(&mut self, v: bool) {
        self.correctpick = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.correctpick = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.correctpick {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.correctpick {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDataGCCStrike15_v2_TournamentGroupTeam {
        CDataGCCStrike15_v2_TournamentGroupTeam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team_id",
                    |m: &CDataGCCStrike15_v2_TournamentGroupTeam| { &m.team_id },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroupTeam| { &mut m.team_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "score",
                    |m: &CDataGCCStrike15_v2_TournamentGroupTeam| { &m.score },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroupTeam| { &mut m.score },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "correctpick",
                    |m: &CDataGCCStrike15_v2_TournamentGroupTeam| { &m.correctpick },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroupTeam| { &mut m.correctpick },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentGroupTeam>(
                    "CDataGCCStrike15_v2_TournamentGroupTeam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentGroupTeam {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentGroupTeam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentGroupTeam,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentGroupTeam::new)
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.correctpick = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentGroup {
    // message fields
    groupid: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    desc: ::protobuf::SingularField<::std::string::String>,
    picks__deprecated: ::std::option::Option<u32>,
    teams: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroupTeam>,
    stage_ids: ::std::vec::Vec<i32>,
    picklockuntiltime: ::std::option::Option<u32>,
    pickableteams: ::std::option::Option<u32>,
    points_per_pick: ::std::option::Option<u32>,
    picks: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup_Picks>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentGroup {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentGroup {
        <CDataGCCStrike15_v2_TournamentGroup as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentGroup {
    pub fn new() -> CDataGCCStrike15_v2_TournamentGroup {
        ::std::default::Default::default()
    }

    // optional uint32 groupid = 1;


    pub fn get_groupid(&self) -> u32 {
        self.groupid.unwrap_or(0)
    }
    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: u32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc = 3;


    pub fn get_desc(&self) -> &str {
        match self.desc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        if self.desc.is_none() {
            self.desc.set_default();
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        self.desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 picks__deprecated = 4;


    pub fn get_picks__deprecated(&self) -> u32 {
        self.picks__deprecated.unwrap_or(0)
    }
    pub fn clear_picks__deprecated(&mut self) {
        self.picks__deprecated = ::std::option::Option::None;
    }

    pub fn has_picks__deprecated(&self) -> bool {
        self.picks__deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picks__deprecated(&mut self, v: u32) {
        self.picks__deprecated = ::std::option::Option::Some(v);
    }

    // repeated .CDataGCCStrike15_v2_TournamentGroupTeam teams = 5;


    pub fn get_teams(&self) -> &[CDataGCCStrike15_v2_TournamentGroupTeam] {
        &self.teams
    }
    pub fn clear_teams(&mut self) {
        self.teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_teams(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroupTeam>) {
        self.teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teams(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroupTeam> {
        &mut self.teams
    }

    // Take field
    pub fn take_teams(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroupTeam> {
        ::std::mem::replace(&mut self.teams, ::protobuf::RepeatedField::new())
    }

    // repeated int32 stage_ids = 6;


    pub fn get_stage_ids(&self) -> &[i32] {
        &self.stage_ids
    }
    pub fn clear_stage_ids(&mut self) {
        self.stage_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_stage_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.stage_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stage_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.stage_ids
    }

    // Take field
    pub fn take_stage_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.stage_ids, ::std::vec::Vec::new())
    }

    // optional uint32 picklockuntiltime = 7;


    pub fn get_picklockuntiltime(&self) -> u32 {
        self.picklockuntiltime.unwrap_or(0)
    }
    pub fn clear_picklockuntiltime(&mut self) {
        self.picklockuntiltime = ::std::option::Option::None;
    }

    pub fn has_picklockuntiltime(&self) -> bool {
        self.picklockuntiltime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picklockuntiltime(&mut self, v: u32) {
        self.picklockuntiltime = ::std::option::Option::Some(v);
    }

    // optional uint32 pickableteams = 8;


    pub fn get_pickableteams(&self) -> u32 {
        self.pickableteams.unwrap_or(0)
    }
    pub fn clear_pickableteams(&mut self) {
        self.pickableteams = ::std::option::Option::None;
    }

    pub fn has_pickableteams(&self) -> bool {
        self.pickableteams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pickableteams(&mut self, v: u32) {
        self.pickableteams = ::std::option::Option::Some(v);
    }

    // optional uint32 points_per_pick = 9;


    pub fn get_points_per_pick(&self) -> u32 {
        self.points_per_pick.unwrap_or(0)
    }
    pub fn clear_points_per_pick(&mut self) {
        self.points_per_pick = ::std::option::Option::None;
    }

    pub fn has_points_per_pick(&self) -> bool {
        self.points_per_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_per_pick(&mut self, v: u32) {
        self.points_per_pick = ::std::option::Option::Some(v);
    }

    // repeated .CDataGCCStrike15_v2_TournamentGroup.Picks picks = 10;


    pub fn get_picks(&self) -> &[CDataGCCStrike15_v2_TournamentGroup_Picks] {
        &self.picks
    }
    pub fn clear_picks(&mut self) {
        self.picks.clear();
    }

    // Param is passed by value, moved
    pub fn set_picks(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup_Picks>) {
        self.picks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_picks(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup_Picks> {
        &mut self.picks
    }

    // Take field
    pub fn take_picks(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup_Picks> {
        ::std::mem::replace(&mut self.picks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.teams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.picks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.groupid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.desc)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.picks__deprecated = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teams)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.stage_ids)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.picklockuntiltime = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pickableteams = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_per_pick = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.picks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.desc.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.picks__deprecated {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.stage_ids {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.picklockuntiltime {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pickableteams {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_per_pick {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.picks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.groupid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.desc.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.picks__deprecated {
            os.write_uint32(4, v)?;
        }
        for v in &self.teams {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.stage_ids {
            os.write_int32(6, *v)?;
        };
        if let Some(v) = self.picklockuntiltime {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.pickableteams {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.points_per_pick {
            os.write_uint32(9, v)?;
        }
        for v in &self.picks {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDataGCCStrike15_v2_TournamentGroup {
        CDataGCCStrike15_v2_TournamentGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "groupid",
                    |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.groupid },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.groupid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.name },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "desc",
                    |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.desc },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.desc },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "picks__deprecated",
                    |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.picks__deprecated },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.picks__deprecated },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentGroupTeam>>(
                    "teams",
                    |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.teams },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.teams },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "stage_ids",
                    |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.stage_ids },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.stage_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "picklockuntiltime",
                    |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.picklockuntiltime },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.picklockuntiltime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pickableteams",
                    |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.pickableteams },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.pickableteams },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_per_pick",
                    |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.points_per_pick },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.points_per_pick },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentGroup_Picks>>(
                    "picks",
                    |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.picks },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.picks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentGroup>(
                    "CDataGCCStrike15_v2_TournamentGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentGroup {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentGroup,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentGroup::new)
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentGroup {
    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.name.clear();
        self.desc.clear();
        self.picks__deprecated = ::std::option::Option::None;
        self.teams.clear();
        self.stage_ids.clear();
        self.picklockuntiltime = ::std::option::Option::None;
        self.pickableteams = ::std::option::Option::None;
        self.points_per_pick = ::std::option::Option::None;
        self.picks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentGroup_Picks {
    // message fields
    pickids: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentGroup_Picks {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentGroup_Picks {
        <CDataGCCStrike15_v2_TournamentGroup_Picks as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentGroup_Picks {
    pub fn new() -> CDataGCCStrike15_v2_TournamentGroup_Picks {
        ::std::default::Default::default()
    }

    // repeated int32 pickids = 1;


    pub fn get_pickids(&self) -> &[i32] {
        &self.pickids
    }
    pub fn clear_pickids(&mut self) {
        self.pickids.clear();
    }

    // Param is passed by value, moved
    pub fn set_pickids(&mut self, v: ::std::vec::Vec<i32>) {
        self.pickids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pickids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.pickids
    }

    // Take field
    pub fn take_pickids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.pickids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentGroup_Picks {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.pickids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pickids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pickids {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDataGCCStrike15_v2_TournamentGroup_Picks {
        CDataGCCStrike15_v2_TournamentGroup_Picks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pickids",
                    |m: &CDataGCCStrike15_v2_TournamentGroup_Picks| { &m.pickids },
                    |m: &mut CDataGCCStrike15_v2_TournamentGroup_Picks| { &mut m.pickids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentGroup_Picks>(
                    "CDataGCCStrike15_v2_TournamentGroup_Picks",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentGroup_Picks {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentGroup_Picks> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentGroup_Picks,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentGroup_Picks::new)
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentGroup_Picks {
    fn clear(&mut self) {
        self.pickids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentGroup_Picks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentGroup_Picks {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentSection {
    // message fields
    sectionid: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    desc: ::protobuf::SingularField<::std::string::String>,
    groups: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentSection {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentSection {
        <CDataGCCStrike15_v2_TournamentSection as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentSection {
    pub fn new() -> CDataGCCStrike15_v2_TournamentSection {
        ::std::default::Default::default()
    }

    // optional uint32 sectionid = 1;


    pub fn get_sectionid(&self) -> u32 {
        self.sectionid.unwrap_or(0)
    }
    pub fn clear_sectionid(&mut self) {
        self.sectionid = ::std::option::Option::None;
    }

    pub fn has_sectionid(&self) -> bool {
        self.sectionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sectionid(&mut self, v: u32) {
        self.sectionid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc = 3;


    pub fn get_desc(&self) -> &str {
        match self.desc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        if self.desc.is_none() {
            self.desc.set_default();
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        self.desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CDataGCCStrike15_v2_TournamentGroup groups = 4;


    pub fn get_groups(&self) -> &[CDataGCCStrike15_v2_TournamentGroup] {
        &self.groups
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentGroup> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentSection {
    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sectionid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.desc)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sectionid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.desc.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sectionid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.desc.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.groups {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDataGCCStrike15_v2_TournamentSection {
        CDataGCCStrike15_v2_TournamentSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sectionid",
                    |m: &CDataGCCStrike15_v2_TournamentSection| { &m.sectionid },
                    |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.sectionid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CDataGCCStrike15_v2_TournamentSection| { &m.name },
                    |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "desc",
                    |m: &CDataGCCStrike15_v2_TournamentSection| { &m.desc },
                    |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.desc },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentGroup>>(
                    "groups",
                    |m: &CDataGCCStrike15_v2_TournamentSection| { &m.groups },
                    |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.groups },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentSection>(
                    "CDataGCCStrike15_v2_TournamentSection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentSection {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentSection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentSection,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentSection::new)
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentSection {
    fn clear(&mut self) {
        self.sectionid = ::std::option::Option::None;
        self.name.clear();
        self.desc.clear();
        self.groups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentSection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDataGCCStrike15_v2_TournamentInfo {
    // message fields
    sections: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentSection>,
    tournament_event: ::protobuf::SingularPtrField<TournamentEvent>,
    tournament_teams: ::protobuf::RepeatedField<TournamentTeam>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentInfo {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentInfo {
        <CDataGCCStrike15_v2_TournamentInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentInfo {
    pub fn new() -> CDataGCCStrike15_v2_TournamentInfo {
        ::std::default::Default::default()
    }

    // repeated .CDataGCCStrike15_v2_TournamentSection sections = 1;


    pub fn get_sections(&self) -> &[CDataGCCStrike15_v2_TournamentSection] {
        &self.sections
    }
    pub fn clear_sections(&mut self) {
        self.sections.clear();
    }

    // Param is passed by value, moved
    pub fn set_sections(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentSection>) {
        self.sections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sections(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentSection> {
        &mut self.sections
    }

    // Take field
    pub fn take_sections(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_TournamentSection> {
        ::std::mem::replace(&mut self.sections, ::protobuf::RepeatedField::new())
    }

    // optional .TournamentEvent tournament_event = 2;


    pub fn get_tournament_event(&self) -> &TournamentEvent {
        self.tournament_event.as_ref().unwrap_or_else(|| TournamentEvent::default_instance())
    }
    pub fn clear_tournament_event(&mut self) {
        self.tournament_event.clear();
    }

    pub fn has_tournament_event(&self) -> bool {
        self.tournament_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_event(&mut self, v: TournamentEvent) {
        self.tournament_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_event(&mut self) -> &mut TournamentEvent {
        if self.tournament_event.is_none() {
            self.tournament_event.set_default();
        }
        self.tournament_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournament_event(&mut self) -> TournamentEvent {
        self.tournament_event.take().unwrap_or_else(|| TournamentEvent::new())
    }

    // repeated .TournamentTeam tournament_teams = 3;


    pub fn get_tournament_teams(&self) -> &[TournamentTeam] {
        &self.tournament_teams
    }
    pub fn clear_tournament_teams(&mut self) {
        self.tournament_teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_tournament_teams(&mut self, v: ::protobuf::RepeatedField<TournamentTeam>) {
        self.tournament_teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tournament_teams(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.tournament_teams
    }

    // Take field
    pub fn take_tournament_teams(&mut self) -> ::protobuf::RepeatedField<TournamentTeam> {
        ::std::mem::replace(&mut self.tournament_teams, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.sections {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tournament_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tournament_teams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sections)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tournament_event)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tournament_teams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.tournament_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tournament_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sections {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.tournament_event.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tournament_teams {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDataGCCStrike15_v2_TournamentInfo {
        CDataGCCStrike15_v2_TournamentInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentSection>>(
                    "sections",
                    |m: &CDataGCCStrike15_v2_TournamentInfo| { &m.sections },
                    |m: &mut CDataGCCStrike15_v2_TournamentInfo| { &mut m.sections },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentEvent>>(
                    "tournament_event",
                    |m: &CDataGCCStrike15_v2_TournamentInfo| { &m.tournament_event },
                    |m: &mut CDataGCCStrike15_v2_TournamentInfo| { &mut m.tournament_event },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentTeam>>(
                    "tournament_teams",
                    |m: &CDataGCCStrike15_v2_TournamentInfo| { &m.tournament_teams },
                    |m: &mut CDataGCCStrike15_v2_TournamentInfo| { &mut m.tournament_teams },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDataGCCStrike15_v2_TournamentInfo>(
                    "CDataGCCStrike15_v2_TournamentInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDataGCCStrike15_v2_TournamentInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDataGCCStrike15_v2_TournamentInfo,
        };
        unsafe {
            instance.get(CDataGCCStrike15_v2_TournamentInfo::new)
        }
    }
}

impl ::protobuf::Clear for CDataGCCStrike15_v2_TournamentInfo {
    fn clear(&mut self) {
        self.sections.clear();
        self.tournament_event.clear();
        self.tournament_teams.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDataGCCStrike15_v2_TournamentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_MatchList {
    // message fields
    msgrequestid: ::std::option::Option<u32>,
    accountid: ::std::option::Option<u32>,
    servertime: ::std::option::Option<u32>,
    matches: ::protobuf::RepeatedField<CDataGCCStrike15_v2_MatchInfo>,
    streams: ::protobuf::RepeatedField<TournamentTeam>,
    tournamentinfo: ::protobuf::SingularPtrField<CDataGCCStrike15_v2_TournamentInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchList {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchList {
        <CMsgGCCStrike15_v2_MatchList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchList {
    pub fn new() -> CMsgGCCStrike15_v2_MatchList {
        ::std::default::Default::default()
    }

    // optional uint32 msgrequestid = 1;


    pub fn get_msgrequestid(&self) -> u32 {
        self.msgrequestid.unwrap_or(0)
    }
    pub fn clear_msgrequestid(&mut self) {
        self.msgrequestid = ::std::option::Option::None;
    }

    pub fn has_msgrequestid(&self) -> bool {
        self.msgrequestid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgrequestid(&mut self, v: u32) {
        self.msgrequestid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid = 2;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 servertime = 3;


    pub fn get_servertime(&self) -> u32 {
        self.servertime.unwrap_or(0)
    }
    pub fn clear_servertime(&mut self) {
        self.servertime = ::std::option::Option::None;
    }

    pub fn has_servertime(&self) -> bool {
        self.servertime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servertime(&mut self, v: u32) {
        self.servertime = ::std::option::Option::Some(v);
    }

    // repeated .CDataGCCStrike15_v2_MatchInfo matches = 4;


    pub fn get_matches(&self) -> &[CDataGCCStrike15_v2_MatchInfo] {
        &self.matches
    }
    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<CDataGCCStrike15_v2_MatchInfo>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<CDataGCCStrike15_v2_MatchInfo> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<CDataGCCStrike15_v2_MatchInfo> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    // repeated .TournamentTeam streams = 5;


    pub fn get_streams(&self) -> &[TournamentTeam] {
        &self.streams
    }
    pub fn clear_streams(&mut self) {
        self.streams.clear();
    }

    // Param is passed by value, moved
    pub fn set_streams(&mut self, v: ::protobuf::RepeatedField<TournamentTeam>) {
        self.streams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streams(&mut self) -> &mut ::protobuf::RepeatedField<TournamentTeam> {
        &mut self.streams
    }

    // Take field
    pub fn take_streams(&mut self) -> ::protobuf::RepeatedField<TournamentTeam> {
        ::std::mem::replace(&mut self.streams, ::protobuf::RepeatedField::new())
    }

    // optional .CDataGCCStrike15_v2_TournamentInfo tournamentinfo = 6;


    pub fn get_tournamentinfo(&self) -> &CDataGCCStrike15_v2_TournamentInfo {
        self.tournamentinfo.as_ref().unwrap_or_else(|| CDataGCCStrike15_v2_TournamentInfo::default_instance())
    }
    pub fn clear_tournamentinfo(&mut self) {
        self.tournamentinfo.clear();
    }

    pub fn has_tournamentinfo(&self) -> bool {
        self.tournamentinfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournamentinfo(&mut self, v: CDataGCCStrike15_v2_TournamentInfo) {
        self.tournamentinfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournamentinfo(&mut self) -> &mut CDataGCCStrike15_v2_TournamentInfo {
        if self.tournamentinfo.is_none() {
            self.tournamentinfo.set_default();
        }
        self.tournamentinfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournamentinfo(&mut self) -> CDataGCCStrike15_v2_TournamentInfo {
        self.tournamentinfo.take().unwrap_or_else(|| CDataGCCStrike15_v2_TournamentInfo::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchList {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.streams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tournamentinfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msgrequestid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.servertime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streams)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tournamentinfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msgrequestid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.servertime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.tournamentinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msgrequestid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.servertime {
            os.write_uint32(3, v)?;
        }
        for v in &self.matches {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.streams {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.tournamentinfo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_MatchList {
        CMsgGCCStrike15_v2_MatchList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "msgrequestid",
                    |m: &CMsgGCCStrike15_v2_MatchList| { &m.msgrequestid },
                    |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.msgrequestid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_MatchList| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "servertime",
                    |m: &CMsgGCCStrike15_v2_MatchList| { &m.servertime },
                    |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.servertime },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_MatchInfo>>(
                    "matches",
                    |m: &CMsgGCCStrike15_v2_MatchList| { &m.matches },
                    |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.matches },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TournamentTeam>>(
                    "streams",
                    |m: &CMsgGCCStrike15_v2_MatchList| { &m.streams },
                    |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.streams },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDataGCCStrike15_v2_TournamentInfo>>(
                    "tournamentinfo",
                    |m: &CMsgGCCStrike15_v2_MatchList| { &m.tournamentinfo },
                    |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.tournamentinfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_MatchList>(
                    "CMsgGCCStrike15_v2_MatchList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_MatchList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_MatchList,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_MatchList::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_MatchList {
    fn clear(&mut self) {
        self.msgrequestid = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.servertime = ::std::option::Option::None;
        self.matches.clear();
        self.streams.clear();
        self.tournamentinfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_MatchList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Predictions {
    // message fields
    event_id: ::std::option::Option<u32>,
    group_match_team_picks: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Predictions {
    fn default() -> &'a CMsgGCCStrike15_v2_Predictions {
        <CMsgGCCStrike15_v2_Predictions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Predictions {
    pub fn new() -> CMsgGCCStrike15_v2_Predictions {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;


    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick group_match_team_picks = 2;


    pub fn get_group_match_team_picks(&self) -> &[CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick] {
        &self.group_match_team_picks
    }
    pub fn clear_group_match_team_picks(&mut self) {
        self.group_match_team_picks.clear();
    }

    // Param is passed by value, moved
    pub fn set_group_match_team_picks(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick>) {
        self.group_match_team_picks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_group_match_team_picks(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick> {
        &mut self.group_match_team_picks
    }

    // Take field
    pub fn take_group_match_team_picks(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick> {
        ::std::mem::replace(&mut self.group_match_team_picks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Predictions {
    fn is_initialized(&self) -> bool {
        for v in &self.group_match_team_picks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.group_match_team_picks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.group_match_team_picks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.group_match_team_picks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Predictions {
        CMsgGCCStrike15_v2_Predictions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    |m: &CMsgGCCStrike15_v2_Predictions| { &m.event_id },
                    |m: &mut CMsgGCCStrike15_v2_Predictions| { &mut m.event_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick>>(
                    "group_match_team_picks",
                    |m: &CMsgGCCStrike15_v2_Predictions| { &m.group_match_team_picks },
                    |m: &mut CMsgGCCStrike15_v2_Predictions| { &mut m.group_match_team_picks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Predictions>(
                    "CMsgGCCStrike15_v2_Predictions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Predictions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Predictions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Predictions,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Predictions::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Predictions {
    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.group_match_team_picks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Predictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Predictions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    // message fields
    sectionid: ::std::option::Option<i32>,
    groupid: ::std::option::Option<i32>,
    index: ::std::option::Option<i32>,
    teamid: ::std::option::Option<i32>,
    itemid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    fn default() -> &'a CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
        <CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    pub fn new() -> CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
        ::std::default::Default::default()
    }

    // optional int32 sectionid = 1;


    pub fn get_sectionid(&self) -> i32 {
        self.sectionid.unwrap_or(0)
    }
    pub fn clear_sectionid(&mut self) {
        self.sectionid = ::std::option::Option::None;
    }

    pub fn has_sectionid(&self) -> bool {
        self.sectionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sectionid(&mut self, v: i32) {
        self.sectionid = ::std::option::Option::Some(v);
    }

    // optional int32 groupid = 2;


    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }
    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional int32 index = 3;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 teamid = 4;


    pub fn get_teamid(&self) -> i32 {
        self.teamid.unwrap_or(0)
    }
    pub fn clear_teamid(&mut self) {
        self.teamid = ::std::option::Option::None;
    }

    pub fn has_teamid(&self) -> bool {
        self.teamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teamid(&mut self, v: i32) {
        self.teamid = ::std::option::Option::Some(v);
    }

    // optional uint64 itemid = 5;


    pub fn get_itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }
    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sectionid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.groupid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.teamid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sectionid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.teamid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sectionid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.groupid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.teamid {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.itemid {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
        CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sectionid",
                    |m: &CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick| { &m.sectionid },
                    |m: &mut CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick| { &mut m.sectionid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "groupid",
                    |m: &CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick| { &m.groupid },
                    |m: &mut CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick| { &mut m.groupid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    |m: &CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick| { &m.index },
                    |m: &mut CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick| { &mut m.index },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "teamid",
                    |m: &CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick| { &m.teamid },
                    |m: &mut CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick| { &mut m.teamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "itemid",
                    |m: &CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick| { &m.itemid },
                    |m: &mut CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick| { &mut m.itemid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick>(
                    "CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    fn clear(&mut self) {
        self.sectionid = ::std::option::Option::None;
        self.groupid = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.teamid = ::std::option::Option::None;
        self.itemid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Predictions_GroupMatchTeamPick {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Fantasy {
    // message fields
    event_id: ::std::option::Option<u32>,
    teams: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasyTeam>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Fantasy {
    fn default() -> &'a CMsgGCCStrike15_v2_Fantasy {
        <CMsgGCCStrike15_v2_Fantasy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Fantasy {
    pub fn new() -> CMsgGCCStrike15_v2_Fantasy {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;


    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgGCCStrike15_v2_Fantasy.FantasyTeam teams = 2;


    pub fn get_teams(&self) -> &[CMsgGCCStrike15_v2_Fantasy_FantasyTeam] {
        &self.teams
    }
    pub fn clear_teams(&mut self) {
        self.teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_teams(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasyTeam>) {
        self.teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teams(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasyTeam> {
        &mut self.teams
    }

    // Take field
    pub fn take_teams(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasyTeam> {
        ::std::mem::replace(&mut self.teams, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Fantasy {
    fn is_initialized(&self) -> bool {
        for v in &self.teams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.teams {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Fantasy {
        CMsgGCCStrike15_v2_Fantasy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    |m: &CMsgGCCStrike15_v2_Fantasy| { &m.event_id },
                    |m: &mut CMsgGCCStrike15_v2_Fantasy| { &mut m.event_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_Fantasy_FantasyTeam>>(
                    "teams",
                    |m: &CMsgGCCStrike15_v2_Fantasy| { &m.teams },
                    |m: &mut CMsgGCCStrike15_v2_Fantasy| { &mut m.teams },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Fantasy>(
                    "CMsgGCCStrike15_v2_Fantasy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Fantasy {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Fantasy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Fantasy,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Fantasy::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Fantasy {
    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.teams.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Fantasy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Fantasy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    // message fields
    field_type: ::std::option::Option<i32>,
    pick: ::std::option::Option<i32>,
    itemid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    fn default() -> &'a CMsgGCCStrike15_v2_Fantasy_FantasySlot {
        <CMsgGCCStrike15_v2_Fantasy_FantasySlot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    pub fn new() -> CMsgGCCStrike15_v2_Fantasy_FantasySlot {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional int32 pick = 2;


    pub fn get_pick(&self) -> i32 {
        self.pick.unwrap_or(0)
    }
    pub fn clear_pick(&mut self) {
        self.pick = ::std::option::Option::None;
    }

    pub fn has_pick(&self) -> bool {
        self.pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pick(&mut self, v: i32) {
        self.pick = ::std::option::Option::Some(v);
    }

    // optional uint64 itemid = 3;


    pub fn get_itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }
    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pick = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pick {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pick {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.itemid {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Fantasy_FantasySlot {
        CMsgGCCStrike15_v2_Fantasy_FantasySlot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type",
                    |m: &CMsgGCCStrike15_v2_Fantasy_FantasySlot| { &m.field_type },
                    |m: &mut CMsgGCCStrike15_v2_Fantasy_FantasySlot| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pick",
                    |m: &CMsgGCCStrike15_v2_Fantasy_FantasySlot| { &m.pick },
                    |m: &mut CMsgGCCStrike15_v2_Fantasy_FantasySlot| { &mut m.pick },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "itemid",
                    |m: &CMsgGCCStrike15_v2_Fantasy_FantasySlot| { &m.itemid },
                    |m: &mut CMsgGCCStrike15_v2_Fantasy_FantasySlot| { &mut m.itemid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Fantasy_FantasySlot>(
                    "CMsgGCCStrike15_v2_Fantasy_FantasySlot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Fantasy_FantasySlot {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Fantasy_FantasySlot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Fantasy_FantasySlot,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Fantasy_FantasySlot::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.pick = ::std::option::Option::None;
        self.itemid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Fantasy_FantasySlot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    // message fields
    sectionid: ::std::option::Option<i32>,
    slots: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasySlot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    fn default() -> &'a CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
        <CMsgGCCStrike15_v2_Fantasy_FantasyTeam as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    pub fn new() -> CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
        ::std::default::Default::default()
    }

    // optional int32 sectionid = 1;


    pub fn get_sectionid(&self) -> i32 {
        self.sectionid.unwrap_or(0)
    }
    pub fn clear_sectionid(&mut self) {
        self.sectionid = ::std::option::Option::None;
    }

    pub fn has_sectionid(&self) -> bool {
        self.sectionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sectionid(&mut self, v: i32) {
        self.sectionid = ::std::option::Option::Some(v);
    }

    // repeated .CMsgGCCStrike15_v2_Fantasy.FantasySlot slots = 2;


    pub fn get_slots(&self) -> &[CMsgGCCStrike15_v2_Fantasy_FantasySlot] {
        &self.slots
    }
    pub fn clear_slots(&mut self) {
        self.slots.clear();
    }

    // Param is passed by value, moved
    pub fn set_slots(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasySlot>) {
        self.slots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slots(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasySlot> {
        &mut self.slots
    }

    // Take field
    pub fn take_slots(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Fantasy_FantasySlot> {
        ::std::mem::replace(&mut self.slots, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    fn is_initialized(&self) -> bool {
        for v in &self.slots {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sectionid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slots)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sectionid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sectionid {
            os.write_int32(1, v)?;
        }
        for v in &self.slots {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
        CMsgGCCStrike15_v2_Fantasy_FantasyTeam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sectionid",
                    |m: &CMsgGCCStrike15_v2_Fantasy_FantasyTeam| { &m.sectionid },
                    |m: &mut CMsgGCCStrike15_v2_Fantasy_FantasyTeam| { &mut m.sectionid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_Fantasy_FantasySlot>>(
                    "slots",
                    |m: &CMsgGCCStrike15_v2_Fantasy_FantasyTeam| { &m.slots },
                    |m: &mut CMsgGCCStrike15_v2_Fantasy_FantasyTeam| { &mut m.slots },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Fantasy_FantasyTeam>(
                    "CMsgGCCStrike15_v2_Fantasy_FantasyTeam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Fantasy_FantasyTeam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Fantasy_FantasyTeam,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Fantasy_FantasyTeam::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    fn clear(&mut self) {
        self.sectionid = ::std::option::Option::None;
        self.slots.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Fantasy_FantasyTeam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAttribute_String {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAttribute_String {
    fn default() -> &'a CAttribute_String {
        <CAttribute_String as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_String {
    pub fn new() -> CAttribute_String {
        ::std::default::Default::default()
    }

    // optional string value = 1;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CAttribute_String {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAttribute_String {
        CAttribute_String::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &CAttribute_String| { &m.value },
                    |m: &mut CAttribute_String| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CAttribute_String>(
                    "CAttribute_String",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CAttribute_String {
        static mut instance: ::protobuf::lazy::Lazy<CAttribute_String> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CAttribute_String,
        };
        unsafe {
            instance.get(CAttribute_String::new)
        }
    }
}

impl ::protobuf::Clear for CAttribute_String {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAttribute_String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_String {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCReloadVersions {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCReloadVersions {
    fn default() -> &'a CMsgGCToGCReloadVersions {
        <CMsgGCToGCReloadVersions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCReloadVersions {
    pub fn new() -> CMsgGCToGCReloadVersions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCToGCReloadVersions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCReloadVersions {
        CMsgGCToGCReloadVersions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCReloadVersions>(
                    "CMsgGCToGCReloadVersions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCToGCReloadVersions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCReloadVersions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCReloadVersions,
        };
        unsafe {
            instance.get(CMsgGCToGCReloadVersions::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCReloadVersions {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCReloadVersions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCReloadVersions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCStrike15Welcome {
    // message fields
    store_item_hash: ::std::option::Option<u32>,
    timeplayedconsecutively: ::std::option::Option<u32>,
    time_first_played: ::std::option::Option<u32>,
    last_time_played: ::std::option::Option<u32>,
    last_ip_address: ::std::option::Option<u32>,
    gscookieid: ::std::option::Option<u64>,
    uniqueid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCStrike15Welcome {
    fn default() -> &'a CMsgCStrike15Welcome {
        <CMsgCStrike15Welcome as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCStrike15Welcome {
    pub fn new() -> CMsgCStrike15Welcome {
        ::std::default::Default::default()
    }

    // optional uint32 store_item_hash = 5;


    pub fn get_store_item_hash(&self) -> u32 {
        self.store_item_hash.unwrap_or(0)
    }
    pub fn clear_store_item_hash(&mut self) {
        self.store_item_hash = ::std::option::Option::None;
    }

    pub fn has_store_item_hash(&self) -> bool {
        self.store_item_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_item_hash(&mut self, v: u32) {
        self.store_item_hash = ::std::option::Option::Some(v);
    }

    // optional uint32 timeplayedconsecutively = 6;


    pub fn get_timeplayedconsecutively(&self) -> u32 {
        self.timeplayedconsecutively.unwrap_or(0)
    }
    pub fn clear_timeplayedconsecutively(&mut self) {
        self.timeplayedconsecutively = ::std::option::Option::None;
    }

    pub fn has_timeplayedconsecutively(&self) -> bool {
        self.timeplayedconsecutively.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeplayedconsecutively(&mut self, v: u32) {
        self.timeplayedconsecutively = ::std::option::Option::Some(v);
    }

    // optional uint32 time_first_played = 10;


    pub fn get_time_first_played(&self) -> u32 {
        self.time_first_played.unwrap_or(0)
    }
    pub fn clear_time_first_played(&mut self) {
        self.time_first_played = ::std::option::Option::None;
    }

    pub fn has_time_first_played(&self) -> bool {
        self.time_first_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_first_played(&mut self, v: u32) {
        self.time_first_played = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_played = 12;


    pub fn get_last_time_played(&self) -> u32 {
        self.last_time_played.unwrap_or(0)
    }
    pub fn clear_last_time_played(&mut self) {
        self.last_time_played = ::std::option::Option::None;
    }

    pub fn has_last_time_played(&self) -> bool {
        self.last_time_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_played(&mut self, v: u32) {
        self.last_time_played = ::std::option::Option::Some(v);
    }

    // optional uint32 last_ip_address = 13;


    pub fn get_last_ip_address(&self) -> u32 {
        self.last_ip_address.unwrap_or(0)
    }
    pub fn clear_last_ip_address(&mut self) {
        self.last_ip_address = ::std::option::Option::None;
    }

    pub fn has_last_ip_address(&self) -> bool {
        self.last_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ip_address(&mut self, v: u32) {
        self.last_ip_address = ::std::option::Option::Some(v);
    }

    // optional uint64 gscookieid = 18;


    pub fn get_gscookieid(&self) -> u64 {
        self.gscookieid.unwrap_or(0)
    }
    pub fn clear_gscookieid(&mut self) {
        self.gscookieid = ::std::option::Option::None;
    }

    pub fn has_gscookieid(&self) -> bool {
        self.gscookieid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gscookieid(&mut self, v: u64) {
        self.gscookieid = ::std::option::Option::Some(v);
    }

    // optional uint64 uniqueid = 19;


    pub fn get_uniqueid(&self) -> u64 {
        self.uniqueid.unwrap_or(0)
    }
    pub fn clear_uniqueid(&mut self) {
        self.uniqueid = ::std::option::Option::None;
    }

    pub fn has_uniqueid(&self) -> bool {
        self.uniqueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uniqueid(&mut self, v: u64) {
        self.uniqueid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCStrike15Welcome {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.store_item_hash = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeplayedconsecutively = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_first_played = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_time_played = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_ip_address = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gscookieid = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uniqueid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.store_item_hash {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeplayedconsecutively {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_first_played {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time_played {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_ip_address {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gscookieid {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.uniqueid {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.store_item_hash {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.timeplayedconsecutively {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.time_first_played {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.last_time_played {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.last_ip_address {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.gscookieid {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.uniqueid {
            os.write_uint64(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCStrike15Welcome {
        CMsgCStrike15Welcome::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "store_item_hash",
                    |m: &CMsgCStrike15Welcome| { &m.store_item_hash },
                    |m: &mut CMsgCStrike15Welcome| { &mut m.store_item_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timeplayedconsecutively",
                    |m: &CMsgCStrike15Welcome| { &m.timeplayedconsecutively },
                    |m: &mut CMsgCStrike15Welcome| { &mut m.timeplayedconsecutively },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_first_played",
                    |m: &CMsgCStrike15Welcome| { &m.time_first_played },
                    |m: &mut CMsgCStrike15Welcome| { &mut m.time_first_played },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_time_played",
                    |m: &CMsgCStrike15Welcome| { &m.last_time_played },
                    |m: &mut CMsgCStrike15Welcome| { &mut m.last_time_played },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_ip_address",
                    |m: &CMsgCStrike15Welcome| { &m.last_ip_address },
                    |m: &mut CMsgCStrike15Welcome| { &mut m.last_ip_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gscookieid",
                    |m: &CMsgCStrike15Welcome| { &m.gscookieid },
                    |m: &mut CMsgCStrike15Welcome| { &mut m.gscookieid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "uniqueid",
                    |m: &CMsgCStrike15Welcome| { &m.uniqueid },
                    |m: &mut CMsgCStrike15Welcome| { &mut m.uniqueid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCStrike15Welcome>(
                    "CMsgCStrike15Welcome",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgCStrike15Welcome {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCStrike15Welcome> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCStrike15Welcome,
        };
        unsafe {
            instance.get(CMsgCStrike15Welcome::new)
        }
    }
}

impl ::protobuf::Clear for CMsgCStrike15Welcome {
    fn clear(&mut self) {
        self.store_item_hash = ::std::option::Option::None;
        self.timeplayedconsecutively = ::std::option::Option::None;
        self.time_first_played = ::std::option::Option::None;
        self.last_time_played = ::std::option::Option::None;
        self.last_ip_address = ::std::option::Option::None;
        self.gscookieid = ::std::option::Option::None;
        self.uniqueid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCStrike15Welcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCStrike15Welcome {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    // message fields
    value_name: ::protobuf::SingularField<::std::string::String>,
    value_int: ::std::option::Option<i32>,
    server_addr: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    choked_blocks: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        <CMsgGCCStrike15_v2_ClientVarValueNotificationInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    pub fn new() -> CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        ::std::default::Default::default()
    }

    // optional string value_name = 1;


    pub fn get_value_name(&self) -> &str {
        match self.value_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value_name(&mut self) {
        self.value_name.clear();
    }

    pub fn has_value_name(&self) -> bool {
        self.value_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_name(&mut self, v: ::std::string::String) {
        self.value_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_name(&mut self) -> &mut ::std::string::String {
        if self.value_name.is_none() {
            self.value_name.set_default();
        }
        self.value_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_name(&mut self) -> ::std::string::String {
        self.value_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 value_int = 2;


    pub fn get_value_int(&self) -> i32 {
        self.value_int.unwrap_or(0)
    }
    pub fn clear_value_int(&mut self) {
        self.value_int = ::std::option::Option::None;
    }

    pub fn has_value_int(&self) -> bool {
        self.value_int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_int(&mut self, v: i32) {
        self.value_int = ::std::option::Option::Some(v);
    }

    // optional uint32 server_addr = 3;


    pub fn get_server_addr(&self) -> u32 {
        self.server_addr.unwrap_or(0)
    }
    pub fn clear_server_addr(&mut self) {
        self.server_addr = ::std::option::Option::None;
    }

    pub fn has_server_addr(&self) -> bool {
        self.server_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_addr(&mut self, v: u32) {
        self.server_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 4;


    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }
    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // repeated string choked_blocks = 5;


    pub fn get_choked_blocks(&self) -> &[::std::string::String] {
        &self.choked_blocks
    }
    pub fn clear_choked_blocks(&mut self) {
        self.choked_blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_choked_blocks(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.choked_blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_choked_blocks(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.choked_blocks
    }

    // Take field
    pub fn take_choked_blocks(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.choked_blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value_int = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_addr = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.choked_blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value_int {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_addr {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.choked_blocks {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.value_int {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.server_addr {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(4, v)?;
        }
        for v in &self.choked_blocks {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value_name",
                    |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.value_name },
                    |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.value_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value_int",
                    |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.value_int },
                    |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.value_int },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_addr",
                    |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.server_addr },
                    |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.server_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_port",
                    |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.server_port },
                    |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.server_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "choked_blocks",
                    |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.choked_blocks },
                    |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.choked_blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientVarValueNotificationInfo>(
                    "CMsgGCCStrike15_v2_ClientVarValueNotificationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientVarValueNotificationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientVarValueNotificationInfo,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn clear(&mut self) {
        self.value_name.clear();
        self.value_int = ::std::option::Option::None;
        self.server_addr = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.choked_blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    // message fields
    accountid: ::std::option::Option<u32>,
    viewangles: ::std::vec::Vec<u32>,
    field_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        <CMsgGCCStrike15_v2_ServerVarValueNotificationInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    pub fn new() -> CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // repeated uint32 viewangles = 2;


    pub fn get_viewangles(&self) -> &[u32] {
        &self.viewangles
    }
    pub fn clear_viewangles(&mut self) {
        self.viewangles.clear();
    }

    // Param is passed by value, moved
    pub fn set_viewangles(&mut self, v: ::std::vec::Vec<u32>) {
        self.viewangles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_viewangles(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.viewangles
    }

    // Take field
    pub fn take_viewangles(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.viewangles, ::std::vec::Vec::new())
    }

    // optional uint32 type = 3;


    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.viewangles)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.viewangles {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        for v in &self.viewangles {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.field_type {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "viewangles",
                    |m: &CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &m.viewangles },
                    |m: &mut CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &mut m.viewangles },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &m.field_type },
                    |m: &mut CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ServerVarValueNotificationInfo>(
                    "CMsgGCCStrike15_v2_ServerVarValueNotificationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ServerVarValueNotificationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ServerVarValueNotificationInfo,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.viewangles.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn default() -> &'a CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        <CMsgGCCStrike15_v2_GiftsLeaderboardRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    pub fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        CMsgGCCStrike15_v2_GiftsLeaderboardRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GiftsLeaderboardRequest>(
                    "CMsgGCCStrike15_v2_GiftsLeaderboardRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GiftsLeaderboardRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GiftsLeaderboardRequest,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GiftsLeaderboardRequest::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    // message fields
    servertime: ::std::option::Option<u32>,
    time_period_seconds: ::std::option::Option<u32>,
    total_gifts_given: ::std::option::Option<u32>,
    total_givers: ::std::option::Option<u32>,
    entries: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        <CMsgGCCStrike15_v2_GiftsLeaderboardResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    pub fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        ::std::default::Default::default()
    }

    // optional uint32 servertime = 1;


    pub fn get_servertime(&self) -> u32 {
        self.servertime.unwrap_or(0)
    }
    pub fn clear_servertime(&mut self) {
        self.servertime = ::std::option::Option::None;
    }

    pub fn has_servertime(&self) -> bool {
        self.servertime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servertime(&mut self, v: u32) {
        self.servertime = ::std::option::Option::Some(v);
    }

    // optional uint32 time_period_seconds = 2;


    pub fn get_time_period_seconds(&self) -> u32 {
        self.time_period_seconds.unwrap_or(0)
    }
    pub fn clear_time_period_seconds(&mut self) {
        self.time_period_seconds = ::std::option::Option::None;
    }

    pub fn has_time_period_seconds(&self) -> bool {
        self.time_period_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_period_seconds(&mut self, v: u32) {
        self.time_period_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 total_gifts_given = 3;


    pub fn get_total_gifts_given(&self) -> u32 {
        self.total_gifts_given.unwrap_or(0)
    }
    pub fn clear_total_gifts_given(&mut self) {
        self.total_gifts_given = ::std::option::Option::None;
    }

    pub fn has_total_gifts_given(&self) -> bool {
        self.total_gifts_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_gifts_given(&mut self, v: u32) {
        self.total_gifts_given = ::std::option::Option::Some(v);
    }

    // optional uint32 total_givers = 4;


    pub fn get_total_givers(&self) -> u32 {
        self.total_givers.unwrap_or(0)
    }
    pub fn clear_total_givers(&mut self) {
        self.total_givers = ::std::option::Option::None;
    }

    pub fn has_total_givers(&self) -> bool {
        self.total_givers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_givers(&mut self, v: u32) {
        self.total_givers = ::std::option::Option::Some(v);
    }

    // repeated .CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry entries = 5;


    pub fn get_entries(&self) -> &[CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.servertime = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_period_seconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_gifts_given = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_givers = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.servertime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_period_seconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_gifts_given {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_givers {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.servertime {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_period_seconds {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total_gifts_given {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.total_givers {
            os.write_uint32(4, v)?;
        }
        for v in &self.entries {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        CMsgGCCStrike15_v2_GiftsLeaderboardResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "servertime",
                    |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.servertime },
                    |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.servertime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_period_seconds",
                    |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.time_period_seconds },
                    |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.time_period_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_gifts_given",
                    |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.total_gifts_given },
                    |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.total_gifts_given },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_givers",
                    |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.total_givers },
                    |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.total_givers },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry>>(
                    "entries",
                    |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.entries },
                    |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.entries },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GiftsLeaderboardResponse>(
                    "CMsgGCCStrike15_v2_GiftsLeaderboardResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GiftsLeaderboardResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GiftsLeaderboardResponse,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GiftsLeaderboardResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn clear(&mut self) {
        self.servertime = ::std::option::Option::None;
        self.time_period_seconds = ::std::option::Option::None;
        self.total_gifts_given = ::std::option::Option::None;
        self.total_givers = ::std::option::Option::None;
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    // message fields
    accountid: ::std::option::Option<u32>,
    gifts: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    fn default() -> &'a CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
        <CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    pub fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 gifts = 2;


    pub fn get_gifts(&self) -> u32 {
        self.gifts.unwrap_or(0)
    }
    pub fn clear_gifts(&mut self) {
        self.gifts = ::std::option::Option::None;
    }

    pub fn has_gifts(&self) -> bool {
        self.gifts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifts(&mut self, v: u32) {
        self.gifts = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gifts = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gifts {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gifts {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
        CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gifts",
                    |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry| { &m.gifts },
                    |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry| { &mut m.gifts },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry>(
                    "CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.gifts = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GiftsLeaderboardResponse_GiftLeaderboardEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    // message fields
    survey_id: ::std::option::Option<u32>,
    vote: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        <CMsgGCCStrike15_v2_ClientSubmitSurveyVote as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    pub fn new() -> CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;


    pub fn get_survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }
    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    // optional uint32 vote = 2;


    pub fn get_vote(&self) -> u32 {
        self.vote.unwrap_or(0)
    }
    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: u32) {
        self.vote = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.survey_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vote = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.vote {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        CMsgGCCStrike15_v2_ClientSubmitSurveyVote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "survey_id",
                    |m: &CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &m.survey_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &mut m.survey_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vote",
                    |m: &CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &m.vote },
                    |m: &mut CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &mut m.vote },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientSubmitSurveyVote>(
                    "CMsgGCCStrike15_v2_ClientSubmitSurveyVote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientSubmitSurveyVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientSubmitSurveyVote,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientSubmitSurveyVote::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.vote = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Server2GCClientValidate {
    // message fields
    accountid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn default() -> &'a CMsgGCCStrike15_v2_Server2GCClientValidate {
        <CMsgGCCStrike15_v2_Server2GCClientValidate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Server2GCClientValidate {
    pub fn new() -> CMsgGCCStrike15_v2_Server2GCClientValidate {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Server2GCClientValidate {
        CMsgGCCStrike15_v2_Server2GCClientValidate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_Server2GCClientValidate| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_Server2GCClientValidate| { &mut m.accountid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Server2GCClientValidate>(
                    "CMsgGCCStrike15_v2_Server2GCClientValidate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Server2GCClientValidate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Server2GCClientValidate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Server2GCClientValidate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Server2GCClientValidate::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    // message fields
    accountid: ::std::option::Option<u32>,
    path: ::protobuf::SingularField<::std::string::String>,
    file: ::protobuf::SingularField<::std::string::String>,
    crc: ::std::option::Option<u32>,
    hash: ::std::option::Option<i32>,
    len: ::std::option::Option<i32>,
    pack_number: ::std::option::Option<i32>,
    pack_file_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn default() -> &'a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        <CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    pub fn new() -> CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file = 3;


    pub fn get_file(&self) -> &str {
        match self.file.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    pub fn has_file(&self) -> bool {
        self.file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        if self.file.is_none() {
            self.file.set_default();
        }
        self.file.as_mut().unwrap()
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        self.file.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 crc = 4;


    pub fn get_crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }
    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    // optional int32 hash = 5;


    pub fn get_hash(&self) -> i32 {
        self.hash.unwrap_or(0)
    }
    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: i32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 len = 6;


    pub fn get_len(&self) -> i32 {
        self.len.unwrap_or(0)
    }
    pub fn clear_len(&mut self) {
        self.len = ::std::option::Option::None;
    }

    pub fn has_len(&self) -> bool {
        self.len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: i32) {
        self.len = ::std::option::Option::Some(v);
    }

    // optional int32 pack_number = 7;


    pub fn get_pack_number(&self) -> i32 {
        self.pack_number.unwrap_or(0)
    }
    pub fn clear_pack_number(&mut self) {
        self.pack_number = ::std::option::Option::None;
    }

    pub fn has_pack_number(&self) -> bool {
        self.pack_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pack_number(&mut self, v: i32) {
        self.pack_number = ::std::option::Option::Some(v);
    }

    // optional int32 pack_file_id = 8;


    pub fn get_pack_file_id(&self) -> i32 {
        self.pack_file_id.unwrap_or(0)
    }
    pub fn clear_pack_file_id(&mut self) {
        self.pack_file_id = ::std::option::Option::None;
    }

    pub fn has_pack_file_id(&self) -> bool {
        self.pack_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pack_file_id(&mut self, v: i32) {
        self.pack_file_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.crc = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hash = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.len = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pack_number = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pack_file_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.file.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.crc {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.len {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pack_number {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pack_file_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.file.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.crc {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.hash {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.len {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.pack_number {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.pack_file_id {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.path },
                    |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file",
                    |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.file },
                    |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.file },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "crc",
                    |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.crc },
                    |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.crc },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hash",
                    |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.hash },
                    |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "len",
                    |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.len },
                    |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.len },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pack_number",
                    |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.pack_number },
                    |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.pack_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pack_file_id",
                    |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.pack_file_id },
                    |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.pack_file_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure>(
                    "CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.path.clear();
        self.file.clear();
        self.crc = ::std::option::Option::None;
        self.hash = ::std::option::Option::None;
        self.len = ::std::option::Option::None;
        self.pack_number = ::std::option::Option::None;
        self.pack_file_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    // message fields
    eventid: ::std::option::Option<u32>,
    stageid: ::std::option::Option<u32>,
    game_type: ::std::option::Option<u32>,
    teamids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        <CMsgGCCStrike15_v2_GC2ClientTournamentInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        ::std::default::Default::default()
    }

    // optional uint32 eventid = 1;


    pub fn get_eventid(&self) -> u32 {
        self.eventid.unwrap_or(0)
    }
    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: u32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional uint32 stageid = 2;


    pub fn get_stageid(&self) -> u32 {
        self.stageid.unwrap_or(0)
    }
    pub fn clear_stageid(&mut self) {
        self.stageid = ::std::option::Option::None;
    }

    pub fn has_stageid(&self) -> bool {
        self.stageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stageid(&mut self, v: u32) {
        self.stageid = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 3;


    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }
    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // repeated uint32 teamids = 4;


    pub fn get_teamids(&self) -> &[u32] {
        &self.teamids
    }
    pub fn clear_teamids(&mut self) {
        self.teamids.clear();
    }

    // Param is passed by value, moved
    pub fn set_teamids(&mut self, v: ::std::vec::Vec<u32>) {
        self.teamids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teamids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.teamids
    }

    // Take field
    pub fn take_teamids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.teamids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eventid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stageid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.teamids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stageid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.teamids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stageid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(3, v)?;
        }
        for v in &self.teamids {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        CMsgGCCStrike15_v2_GC2ClientTournamentInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eventid",
                    |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.eventid },
                    |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.eventid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stageid",
                    |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.stageid },
                    |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.stageid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.game_type },
                    |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.game_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "teamids",
                    |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.teamids },
                    |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.teamids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GC2ClientTournamentInfo>(
                    "CMsgGCCStrike15_v2_GC2ClientTournamentInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GC2ClientTournamentInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GC2ClientTournamentInfo,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GC2ClientTournamentInfo::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.stageid = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.teamids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconCoupon {
    // message fields
    entryid: ::std::option::Option<u32>,
    defidx: ::std::option::Option<u32>,
    expiration_date: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconCoupon {
    fn default() -> &'a CSOEconCoupon {
        <CSOEconCoupon as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconCoupon {
    pub fn new() -> CSOEconCoupon {
        ::std::default::Default::default()
    }

    // optional uint32 entryid = 1;


    pub fn get_entryid(&self) -> u32 {
        self.entryid.unwrap_or(0)
    }
    pub fn clear_entryid(&mut self) {
        self.entryid = ::std::option::Option::None;
    }

    pub fn has_entryid(&self) -> bool {
        self.entryid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryid(&mut self, v: u32) {
        self.entryid = ::std::option::Option::Some(v);
    }

    // optional uint32 defidx = 2;


    pub fn get_defidx(&self) -> u32 {
        self.defidx.unwrap_or(0)
    }
    pub fn clear_defidx(&mut self) {
        self.defidx = ::std::option::Option::None;
    }

    pub fn has_defidx(&self) -> bool {
        self.defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defidx(&mut self, v: u32) {
        self.defidx = ::std::option::Option::Some(v);
    }

    // optional fixed32 expiration_date = 3;


    pub fn get_expiration_date(&self) -> u32 {
        self.expiration_date.unwrap_or(0)
    }
    pub fn clear_expiration_date(&mut self) {
        self.expiration_date = ::std::option::Option::None;
    }

    pub fn has_expiration_date(&self) -> bool {
        self.expiration_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_date(&mut self, v: u32) {
        self.expiration_date = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconCoupon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.entryid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defidx = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.expiration_date = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entryid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defidx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiration_date {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entryid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.defidx {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_date {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconCoupon {
        CSOEconCoupon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "entryid",
                    |m: &CSOEconCoupon| { &m.entryid },
                    |m: &mut CSOEconCoupon| { &mut m.entryid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "defidx",
                    |m: &CSOEconCoupon| { &m.defidx },
                    |m: &mut CSOEconCoupon| { &mut m.defidx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "expiration_date",
                    |m: &CSOEconCoupon| { &m.expiration_date },
                    |m: &mut CSOEconCoupon| { &mut m.expiration_date },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSOEconCoupon>(
                    "CSOEconCoupon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CSOEconCoupon {
        static mut instance: ::protobuf::lazy::Lazy<CSOEconCoupon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSOEconCoupon,
        };
        unsafe {
            instance.get(CSOEconCoupon::new)
        }
    }
}

impl ::protobuf::Clear for CSOEconCoupon {
    fn clear(&mut self) {
        self.entryid = ::std::option::Option::None;
        self.defidx = ::std::option::Option::None;
        self.expiration_date = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconCoupon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconCoupon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOQuestProgress {
    // message fields
    questid: ::std::option::Option<u32>,
    points_remaining: ::std::option::Option<u32>,
    bonus_points: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOQuestProgress {
    fn default() -> &'a CSOQuestProgress {
        <CSOQuestProgress as ::protobuf::Message>::default_instance()
    }
}

impl CSOQuestProgress {
    pub fn new() -> CSOQuestProgress {
        ::std::default::Default::default()
    }

    // optional uint32 questid = 1;


    pub fn get_questid(&self) -> u32 {
        self.questid.unwrap_or(0)
    }
    pub fn clear_questid(&mut self) {
        self.questid = ::std::option::Option::None;
    }

    pub fn has_questid(&self) -> bool {
        self.questid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_questid(&mut self, v: u32) {
        self.questid = ::std::option::Option::Some(v);
    }

    // optional uint32 points_remaining = 2;


    pub fn get_points_remaining(&self) -> u32 {
        self.points_remaining.unwrap_or(0)
    }
    pub fn clear_points_remaining(&mut self) {
        self.points_remaining = ::std::option::Option::None;
    }

    pub fn has_points_remaining(&self) -> bool {
        self.points_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_remaining(&mut self, v: u32) {
        self.points_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_points = 3;


    pub fn get_bonus_points(&self) -> u32 {
        self.bonus_points.unwrap_or(0)
    }
    pub fn clear_bonus_points(&mut self) {
        self.bonus_points = ::std::option::Option::None;
    }

    pub fn has_bonus_points(&self) -> bool {
        self.bonus_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_points(&mut self, v: u32) {
        self.bonus_points = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOQuestProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.questid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_remaining = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bonus_points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.questid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_remaining {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bonus_points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.questid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.points_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOQuestProgress {
        CSOQuestProgress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "questid",
                    |m: &CSOQuestProgress| { &m.questid },
                    |m: &mut CSOQuestProgress| { &mut m.questid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_remaining",
                    |m: &CSOQuestProgress| { &m.points_remaining },
                    |m: &mut CSOQuestProgress| { &mut m.points_remaining },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bonus_points",
                    |m: &CSOQuestProgress| { &m.bonus_points },
                    |m: &mut CSOQuestProgress| { &mut m.bonus_points },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSOQuestProgress>(
                    "CSOQuestProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CSOQuestProgress {
        static mut instance: ::protobuf::lazy::Lazy<CSOQuestProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSOQuestProgress,
        };
        unsafe {
            instance.get(CSOQuestProgress::new)
        }
    }
}

impl ::protobuf::Clear for CSOQuestProgress {
    fn clear(&mut self) {
        self.questid = ::std::option::Option::None;
        self.points_remaining = ::std::option::Option::None;
        self.bonus_points = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOQuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOQuestProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOPersonaDataPublic {
    // message fields
    player_level: ::std::option::Option<i32>,
    commendation: ::protobuf::SingularPtrField<PlayerCommendationInfo>,
    elevated_state: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOPersonaDataPublic {
    fn default() -> &'a CSOPersonaDataPublic {
        <CSOPersonaDataPublic as ::protobuf::Message>::default_instance()
    }
}

impl CSOPersonaDataPublic {
    pub fn new() -> CSOPersonaDataPublic {
        ::std::default::Default::default()
    }

    // optional int32 player_level = 1;


    pub fn get_player_level(&self) -> i32 {
        self.player_level.unwrap_or(0)
    }
    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: i32) {
        self.player_level = ::std::option::Option::Some(v);
    }

    // optional .PlayerCommendationInfo commendation = 2;


    pub fn get_commendation(&self) -> &PlayerCommendationInfo {
        self.commendation.as_ref().unwrap_or_else(|| PlayerCommendationInfo::default_instance())
    }
    pub fn clear_commendation(&mut self) {
        self.commendation.clear();
    }

    pub fn has_commendation(&self) -> bool {
        self.commendation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commendation(&mut self, v: PlayerCommendationInfo) {
        self.commendation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commendation(&mut self) -> &mut PlayerCommendationInfo {
        if self.commendation.is_none() {
            self.commendation.set_default();
        }
        self.commendation.as_mut().unwrap()
    }

    // Take field
    pub fn take_commendation(&mut self) -> PlayerCommendationInfo {
        self.commendation.take().unwrap_or_else(|| PlayerCommendationInfo::new())
    }

    // optional bool elevated_state = 3;


    pub fn get_elevated_state(&self) -> bool {
        self.elevated_state.unwrap_or(false)
    }
    pub fn clear_elevated_state(&mut self) {
        self.elevated_state = ::std::option::Option::None;
    }

    pub fn has_elevated_state(&self) -> bool {
        self.elevated_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevated_state(&mut self, v: bool) {
        self.elevated_state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOPersonaDataPublic {
    fn is_initialized(&self) -> bool {
        for v in &self.commendation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commendation)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.elevated_state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.elevated_state {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_level {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.commendation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.elevated_state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOPersonaDataPublic {
        CSOPersonaDataPublic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_level",
                    |m: &CSOPersonaDataPublic| { &m.player_level },
                    |m: &mut CSOPersonaDataPublic| { &mut m.player_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerCommendationInfo>>(
                    "commendation",
                    |m: &CSOPersonaDataPublic| { &m.commendation },
                    |m: &mut CSOPersonaDataPublic| { &mut m.commendation },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "elevated_state",
                    |m: &CSOPersonaDataPublic| { &m.elevated_state },
                    |m: &mut CSOPersonaDataPublic| { &mut m.elevated_state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSOPersonaDataPublic>(
                    "CSOPersonaDataPublic",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CSOPersonaDataPublic {
        static mut instance: ::protobuf::lazy::Lazy<CSOPersonaDataPublic> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSOPersonaDataPublic,
        };
        unsafe {
            instance.get(CSOPersonaDataPublic::new)
        }
    }
}

impl ::protobuf::Clear for CSOPersonaDataPublic {
    fn clear(&mut self) {
        self.player_level = ::std::option::Option::None;
        self.commendation.clear();
        self.elevated_state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOPersonaDataPublic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOPersonaDataPublic {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GlobalGame_Subscribe {
    // message fields
    ticket: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GlobalGame_Subscribe {
    fn default() -> &'a CMsgGC_GlobalGame_Subscribe {
        <CMsgGC_GlobalGame_Subscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GlobalGame_Subscribe {
    pub fn new() -> CMsgGC_GlobalGame_Subscribe {
        ::std::default::Default::default()
    }

    // optional uint64 ticket = 1;


    pub fn get_ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }
    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Subscribe {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ticket = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GlobalGame_Subscribe {
        CMsgGC_GlobalGame_Subscribe::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ticket",
                    |m: &CMsgGC_GlobalGame_Subscribe| { &m.ticket },
                    |m: &mut CMsgGC_GlobalGame_Subscribe| { &mut m.ticket },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGC_GlobalGame_Subscribe>(
                    "CMsgGC_GlobalGame_Subscribe",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGC_GlobalGame_Subscribe {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGC_GlobalGame_Subscribe> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGC_GlobalGame_Subscribe,
        };
        unsafe {
            instance.get(CMsgGC_GlobalGame_Subscribe::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGC_GlobalGame_Subscribe {
    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GlobalGame_Subscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Subscribe {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GlobalGame_Unsubscribe {
    // message fields
    timeleft: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GlobalGame_Unsubscribe {
    fn default() -> &'a CMsgGC_GlobalGame_Unsubscribe {
        <CMsgGC_GlobalGame_Unsubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GlobalGame_Unsubscribe {
    pub fn new() -> CMsgGC_GlobalGame_Unsubscribe {
        ::std::default::Default::default()
    }

    // optional int32 timeleft = 1;


    pub fn get_timeleft(&self) -> i32 {
        self.timeleft.unwrap_or(0)
    }
    pub fn clear_timeleft(&mut self) {
        self.timeleft = ::std::option::Option::None;
    }

    pub fn has_timeleft(&self) -> bool {
        self.timeleft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeleft(&mut self, v: i32) {
        self.timeleft = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Unsubscribe {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timeleft = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeleft {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeleft {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GlobalGame_Unsubscribe {
        CMsgGC_GlobalGame_Unsubscribe::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "timeleft",
                    |m: &CMsgGC_GlobalGame_Unsubscribe| { &m.timeleft },
                    |m: &mut CMsgGC_GlobalGame_Unsubscribe| { &mut m.timeleft },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGC_GlobalGame_Unsubscribe>(
                    "CMsgGC_GlobalGame_Unsubscribe",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGC_GlobalGame_Unsubscribe {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGC_GlobalGame_Unsubscribe> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGC_GlobalGame_Unsubscribe,
        };
        unsafe {
            instance.get(CMsgGC_GlobalGame_Unsubscribe::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGC_GlobalGame_Unsubscribe {
    fn clear(&mut self) {
        self.timeleft = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GlobalGame_Unsubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Unsubscribe {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GlobalGame_Play {
    // message fields
    ticket: ::std::option::Option<u64>,
    gametimems: ::std::option::Option<u32>,
    msperpoint: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GlobalGame_Play {
    fn default() -> &'a CMsgGC_GlobalGame_Play {
        <CMsgGC_GlobalGame_Play as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GlobalGame_Play {
    pub fn new() -> CMsgGC_GlobalGame_Play {
        ::std::default::Default::default()
    }

    // optional uint64 ticket = 1;


    pub fn get_ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }
    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // optional uint32 gametimems = 2;


    pub fn get_gametimems(&self) -> u32 {
        self.gametimems.unwrap_or(0)
    }
    pub fn clear_gametimems(&mut self) {
        self.gametimems = ::std::option::Option::None;
    }

    pub fn has_gametimems(&self) -> bool {
        self.gametimems.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gametimems(&mut self, v: u32) {
        self.gametimems = ::std::option::Option::Some(v);
    }

    // optional uint32 msperpoint = 3;


    pub fn get_msperpoint(&self) -> u32 {
        self.msperpoint.unwrap_or(0)
    }
    pub fn clear_msperpoint(&mut self) {
        self.msperpoint = ::std::option::Option::None;
    }

    pub fn has_msperpoint(&self) -> bool {
        self.msperpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msperpoint(&mut self, v: u32) {
        self.msperpoint = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Play {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ticket = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gametimems = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msperpoint = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gametimems {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msperpoint {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.gametimems {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.msperpoint {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GlobalGame_Play {
        CMsgGC_GlobalGame_Play::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ticket",
                    |m: &CMsgGC_GlobalGame_Play| { &m.ticket },
                    |m: &mut CMsgGC_GlobalGame_Play| { &mut m.ticket },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gametimems",
                    |m: &CMsgGC_GlobalGame_Play| { &m.gametimems },
                    |m: &mut CMsgGC_GlobalGame_Play| { &mut m.gametimems },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "msperpoint",
                    |m: &CMsgGC_GlobalGame_Play| { &m.msperpoint },
                    |m: &mut CMsgGC_GlobalGame_Play| { &mut m.msperpoint },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGC_GlobalGame_Play>(
                    "CMsgGC_GlobalGame_Play",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGC_GlobalGame_Play {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGC_GlobalGame_Play> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGC_GlobalGame_Play,
        };
        unsafe {
            instance.get(CMsgGC_GlobalGame_Play::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGC_GlobalGame_Play {
    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.gametimems = ::std::option::Option::None;
        self.msperpoint = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GlobalGame_Play {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Play {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_AcknowledgePenalty {
    // message fields
    acknowledged: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn default() -> &'a CMsgGCCStrike15_v2_AcknowledgePenalty {
        <CMsgGCCStrike15_v2_AcknowledgePenalty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_AcknowledgePenalty {
    pub fn new() -> CMsgGCCStrike15_v2_AcknowledgePenalty {
        ::std::default::Default::default()
    }

    // optional int32 acknowledged = 1;


    pub fn get_acknowledged(&self) -> i32 {
        self.acknowledged.unwrap_or(0)
    }
    pub fn clear_acknowledged(&mut self) {
        self.acknowledged = ::std::option::Option::None;
    }

    pub fn has_acknowledged(&self) -> bool {
        self.acknowledged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acknowledged(&mut self, v: i32) {
        self.acknowledged = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.acknowledged = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.acknowledged {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.acknowledged {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_AcknowledgePenalty {
        CMsgGCCStrike15_v2_AcknowledgePenalty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "acknowledged",
                    |m: &CMsgGCCStrike15_v2_AcknowledgePenalty| { &m.acknowledged },
                    |m: &mut CMsgGCCStrike15_v2_AcknowledgePenalty| { &mut m.acknowledged },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_AcknowledgePenalty>(
                    "CMsgGCCStrike15_v2_AcknowledgePenalty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_AcknowledgePenalty {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_AcknowledgePenalty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_AcknowledgePenalty,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_AcknowledgePenalty::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn clear(&mut self) {
        self.acknowledged = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    // message fields
    defindex: ::std::option::Option<u32>,
    upgradeid: ::std::option::Option<u64>,
    hours: ::std::option::Option<u32>,
    prestigetime: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        <CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        ::std::default::Default::default()
    }

    // optional uint32 defindex = 1;


    pub fn get_defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }
    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint64 upgradeid = 2;


    pub fn get_upgradeid(&self) -> u64 {
        self.upgradeid.unwrap_or(0)
    }
    pub fn clear_upgradeid(&mut self) {
        self.upgradeid = ::std::option::Option::None;
    }

    pub fn has_upgradeid(&self) -> bool {
        self.upgradeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgradeid(&mut self, v: u64) {
        self.upgradeid = ::std::option::Option::Some(v);
    }

    // optional uint32 hours = 3;


    pub fn get_hours(&self) -> u32 {
        self.hours.unwrap_or(0)
    }
    pub fn clear_hours(&mut self) {
        self.hours = ::std::option::Option::None;
    }

    pub fn has_hours(&self) -> bool {
        self.hours.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hours(&mut self, v: u32) {
        self.hours = ::std::option::Option::Some(v);
    }

    // optional uint32 prestigetime = 4;


    pub fn get_prestigetime(&self) -> u32 {
        self.prestigetime.unwrap_or(0)
    }
    pub fn clear_prestigetime(&mut self) {
        self.prestigetime = ::std::option::Option::None;
    }

    pub fn has_prestigetime(&self) -> bool {
        self.prestigetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prestigetime(&mut self, v: u32) {
        self.prestigetime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.upgradeid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hours = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prestigetime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.upgradeid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hours {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prestigetime {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.upgradeid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.hours {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.prestigetime {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "defindex",
                    |m: &CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &m.defindex },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &mut m.defindex },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "upgradeid",
                    |m: &CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &m.upgradeid },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &mut m.upgradeid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hours",
                    |m: &CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &m.hours },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &mut m.hours },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prestigetime",
                    |m: &CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &m.prestigetime },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &mut m.prestigetime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin>(
                    "CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn clear(&mut self) {
        self.defindex = ::std::option::Option::None;
        self.upgradeid = ::std::option::Option::None;
        self.hours = ::std::option::Option::None;
        self.prestigetime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    // message fields
    ticket: ::std::option::Option<u64>,
    os: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        <CMsgGCCStrike15_v2_Client2GCStreamUnlock as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        ::std::default::Default::default()
    }

    // optional uint64 ticket = 1;


    pub fn get_ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }
    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // optional int32 os = 2;


    pub fn get_os(&self) -> i32 {
        self.os.unwrap_or(0)
    }
    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: i32) {
        self.os = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ticket = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.os = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.os {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.os {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        CMsgGCCStrike15_v2_Client2GCStreamUnlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ticket",
                    |m: &CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &m.ticket },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &mut m.ticket },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "os",
                    |m: &CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &m.os },
                    |m: &mut CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &mut m.os },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Client2GCStreamUnlock>(
                    "CMsgGCCStrike15_v2_Client2GCStreamUnlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Client2GCStreamUnlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Client2GCStreamUnlock,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Client2GCStreamUnlock::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    // message fields
    stage: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        <CMsgGCCStrike15_v2_ClientToGCRequestElevate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    pub fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        ::std::default::Default::default()
    }

    // optional uint32 stage = 1;


    pub fn get_stage(&self) -> u32 {
        self.stage.unwrap_or(0)
    }
    pub fn clear_stage(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_stage(&self) -> bool {
        self.stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: u32) {
        self.stage = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stage = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stage {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stage {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        CMsgGCCStrike15_v2_ClientToGCRequestElevate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stage",
                    |m: &CMsgGCCStrike15_v2_ClientToGCRequestElevate| { &m.stage },
                    |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestElevate| { &mut m.stage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientToGCRequestElevate>(
                    "CMsgGCCStrike15_v2_ClientToGCRequestElevate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientToGCRequestElevate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientToGCRequestElevate,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientToGCRequestElevate::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn clear(&mut self) {
        self.stage = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientToGCChat {
    // message fields
    match_id: ::std::option::Option<u64>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientToGCChat {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientToGCChat {
        <CMsgGCCStrike15_v2_ClientToGCChat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientToGCChat {
    pub fn new() -> CMsgGCCStrike15_v2_ClientToGCChat {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientToGCChat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientToGCChat {
        CMsgGCCStrike15_v2_ClientToGCChat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    |m: &CMsgGCCStrike15_v2_ClientToGCChat| { &m.match_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientToGCChat| { &mut m.match_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CMsgGCCStrike15_v2_ClientToGCChat| { &m.text },
                    |m: &mut CMsgGCCStrike15_v2_ClientToGCChat| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientToGCChat>(
                    "CMsgGCCStrike15_v2_ClientToGCChat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientToGCChat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientToGCChat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientToGCChat,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientToGCChat::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientToGCChat {
    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientToGCChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientToGCChat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GCToClientChat {
    // message fields
    account_id: ::std::option::Option<u32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GCToClientChat {
    fn default() -> &'a CMsgGCCStrike15_v2_GCToClientChat {
        <CMsgGCCStrike15_v2_GCToClientChat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GCToClientChat {
    pub fn new() -> CMsgGCCStrike15_v2_GCToClientChat {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GCToClientChat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_GCToClientChat {
        CMsgGCCStrike15_v2_GCToClientChat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    |m: &CMsgGCCStrike15_v2_GCToClientChat| { &m.account_id },
                    |m: &mut CMsgGCCStrike15_v2_GCToClientChat| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CMsgGCCStrike15_v2_GCToClientChat| { &m.text },
                    |m: &mut CMsgGCCStrike15_v2_GCToClientChat| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GCToClientChat>(
                    "CMsgGCCStrike15_v2_GCToClientChat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GCToClientChat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GCToClientChat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GCToClientChat,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GCToClientChat::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GCToClientChat {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GCToClientChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GCToClientChat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientAuthKeyCode {
    // message fields
    eventid: ::std::option::Option<u32>,
    code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientAuthKeyCode {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientAuthKeyCode {
        <CMsgGCCStrike15_v2_ClientAuthKeyCode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientAuthKeyCode {
    pub fn new() -> CMsgGCCStrike15_v2_ClientAuthKeyCode {
        ::std::default::Default::default()
    }

    // optional uint32 eventid = 1;


    pub fn get_eventid(&self) -> u32 {
        self.eventid.unwrap_or(0)
    }
    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: u32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional string code = 2;


    pub fn get_code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientAuthKeyCode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eventid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientAuthKeyCode {
        CMsgGCCStrike15_v2_ClientAuthKeyCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eventid",
                    |m: &CMsgGCCStrike15_v2_ClientAuthKeyCode| { &m.eventid },
                    |m: &mut CMsgGCCStrike15_v2_ClientAuthKeyCode| { &mut m.eventid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "code",
                    |m: &CMsgGCCStrike15_v2_ClientAuthKeyCode| { &m.code },
                    |m: &mut CMsgGCCStrike15_v2_ClientAuthKeyCode| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientAuthKeyCode>(
                    "CMsgGCCStrike15_v2_ClientAuthKeyCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientAuthKeyCode {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientAuthKeyCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientAuthKeyCode,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientAuthKeyCode::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientAuthKeyCode {
    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientAuthKeyCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientAuthKeyCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_GotvSyncPacket {
    // message fields
    data: ::protobuf::SingularPtrField<super::engine_gcmessages::CEngineGotvSyncPacket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_GotvSyncPacket {
    fn default() -> &'a CMsgGCCStrike15_GotvSyncPacket {
        <CMsgGCCStrike15_GotvSyncPacket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_GotvSyncPacket {
    pub fn new() -> CMsgGCCStrike15_GotvSyncPacket {
        ::std::default::Default::default()
    }

    // optional .CEngineGotvSyncPacket data = 1;


    pub fn get_data(&self) -> &super::engine_gcmessages::CEngineGotvSyncPacket {
        self.data.as_ref().unwrap_or_else(|| super::engine_gcmessages::CEngineGotvSyncPacket::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::engine_gcmessages::CEngineGotvSyncPacket) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::engine_gcmessages::CEngineGotvSyncPacket {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::engine_gcmessages::CEngineGotvSyncPacket {
        self.data.take().unwrap_or_else(|| super::engine_gcmessages::CEngineGotvSyncPacket::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_GotvSyncPacket {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_GotvSyncPacket {
        CMsgGCCStrike15_GotvSyncPacket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::engine_gcmessages::CEngineGotvSyncPacket>>(
                    "data",
                    |m: &CMsgGCCStrike15_GotvSyncPacket| { &m.data },
                    |m: &mut CMsgGCCStrike15_GotvSyncPacket| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_GotvSyncPacket>(
                    "CMsgGCCStrike15_GotvSyncPacket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_GotvSyncPacket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_GotvSyncPacket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_GotvSyncPacket,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_GotvSyncPacket::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_GotvSyncPacket {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_GotvSyncPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_GotvSyncPacket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlayerDecalDigitalSignature {
    // message fields
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    accountid: ::std::option::Option<u32>,
    rtime: ::std::option::Option<u32>,
    endpos: ::std::vec::Vec<f32>,
    startpos: ::std::vec::Vec<f32>,
    right: ::std::vec::Vec<f32>,
    tx_defidx: ::std::option::Option<u32>,
    entindex: ::std::option::Option<i32>,
    hitbox: ::std::option::Option<u32>,
    creationtime: ::std::option::Option<f32>,
    equipslot: ::std::option::Option<u32>,
    trace_id: ::std::option::Option<u32>,
    normal: ::std::vec::Vec<f32>,
    tint_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayerDecalDigitalSignature {
    fn default() -> &'a PlayerDecalDigitalSignature {
        <PlayerDecalDigitalSignature as ::protobuf::Message>::default_instance()
    }
}

impl PlayerDecalDigitalSignature {
    pub fn new() -> PlayerDecalDigitalSignature {
        ::std::default::Default::default()
    }

    // optional bytes signature = 1;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 accountid = 2;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime = 3;


    pub fn get_rtime(&self) -> u32 {
        self.rtime.unwrap_or(0)
    }
    pub fn clear_rtime(&mut self) {
        self.rtime = ::std::option::Option::None;
    }

    pub fn has_rtime(&self) -> bool {
        self.rtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime(&mut self, v: u32) {
        self.rtime = ::std::option::Option::Some(v);
    }

    // repeated float endpos = 4;


    pub fn get_endpos(&self) -> &[f32] {
        &self.endpos
    }
    pub fn clear_endpos(&mut self) {
        self.endpos.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpos(&mut self, v: ::std::vec::Vec<f32>) {
        self.endpos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpos(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.endpos
    }

    // Take field
    pub fn take_endpos(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.endpos, ::std::vec::Vec::new())
    }

    // repeated float startpos = 5;


    pub fn get_startpos(&self) -> &[f32] {
        &self.startpos
    }
    pub fn clear_startpos(&mut self) {
        self.startpos.clear();
    }

    // Param is passed by value, moved
    pub fn set_startpos(&mut self, v: ::std::vec::Vec<f32>) {
        self.startpos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_startpos(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.startpos
    }

    // Take field
    pub fn take_startpos(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.startpos, ::std::vec::Vec::new())
    }

    // repeated float right = 6;


    pub fn get_right(&self) -> &[f32] {
        &self.right
    }
    pub fn clear_right(&mut self) {
        self.right.clear();
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: ::std::vec::Vec<f32>) {
        self.right = v;
    }

    // Mutable pointer to the field.
    pub fn mut_right(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.right
    }

    // Take field
    pub fn take_right(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.right, ::std::vec::Vec::new())
    }

    // optional uint32 tx_defidx = 7;


    pub fn get_tx_defidx(&self) -> u32 {
        self.tx_defidx.unwrap_or(0)
    }
    pub fn clear_tx_defidx(&mut self) {
        self.tx_defidx = ::std::option::Option::None;
    }

    pub fn has_tx_defidx(&self) -> bool {
        self.tx_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_defidx(&mut self, v: u32) {
        self.tx_defidx = ::std::option::Option::Some(v);
    }

    // optional int32 entindex = 8;


    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }
    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 hitbox = 9;


    pub fn get_hitbox(&self) -> u32 {
        self.hitbox.unwrap_or(0)
    }
    pub fn clear_hitbox(&mut self) {
        self.hitbox = ::std::option::Option::None;
    }

    pub fn has_hitbox(&self) -> bool {
        self.hitbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hitbox(&mut self, v: u32) {
        self.hitbox = ::std::option::Option::Some(v);
    }

    // optional float creationtime = 10;


    pub fn get_creationtime(&self) -> f32 {
        self.creationtime.unwrap_or(0.)
    }
    pub fn clear_creationtime(&mut self) {
        self.creationtime = ::std::option::Option::None;
    }

    pub fn has_creationtime(&self) -> bool {
        self.creationtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationtime(&mut self, v: f32) {
        self.creationtime = ::std::option::Option::Some(v);
    }

    // optional uint32 equipslot = 11;


    pub fn get_equipslot(&self) -> u32 {
        self.equipslot.unwrap_or(0)
    }
    pub fn clear_equipslot(&mut self) {
        self.equipslot = ::std::option::Option::None;
    }

    pub fn has_equipslot(&self) -> bool {
        self.equipslot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_equipslot(&mut self, v: u32) {
        self.equipslot = ::std::option::Option::Some(v);
    }

    // optional uint32 trace_id = 12;


    pub fn get_trace_id(&self) -> u32 {
        self.trace_id.unwrap_or(0)
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id = ::std::option::Option::None;
    }

    pub fn has_trace_id(&self) -> bool {
        self.trace_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: u32) {
        self.trace_id = ::std::option::Option::Some(v);
    }

    // repeated float normal = 13;


    pub fn get_normal(&self) -> &[f32] {
        &self.normal
    }
    pub fn clear_normal(&mut self) {
        self.normal.clear();
    }

    // Param is passed by value, moved
    pub fn set_normal(&mut self, v: ::std::vec::Vec<f32>) {
        self.normal = v;
    }

    // Mutable pointer to the field.
    pub fn mut_normal(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.normal
    }

    // Take field
    pub fn take_normal(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.normal, ::std::vec::Vec::new())
    }

    // optional uint32 tint_id = 14;


    pub fn get_tint_id(&self) -> u32 {
        self.tint_id.unwrap_or(0)
    }
    pub fn clear_tint_id(&mut self) {
        self.tint_id = ::std::option::Option::None;
    }

    pub fn has_tint_id(&self) -> bool {
        self.tint_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tint_id(&mut self, v: u32) {
        self.tint_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PlayerDecalDigitalSignature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.endpos)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.startpos)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.right)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tx_defidx = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hitbox = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.creationtime = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.equipslot = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trace_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.normal)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tint_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.endpos.len() as u32;
        my_size += 5 * self.startpos.len() as u32;
        my_size += 5 * self.right.len() as u32;
        if let Some(v) = self.tx_defidx {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hitbox {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creationtime {
            my_size += 5;
        }
        if let Some(v) = self.equipslot {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trace_id {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.normal.len() as u32;
        if let Some(v) = self.tint_id {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rtime {
            os.write_uint32(3, v)?;
        }
        for v in &self.endpos {
            os.write_float(4, *v)?;
        };
        for v in &self.startpos {
            os.write_float(5, *v)?;
        };
        for v in &self.right {
            os.write_float(6, *v)?;
        };
        if let Some(v) = self.tx_defidx {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.hitbox {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.creationtime {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.equipslot {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.trace_id {
            os.write_uint32(12, v)?;
        }
        for v in &self.normal {
            os.write_float(13, *v)?;
        };
        if let Some(v) = self.tint_id {
            os.write_uint32(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayerDecalDigitalSignature {
        PlayerDecalDigitalSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "signature",
                    |m: &PlayerDecalDigitalSignature| { &m.signature },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &PlayerDecalDigitalSignature| { &m.accountid },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rtime",
                    |m: &PlayerDecalDigitalSignature| { &m.rtime },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.rtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "endpos",
                    |m: &PlayerDecalDigitalSignature| { &m.endpos },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.endpos },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "startpos",
                    |m: &PlayerDecalDigitalSignature| { &m.startpos },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.startpos },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "right",
                    |m: &PlayerDecalDigitalSignature| { &m.right },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.right },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tx_defidx",
                    |m: &PlayerDecalDigitalSignature| { &m.tx_defidx },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.tx_defidx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entindex",
                    |m: &PlayerDecalDigitalSignature| { &m.entindex },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.entindex },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hitbox",
                    |m: &PlayerDecalDigitalSignature| { &m.hitbox },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.hitbox },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "creationtime",
                    |m: &PlayerDecalDigitalSignature| { &m.creationtime },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.creationtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "equipslot",
                    |m: &PlayerDecalDigitalSignature| { &m.equipslot },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.equipslot },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trace_id",
                    |m: &PlayerDecalDigitalSignature| { &m.trace_id },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.trace_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "normal",
                    |m: &PlayerDecalDigitalSignature| { &m.normal },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.normal },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tint_id",
                    |m: &PlayerDecalDigitalSignature| { &m.tint_id },
                    |m: &mut PlayerDecalDigitalSignature| { &mut m.tint_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerDecalDigitalSignature>(
                    "PlayerDecalDigitalSignature",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlayerDecalDigitalSignature {
        static mut instance: ::protobuf::lazy::Lazy<PlayerDecalDigitalSignature> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlayerDecalDigitalSignature,
        };
        unsafe {
            instance.get(PlayerDecalDigitalSignature::new)
        }
    }
}

impl ::protobuf::Clear for PlayerDecalDigitalSignature {
    fn clear(&mut self) {
        self.signature.clear();
        self.accountid = ::std::option::Option::None;
        self.rtime = ::std::option::Option::None;
        self.endpos.clear();
        self.startpos.clear();
        self.right.clear();
        self.tx_defidx = ::std::option::Option::None;
        self.entindex = ::std::option::Option::None;
        self.hitbox = ::std::option::Option::None;
        self.creationtime = ::std::option::Option::None;
        self.equipslot = ::std::option::Option::None;
        self.trace_id = ::std::option::Option::None;
        self.normal.clear();
        self.tint_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayerDecalDigitalSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerDecalDigitalSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    // message fields
    data: ::protobuf::SingularPtrField<PlayerDecalDigitalSignature>,
    itemid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientPlayerDecalSign {
        <CMsgGCCStrike15_v2_ClientPlayerDecalSign as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    pub fn new() -> CMsgGCCStrike15_v2_ClientPlayerDecalSign {
        ::std::default::Default::default()
    }

    // optional .PlayerDecalDigitalSignature data = 1;


    pub fn get_data(&self) -> &PlayerDecalDigitalSignature {
        self.data.as_ref().unwrap_or_else(|| PlayerDecalDigitalSignature::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: PlayerDecalDigitalSignature) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut PlayerDecalDigitalSignature {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> PlayerDecalDigitalSignature {
        self.data.take().unwrap_or_else(|| PlayerDecalDigitalSignature::new())
    }

    // optional uint64 itemid = 2;


    pub fn get_itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }
    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.itemid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientPlayerDecalSign {
        CMsgGCCStrike15_v2_ClientPlayerDecalSign::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayerDecalDigitalSignature>>(
                    "data",
                    |m: &CMsgGCCStrike15_v2_ClientPlayerDecalSign| { &m.data },
                    |m: &mut CMsgGCCStrike15_v2_ClientPlayerDecalSign| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "itemid",
                    |m: &CMsgGCCStrike15_v2_ClientPlayerDecalSign| { &m.itemid },
                    |m: &mut CMsgGCCStrike15_v2_ClientPlayerDecalSign| { &mut m.itemid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientPlayerDecalSign>(
                    "CMsgGCCStrike15_v2_ClientPlayerDecalSign",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientPlayerDecalSign {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientPlayerDecalSign> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientPlayerDecalSign,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientPlayerDecalSign::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    fn clear(&mut self) {
        self.data.clear();
        self.itemid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientLogonFatalError {
    // message fields
    errorcode: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    country: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientLogonFatalError {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientLogonFatalError {
        <CMsgGCCStrike15_v2_ClientLogonFatalError as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientLogonFatalError {
    pub fn new() -> CMsgGCCStrike15_v2_ClientLogonFatalError {
        ::std::default::Default::default()
    }

    // optional uint32 errorcode = 1;


    pub fn get_errorcode(&self) -> u32 {
        self.errorcode.unwrap_or(0)
    }
    pub fn clear_errorcode(&mut self) {
        self.errorcode = ::std::option::Option::None;
    }

    pub fn has_errorcode(&self) -> bool {
        self.errorcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorcode(&mut self, v: u32) {
        self.errorcode = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country = 3;


    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country.set_default();
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientLogonFatalError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorcode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorcode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorcode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.country.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientLogonFatalError {
        CMsgGCCStrike15_v2_ClientLogonFatalError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "errorcode",
                    |m: &CMsgGCCStrike15_v2_ClientLogonFatalError| { &m.errorcode },
                    |m: &mut CMsgGCCStrike15_v2_ClientLogonFatalError| { &mut m.errorcode },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CMsgGCCStrike15_v2_ClientLogonFatalError| { &m.message },
                    |m: &mut CMsgGCCStrike15_v2_ClientLogonFatalError| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "country",
                    |m: &CMsgGCCStrike15_v2_ClientLogonFatalError| { &m.country },
                    |m: &mut CMsgGCCStrike15_v2_ClientLogonFatalError| { &mut m.country },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientLogonFatalError>(
                    "CMsgGCCStrike15_v2_ClientLogonFatalError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientLogonFatalError {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientLogonFatalError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientLogonFatalError,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientLogonFatalError::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientLogonFatalError {
    fn clear(&mut self) {
        self.errorcode = ::std::option::Option::None;
        self.message.clear();
        self.country.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientLogonFatalError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientLogonFatalError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientPollState {
    // message fields
    pollid: ::std::option::Option<u32>,
    names: ::protobuf::RepeatedField<::std::string::String>,
    values: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientPollState {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientPollState {
        <CMsgGCCStrike15_v2_ClientPollState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientPollState {
    pub fn new() -> CMsgGCCStrike15_v2_ClientPollState {
        ::std::default::Default::default()
    }

    // optional uint32 pollid = 1;


    pub fn get_pollid(&self) -> u32 {
        self.pollid.unwrap_or(0)
    }
    pub fn clear_pollid(&mut self) {
        self.pollid = ::std::option::Option::None;
    }

    pub fn has_pollid(&self) -> bool {
        self.pollid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pollid(&mut self, v: u32) {
        self.pollid = ::std::option::Option::Some(v);
    }

    // repeated string names = 2;


    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }

    // repeated int32 values = 3;


    pub fn get_values(&self) -> &[i32] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::vec::Vec<i32>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.values, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientPollState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pollid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pollid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.values {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pollid {
            os.write_uint32(1, v)?;
        }
        for v in &self.names {
            os.write_string(2, &v)?;
        };
        for v in &self.values {
            os.write_int32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientPollState {
        CMsgGCCStrike15_v2_ClientPollState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pollid",
                    |m: &CMsgGCCStrike15_v2_ClientPollState| { &m.pollid },
                    |m: &mut CMsgGCCStrike15_v2_ClientPollState| { &mut m.pollid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "names",
                    |m: &CMsgGCCStrike15_v2_ClientPollState| { &m.names },
                    |m: &mut CMsgGCCStrike15_v2_ClientPollState| { &mut m.names },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "values",
                    |m: &CMsgGCCStrike15_v2_ClientPollState| { &m.values },
                    |m: &mut CMsgGCCStrike15_v2_ClientPollState| { &mut m.values },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientPollState>(
                    "CMsgGCCStrike15_v2_ClientPollState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientPollState {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientPollState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientPollState,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientPollState::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientPollState {
    fn clear(&mut self) {
        self.pollid = ::std::option::Option::None;
        self.names.clear();
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientPollState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientPollState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Party_Register {
    // message fields
    id: ::std::option::Option<u32>,
    ver: ::std::option::Option<u32>,
    apr: ::std::option::Option<u32>,
    ark: ::std::option::Option<u32>,
    nby: ::std::option::Option<u32>,
    grp: ::std::option::Option<u32>,
    slots: ::std::option::Option<u32>,
    launcher: ::std::option::Option<u32>,
    game_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Party_Register {
    fn default() -> &'a CMsgGCCStrike15_v2_Party_Register {
        <CMsgGCCStrike15_v2_Party_Register as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Party_Register {
    pub fn new() -> CMsgGCCStrike15_v2_Party_Register {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 ver = 2;


    pub fn get_ver(&self) -> u32 {
        self.ver.unwrap_or(0)
    }
    pub fn clear_ver(&mut self) {
        self.ver = ::std::option::Option::None;
    }

    pub fn has_ver(&self) -> bool {
        self.ver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ver(&mut self, v: u32) {
        self.ver = ::std::option::Option::Some(v);
    }

    // optional uint32 apr = 3;


    pub fn get_apr(&self) -> u32 {
        self.apr.unwrap_or(0)
    }
    pub fn clear_apr(&mut self) {
        self.apr = ::std::option::Option::None;
    }

    pub fn has_apr(&self) -> bool {
        self.apr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apr(&mut self, v: u32) {
        self.apr = ::std::option::Option::Some(v);
    }

    // optional uint32 ark = 4;


    pub fn get_ark(&self) -> u32 {
        self.ark.unwrap_or(0)
    }
    pub fn clear_ark(&mut self) {
        self.ark = ::std::option::Option::None;
    }

    pub fn has_ark(&self) -> bool {
        self.ark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ark(&mut self, v: u32) {
        self.ark = ::std::option::Option::Some(v);
    }

    // optional uint32 nby = 5;


    pub fn get_nby(&self) -> u32 {
        self.nby.unwrap_or(0)
    }
    pub fn clear_nby(&mut self) {
        self.nby = ::std::option::Option::None;
    }

    pub fn has_nby(&self) -> bool {
        self.nby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nby(&mut self, v: u32) {
        self.nby = ::std::option::Option::Some(v);
    }

    // optional uint32 grp = 6;


    pub fn get_grp(&self) -> u32 {
        self.grp.unwrap_or(0)
    }
    pub fn clear_grp(&mut self) {
        self.grp = ::std::option::Option::None;
    }

    pub fn has_grp(&self) -> bool {
        self.grp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grp(&mut self, v: u32) {
        self.grp = ::std::option::Option::Some(v);
    }

    // optional uint32 slots = 7;


    pub fn get_slots(&self) -> u32 {
        self.slots.unwrap_or(0)
    }
    pub fn clear_slots(&mut self) {
        self.slots = ::std::option::Option::None;
    }

    pub fn has_slots(&self) -> bool {
        self.slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots(&mut self, v: u32) {
        self.slots = ::std::option::Option::Some(v);
    }

    // optional uint32 launcher = 8;


    pub fn get_launcher(&self) -> u32 {
        self.launcher.unwrap_or(0)
    }
    pub fn clear_launcher(&mut self) {
        self.launcher = ::std::option::Option::None;
    }

    pub fn has_launcher(&self) -> bool {
        self.launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launcher(&mut self, v: u32) {
        self.launcher = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 9;


    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }
    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Party_Register {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ver = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.apr = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ark = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nby = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.grp = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slots = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.launcher = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ver {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.apr {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ark {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nby {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.grp {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slots {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.launcher {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ver {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.apr {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ark {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.nby {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.grp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.slots {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.launcher {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Party_Register {
        CMsgGCCStrike15_v2_Party_Register::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    |m: &CMsgGCCStrike15_v2_Party_Register| { &m.id },
                    |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ver",
                    |m: &CMsgGCCStrike15_v2_Party_Register| { &m.ver },
                    |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.ver },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "apr",
                    |m: &CMsgGCCStrike15_v2_Party_Register| { &m.apr },
                    |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.apr },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ark",
                    |m: &CMsgGCCStrike15_v2_Party_Register| { &m.ark },
                    |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.ark },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "nby",
                    |m: &CMsgGCCStrike15_v2_Party_Register| { &m.nby },
                    |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.nby },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "grp",
                    |m: &CMsgGCCStrike15_v2_Party_Register| { &m.grp },
                    |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.grp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slots",
                    |m: &CMsgGCCStrike15_v2_Party_Register| { &m.slots },
                    |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.slots },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "launcher",
                    |m: &CMsgGCCStrike15_v2_Party_Register| { &m.launcher },
                    |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.launcher },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    |m: &CMsgGCCStrike15_v2_Party_Register| { &m.game_type },
                    |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.game_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Party_Register>(
                    "CMsgGCCStrike15_v2_Party_Register",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Party_Register {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Party_Register> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Party_Register,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Party_Register::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Party_Register {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.ver = ::std::option::Option::None;
        self.apr = ::std::option::Option::None;
        self.ark = ::std::option::Option::None;
        self.nby = ::std::option::Option::None;
        self.grp = ::std::option::Option::None;
        self.slots = ::std::option::Option::None;
        self.launcher = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Party_Register {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Party_Register {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Party_Search {
    // message fields
    ver: ::std::option::Option<u32>,
    apr: ::std::option::Option<u32>,
    ark: ::std::option::Option<u32>,
    grps: ::std::vec::Vec<u32>,
    launcher: ::std::option::Option<u32>,
    game_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Party_Search {
    fn default() -> &'a CMsgGCCStrike15_v2_Party_Search {
        <CMsgGCCStrike15_v2_Party_Search as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Party_Search {
    pub fn new() -> CMsgGCCStrike15_v2_Party_Search {
        ::std::default::Default::default()
    }

    // optional uint32 ver = 1;


    pub fn get_ver(&self) -> u32 {
        self.ver.unwrap_or(0)
    }
    pub fn clear_ver(&mut self) {
        self.ver = ::std::option::Option::None;
    }

    pub fn has_ver(&self) -> bool {
        self.ver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ver(&mut self, v: u32) {
        self.ver = ::std::option::Option::Some(v);
    }

    // optional uint32 apr = 2;


    pub fn get_apr(&self) -> u32 {
        self.apr.unwrap_or(0)
    }
    pub fn clear_apr(&mut self) {
        self.apr = ::std::option::Option::None;
    }

    pub fn has_apr(&self) -> bool {
        self.apr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apr(&mut self, v: u32) {
        self.apr = ::std::option::Option::Some(v);
    }

    // optional uint32 ark = 3;


    pub fn get_ark(&self) -> u32 {
        self.ark.unwrap_or(0)
    }
    pub fn clear_ark(&mut self) {
        self.ark = ::std::option::Option::None;
    }

    pub fn has_ark(&self) -> bool {
        self.ark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ark(&mut self, v: u32) {
        self.ark = ::std::option::Option::Some(v);
    }

    // repeated uint32 grps = 4;


    pub fn get_grps(&self) -> &[u32] {
        &self.grps
    }
    pub fn clear_grps(&mut self) {
        self.grps.clear();
    }

    // Param is passed by value, moved
    pub fn set_grps(&mut self, v: ::std::vec::Vec<u32>) {
        self.grps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_grps(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.grps
    }

    // Take field
    pub fn take_grps(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.grps, ::std::vec::Vec::new())
    }

    // optional uint32 launcher = 5;


    pub fn get_launcher(&self) -> u32 {
        self.launcher.unwrap_or(0)
    }
    pub fn clear_launcher(&mut self) {
        self.launcher = ::std::option::Option::None;
    }

    pub fn has_launcher(&self) -> bool {
        self.launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launcher(&mut self, v: u32) {
        self.launcher = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 6;


    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }
    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Party_Search {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ver = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.apr = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ark = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.grps)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.launcher = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ver {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.apr {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ark {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.grps {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.launcher {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ver {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.apr {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ark {
            os.write_uint32(3, v)?;
        }
        for v in &self.grps {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.launcher {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Party_Search {
        CMsgGCCStrike15_v2_Party_Search::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ver",
                    |m: &CMsgGCCStrike15_v2_Party_Search| { &m.ver },
                    |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.ver },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "apr",
                    |m: &CMsgGCCStrike15_v2_Party_Search| { &m.apr },
                    |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.apr },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ark",
                    |m: &CMsgGCCStrike15_v2_Party_Search| { &m.ark },
                    |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.ark },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "grps",
                    |m: &CMsgGCCStrike15_v2_Party_Search| { &m.grps },
                    |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.grps },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "launcher",
                    |m: &CMsgGCCStrike15_v2_Party_Search| { &m.launcher },
                    |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.launcher },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    |m: &CMsgGCCStrike15_v2_Party_Search| { &m.game_type },
                    |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.game_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Party_Search>(
                    "CMsgGCCStrike15_v2_Party_Search",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Party_Search {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Party_Search> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Party_Search,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Party_Search::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Party_Search {
    fn clear(&mut self) {
        self.ver = ::std::option::Option::None;
        self.apr = ::std::option::Option::None;
        self.ark = ::std::option::Option::None;
        self.grps.clear();
        self.launcher = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Party_Search {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Party_Search {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Party_SearchResults {
    // message fields
    entries: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Party_SearchResults_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Party_SearchResults {
    fn default() -> &'a CMsgGCCStrike15_v2_Party_SearchResults {
        <CMsgGCCStrike15_v2_Party_SearchResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Party_SearchResults {
    pub fn new() -> CMsgGCCStrike15_v2_Party_SearchResults {
        ::std::default::Default::default()
    }

    // repeated .CMsgGCCStrike15_v2_Party_SearchResults.Entry entries = 1;


    pub fn get_entries(&self) -> &[CMsgGCCStrike15_v2_Party_SearchResults_Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Party_SearchResults_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Party_SearchResults_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Party_SearchResults_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Party_SearchResults {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Party_SearchResults {
        CMsgGCCStrike15_v2_Party_SearchResults::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_Party_SearchResults_Entry>>(
                    "entries",
                    |m: &CMsgGCCStrike15_v2_Party_SearchResults| { &m.entries },
                    |m: &mut CMsgGCCStrike15_v2_Party_SearchResults| { &mut m.entries },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Party_SearchResults>(
                    "CMsgGCCStrike15_v2_Party_SearchResults",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Party_SearchResults {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Party_SearchResults> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Party_SearchResults,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Party_SearchResults::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Party_SearchResults {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Party_SearchResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Party_SearchResults {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Party_SearchResults_Entry {
    // message fields
    id: ::std::option::Option<u32>,
    grp: ::std::option::Option<u32>,
    game_type: ::std::option::Option<u32>,
    apr: ::std::option::Option<u32>,
    ark: ::std::option::Option<u32>,
    loc: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Party_SearchResults_Entry {
    fn default() -> &'a CMsgGCCStrike15_v2_Party_SearchResults_Entry {
        <CMsgGCCStrike15_v2_Party_SearchResults_Entry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Party_SearchResults_Entry {
    pub fn new() -> CMsgGCCStrike15_v2_Party_SearchResults_Entry {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 grp = 2;


    pub fn get_grp(&self) -> u32 {
        self.grp.unwrap_or(0)
    }
    pub fn clear_grp(&mut self) {
        self.grp = ::std::option::Option::None;
    }

    pub fn has_grp(&self) -> bool {
        self.grp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grp(&mut self, v: u32) {
        self.grp = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 3;


    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }
    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional uint32 apr = 4;


    pub fn get_apr(&self) -> u32 {
        self.apr.unwrap_or(0)
    }
    pub fn clear_apr(&mut self) {
        self.apr = ::std::option::Option::None;
    }

    pub fn has_apr(&self) -> bool {
        self.apr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apr(&mut self, v: u32) {
        self.apr = ::std::option::Option::Some(v);
    }

    // optional uint32 ark = 5;


    pub fn get_ark(&self) -> u32 {
        self.ark.unwrap_or(0)
    }
    pub fn clear_ark(&mut self) {
        self.ark = ::std::option::Option::None;
    }

    pub fn has_ark(&self) -> bool {
        self.ark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ark(&mut self, v: u32) {
        self.ark = ::std::option::Option::Some(v);
    }

    // optional uint32 loc = 6;


    pub fn get_loc(&self) -> u32 {
        self.loc.unwrap_or(0)
    }
    pub fn clear_loc(&mut self) {
        self.loc = ::std::option::Option::None;
    }

    pub fn has_loc(&self) -> bool {
        self.loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc(&mut self, v: u32) {
        self.loc = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Party_SearchResults_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.grp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.apr = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ark = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.loc = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.grp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.apr {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ark {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.loc {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.grp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.apr {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ark {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.loc {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Party_SearchResults_Entry {
        CMsgGCCStrike15_v2_Party_SearchResults_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    |m: &CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &m.id },
                    |m: &mut CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "grp",
                    |m: &CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &m.grp },
                    |m: &mut CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &mut m.grp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_type",
                    |m: &CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &m.game_type },
                    |m: &mut CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &mut m.game_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "apr",
                    |m: &CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &m.apr },
                    |m: &mut CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &mut m.apr },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ark",
                    |m: &CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &m.ark },
                    |m: &mut CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &mut m.ark },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "loc",
                    |m: &CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &m.loc },
                    |m: &mut CMsgGCCStrike15_v2_Party_SearchResults_Entry| { &mut m.loc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Party_SearchResults_Entry>(
                    "CMsgGCCStrike15_v2_Party_SearchResults_Entry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Party_SearchResults_Entry {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Party_SearchResults_Entry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Party_SearchResults_Entry,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Party_SearchResults_Entry::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Party_SearchResults_Entry {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.grp = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.apr = ::std::option::Option::None;
        self.ark = ::std::option::Option::None;
        self.loc = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Party_SearchResults_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Party_SearchResults_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Party_Invite {
    // message fields
    accountid: ::std::option::Option<u32>,
    lobbyid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Party_Invite {
    fn default() -> &'a CMsgGCCStrike15_v2_Party_Invite {
        <CMsgGCCStrike15_v2_Party_Invite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Party_Invite {
    pub fn new() -> CMsgGCCStrike15_v2_Party_Invite {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 lobbyid = 2;


    pub fn get_lobbyid(&self) -> u32 {
        self.lobbyid.unwrap_or(0)
    }
    pub fn clear_lobbyid(&mut self) {
        self.lobbyid = ::std::option::Option::None;
    }

    pub fn has_lobbyid(&self) -> bool {
        self.lobbyid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobbyid(&mut self, v: u32) {
        self.lobbyid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Party_Invite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lobbyid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobbyid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lobbyid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Party_Invite {
        CMsgGCCStrike15_v2_Party_Invite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_Party_Invite| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_Party_Invite| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lobbyid",
                    |m: &CMsgGCCStrike15_v2_Party_Invite| { &m.lobbyid },
                    |m: &mut CMsgGCCStrike15_v2_Party_Invite| { &mut m.lobbyid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Party_Invite>(
                    "CMsgGCCStrike15_v2_Party_Invite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Party_Invite {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Party_Invite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Party_Invite,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Party_Invite::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Party_Invite {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.lobbyid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Party_Invite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Party_Invite {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Account_RequestCoPlays {
    // message fields
    players: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Account_RequestCoPlays_Player>,
    servertime: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Account_RequestCoPlays {
    fn default() -> &'a CMsgGCCStrike15_v2_Account_RequestCoPlays {
        <CMsgGCCStrike15_v2_Account_RequestCoPlays as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Account_RequestCoPlays {
    pub fn new() -> CMsgGCCStrike15_v2_Account_RequestCoPlays {
        ::std::default::Default::default()
    }

    // repeated .CMsgGCCStrike15_v2_Account_RequestCoPlays.Player players = 1;


    pub fn get_players(&self) -> &[CMsgGCCStrike15_v2_Account_RequestCoPlays_Player] {
        &self.players
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Account_RequestCoPlays_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Account_RequestCoPlays_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_Account_RequestCoPlays_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    // optional uint32 servertime = 2;


    pub fn get_servertime(&self) -> u32 {
        self.servertime.unwrap_or(0)
    }
    pub fn clear_servertime(&mut self) {
        self.servertime = ::std::option::Option::None;
    }

    pub fn has_servertime(&self) -> bool {
        self.servertime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servertime(&mut self, v: u32) {
        self.servertime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Account_RequestCoPlays {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.servertime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.servertime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.servertime {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Account_RequestCoPlays {
        CMsgGCCStrike15_v2_Account_RequestCoPlays::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_Account_RequestCoPlays_Player>>(
                    "players",
                    |m: &CMsgGCCStrike15_v2_Account_RequestCoPlays| { &m.players },
                    |m: &mut CMsgGCCStrike15_v2_Account_RequestCoPlays| { &mut m.players },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "servertime",
                    |m: &CMsgGCCStrike15_v2_Account_RequestCoPlays| { &m.servertime },
                    |m: &mut CMsgGCCStrike15_v2_Account_RequestCoPlays| { &mut m.servertime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Account_RequestCoPlays>(
                    "CMsgGCCStrike15_v2_Account_RequestCoPlays",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Account_RequestCoPlays {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Account_RequestCoPlays> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Account_RequestCoPlays,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Account_RequestCoPlays::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Account_RequestCoPlays {
    fn clear(&mut self) {
        self.players.clear();
        self.servertime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Account_RequestCoPlays {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Account_RequestCoPlays {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
    // message fields
    accountid: ::std::option::Option<u32>,
    rtcoplay: ::std::option::Option<u32>,
    online: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
    fn default() -> &'a CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
        <CMsgGCCStrike15_v2_Account_RequestCoPlays_Player as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
    pub fn new() -> CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtcoplay = 2;


    pub fn get_rtcoplay(&self) -> u32 {
        self.rtcoplay.unwrap_or(0)
    }
    pub fn clear_rtcoplay(&mut self) {
        self.rtcoplay = ::std::option::Option::None;
    }

    pub fn has_rtcoplay(&self) -> bool {
        self.rtcoplay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtcoplay(&mut self, v: u32) {
        self.rtcoplay = ::std::option::Option::Some(v);
    }

    // optional bool online = 3;


    pub fn get_online(&self) -> bool {
        self.online.unwrap_or(false)
    }
    pub fn clear_online(&mut self) {
        self.online = ::std::option::Option::None;
    }

    pub fn has_online(&self) -> bool {
        self.online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online(&mut self, v: bool) {
        self.online = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtcoplay = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.online = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtcoplay {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.online {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rtcoplay {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.online {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
        CMsgGCCStrike15_v2_Account_RequestCoPlays_Player::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_Account_RequestCoPlays_Player| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_Account_RequestCoPlays_Player| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rtcoplay",
                    |m: &CMsgGCCStrike15_v2_Account_RequestCoPlays_Player| { &m.rtcoplay },
                    |m: &mut CMsgGCCStrike15_v2_Account_RequestCoPlays_Player| { &mut m.rtcoplay },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "online",
                    |m: &CMsgGCCStrike15_v2_Account_RequestCoPlays_Player| { &m.online },
                    |m: &mut CMsgGCCStrike15_v2_Account_RequestCoPlays_Player| { &mut m.online },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_Account_RequestCoPlays_Player>(
                    "CMsgGCCStrike15_v2_Account_RequestCoPlays_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_Account_RequestCoPlays_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_Account_RequestCoPlays_Player,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_Account_RequestCoPlays_Player::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.rtcoplay = ::std::option::Option::None;
        self.online = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Account_RequestCoPlays_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    // message fields
    authorized_steam_id: ::std::option::Option<u64>,
    authorized_public_ip: ::std::option::Option<u32>,
    gameserver_steam_id: ::std::option::Option<u64>,
    gameserver_sdr_routing: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientToGCRequestTicket {
        <CMsgGCCStrike15_v2_ClientToGCRequestTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    pub fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestTicket {
        ::std::default::Default::default()
    }

    // optional fixed64 authorized_steam_id = 1;


    pub fn get_authorized_steam_id(&self) -> u64 {
        self.authorized_steam_id.unwrap_or(0)
    }
    pub fn clear_authorized_steam_id(&mut self) {
        self.authorized_steam_id = ::std::option::Option::None;
    }

    pub fn has_authorized_steam_id(&self) -> bool {
        self.authorized_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorized_steam_id(&mut self, v: u64) {
        self.authorized_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 authorized_public_ip = 2;


    pub fn get_authorized_public_ip(&self) -> u32 {
        self.authorized_public_ip.unwrap_or(0)
    }
    pub fn clear_authorized_public_ip(&mut self) {
        self.authorized_public_ip = ::std::option::Option::None;
    }

    pub fn has_authorized_public_ip(&self) -> bool {
        self.authorized_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorized_public_ip(&mut self, v: u32) {
        self.authorized_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameserver_steam_id = 3;


    pub fn get_gameserver_steam_id(&self) -> u64 {
        self.gameserver_steam_id.unwrap_or(0)
    }
    pub fn clear_gameserver_steam_id(&mut self) {
        self.gameserver_steam_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_steam_id(&self) -> bool {
        self.gameserver_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_steam_id(&mut self, v: u64) {
        self.gameserver_steam_id = ::std::option::Option::Some(v);
    }

    // optional string gameserver_sdr_routing = 5;


    pub fn get_gameserver_sdr_routing(&self) -> &str {
        match self.gameserver_sdr_routing.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gameserver_sdr_routing(&mut self) {
        self.gameserver_sdr_routing.clear();
    }

    pub fn has_gameserver_sdr_routing(&self) -> bool {
        self.gameserver_sdr_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_sdr_routing(&mut self, v: ::std::string::String) {
        self.gameserver_sdr_routing = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gameserver_sdr_routing(&mut self) -> &mut ::std::string::String {
        if self.gameserver_sdr_routing.is_none() {
            self.gameserver_sdr_routing.set_default();
        }
        self.gameserver_sdr_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_gameserver_sdr_routing(&mut self) -> ::std::string::String {
        self.gameserver_sdr_routing.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.authorized_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.authorized_public_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.gameserver_steam_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gameserver_sdr_routing)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.authorized_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.authorized_public_ip {
            my_size += 5;
        }
        if let Some(v) = self.gameserver_steam_id {
            my_size += 9;
        }
        if let Some(ref v) = self.gameserver_sdr_routing.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.authorized_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.authorized_public_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.gameserver_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.gameserver_sdr_routing.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestTicket {
        CMsgGCCStrike15_v2_ClientToGCRequestTicket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "authorized_steam_id",
                    |m: &CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &m.authorized_steam_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &mut m.authorized_steam_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "authorized_public_ip",
                    |m: &CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &m.authorized_public_ip },
                    |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &mut m.authorized_public_ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "gameserver_steam_id",
                    |m: &CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &m.gameserver_steam_id },
                    |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &mut m.gameserver_steam_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gameserver_sdr_routing",
                    |m: &CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &m.gameserver_sdr_routing },
                    |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &mut m.gameserver_sdr_routing },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientToGCRequestTicket>(
                    "CMsgGCCStrike15_v2_ClientToGCRequestTicket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientToGCRequestTicket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientToGCRequestTicket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientToGCRequestTicket,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientToGCRequestTicket::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    fn clear(&mut self) {
        self.authorized_steam_id = ::std::option::Option::None;
        self.authorized_public_ip = ::std::option::Option::None;
        self.gameserver_steam_id = ::std::option::Option::None;
        self.gameserver_sdr_routing.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientSteamDatagramTicket {
    // message fields
    serialized_ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientSteamDatagramTicket {
    fn default() -> &'a CMsgGCToClientSteamDatagramTicket {
        <CMsgGCToClientSteamDatagramTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientSteamDatagramTicket {
    pub fn new() -> CMsgGCToClientSteamDatagramTicket {
        ::std::default::Default::default()
    }

    // optional bytes serialized_ticket = 16;


    pub fn get_serialized_ticket(&self) -> &[u8] {
        match self.serialized_ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_serialized_ticket(&mut self) {
        self.serialized_ticket.clear();
    }

    pub fn has_serialized_ticket(&self) -> bool {
        self.serialized_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_ticket.is_none() {
            self.serialized_ticket.set_default();
        }
        self.serialized_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCToClientSteamDatagramTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                16 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serialized_ticket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.serialized_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.serialized_ticket.as_ref() {
            os.write_bytes(16, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToClientSteamDatagramTicket {
        CMsgGCToClientSteamDatagramTicket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "serialized_ticket",
                    |m: &CMsgGCToClientSteamDatagramTicket| { &m.serialized_ticket },
                    |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.serialized_ticket },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientSteamDatagramTicket>(
                    "CMsgGCToClientSteamDatagramTicket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCToClientSteamDatagramTicket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientSteamDatagramTicket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientSteamDatagramTicket,
        };
        unsafe {
            instance.get(CMsgGCToClientSteamDatagramTicket::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientSteamDatagramTicket {
    fn clear(&mut self) {
        self.serialized_ticket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientSteamDatagramTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientSteamDatagramTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientRequestOffers {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestOffers {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestOffers {
        <CMsgGCCStrike15_v2_ClientRequestOffers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestOffers {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestOffers {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestOffers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestOffers {
        CMsgGCCStrike15_v2_ClientRequestOffers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientRequestOffers>(
                    "CMsgGCCStrike15_v2_ClientRequestOffers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestOffers {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientRequestOffers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientRequestOffers,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientRequestOffers::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientRequestOffers {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientRequestOffers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestOffers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientRequestSouvenir {
    // message fields
    itemid: ::std::option::Option<u64>,
    matchid: ::std::option::Option<u64>,
    eventid: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestSouvenir {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestSouvenir {
        <CMsgGCCStrike15_v2_ClientRequestSouvenir as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestSouvenir {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestSouvenir {
        ::std::default::Default::default()
    }

    // optional uint64 itemid = 1;


    pub fn get_itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }
    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    // optional uint64 matchid = 2;


    pub fn get_matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }
    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    // optional int32 eventid = 3;


    pub fn get_eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }
    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestSouvenir {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.matchid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eventid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.itemid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.matchid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.eventid {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestSouvenir {
        CMsgGCCStrike15_v2_ClientRequestSouvenir::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "itemid",
                    |m: &CMsgGCCStrike15_v2_ClientRequestSouvenir| { &m.itemid },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestSouvenir| { &mut m.itemid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "matchid",
                    |m: &CMsgGCCStrike15_v2_ClientRequestSouvenir| { &m.matchid },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestSouvenir| { &mut m.matchid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "eventid",
                    |m: &CMsgGCCStrike15_v2_ClientRequestSouvenir| { &m.eventid },
                    |m: &mut CMsgGCCStrike15_v2_ClientRequestSouvenir| { &mut m.eventid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientRequestSouvenir>(
                    "CMsgGCCStrike15_v2_ClientRequestSouvenir",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestSouvenir {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientRequestSouvenir> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientRequestSouvenir,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientRequestSouvenir::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientRequestSouvenir {
    fn clear(&mut self) {
        self.itemid = ::std::option::Option::None;
        self.matchid = ::std::option::Option::None;
        self.eventid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientRequestSouvenir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestSouvenir {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientAccountBalance {
    // message fields
    amount: ::std::option::Option<u64>,
    url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientAccountBalance {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientAccountBalance {
        <CMsgGCCStrike15_v2_ClientAccountBalance as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientAccountBalance {
    pub fn new() -> CMsgGCCStrike15_v2_ClientAccountBalance {
        ::std::default::Default::default()
    }

    // optional uint64 amount = 1;


    pub fn get_amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientAccountBalance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.amount {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientAccountBalance {
        CMsgGCCStrike15_v2_ClientAccountBalance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "amount",
                    |m: &CMsgGCCStrike15_v2_ClientAccountBalance| { &m.amount },
                    |m: &mut CMsgGCCStrike15_v2_ClientAccountBalance| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgGCCStrike15_v2_ClientAccountBalance| { &m.url },
                    |m: &mut CMsgGCCStrike15_v2_ClientAccountBalance| { &mut m.url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientAccountBalance>(
                    "CMsgGCCStrike15_v2_ClientAccountBalance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientAccountBalance {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientAccountBalance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientAccountBalance,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientAccountBalance::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientAccountBalance {
    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientAccountBalance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientAccountBalance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    // message fields
    accountid: ::std::option::Option<u32>,
    lobbyid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientPartyJoinRelay {
        <CMsgGCCStrike15_v2_ClientPartyJoinRelay as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    pub fn new() -> CMsgGCCStrike15_v2_ClientPartyJoinRelay {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 lobbyid = 2;


    pub fn get_lobbyid(&self) -> u64 {
        self.lobbyid.unwrap_or(0)
    }
    pub fn clear_lobbyid(&mut self) {
        self.lobbyid = ::std::option::Option::None;
    }

    pub fn has_lobbyid(&self) -> bool {
        self.lobbyid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobbyid(&mut self, v: u64) {
        self.lobbyid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lobbyid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobbyid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lobbyid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientPartyJoinRelay {
        CMsgGCCStrike15_v2_ClientPartyJoinRelay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_ClientPartyJoinRelay| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_ClientPartyJoinRelay| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "lobbyid",
                    |m: &CMsgGCCStrike15_v2_ClientPartyJoinRelay| { &m.lobbyid },
                    |m: &mut CMsgGCCStrike15_v2_ClientPartyJoinRelay| { &mut m.lobbyid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientPartyJoinRelay>(
                    "CMsgGCCStrike15_v2_ClientPartyJoinRelay",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientPartyJoinRelay {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientPartyJoinRelay> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientPartyJoinRelay,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientPartyJoinRelay::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.lobbyid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientPartyWarning {
    // message fields
    entries: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_ClientPartyWarning_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientPartyWarning {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientPartyWarning {
        <CMsgGCCStrike15_v2_ClientPartyWarning as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientPartyWarning {
    pub fn new() -> CMsgGCCStrike15_v2_ClientPartyWarning {
        ::std::default::Default::default()
    }

    // repeated .CMsgGCCStrike15_v2_ClientPartyWarning.Entry entries = 1;


    pub fn get_entries(&self) -> &[CMsgGCCStrike15_v2_ClientPartyWarning_Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CMsgGCCStrike15_v2_ClientPartyWarning_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCCStrike15_v2_ClientPartyWarning_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CMsgGCCStrike15_v2_ClientPartyWarning_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientPartyWarning {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientPartyWarning {
        CMsgGCCStrike15_v2_ClientPartyWarning::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCCStrike15_v2_ClientPartyWarning_Entry>>(
                    "entries",
                    |m: &CMsgGCCStrike15_v2_ClientPartyWarning| { &m.entries },
                    |m: &mut CMsgGCCStrike15_v2_ClientPartyWarning| { &mut m.entries },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientPartyWarning>(
                    "CMsgGCCStrike15_v2_ClientPartyWarning",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientPartyWarning {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientPartyWarning> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientPartyWarning,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientPartyWarning::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientPartyWarning {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientPartyWarning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientPartyWarning {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
    // message fields
    accountid: ::std::option::Option<u32>,
    warntype: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
        <CMsgGCCStrike15_v2_ClientPartyWarning_Entry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
    pub fn new() -> CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 warntype = 2;


    pub fn get_warntype(&self) -> u32 {
        self.warntype.unwrap_or(0)
    }
    pub fn clear_warntype(&mut self) {
        self.warntype = ::std::option::Option::None;
    }

    pub fn has_warntype(&self) -> bool {
        self.warntype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_warntype(&mut self, v: u32) {
        self.warntype = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.warntype = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.warntype {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.warntype {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
        CMsgGCCStrike15_v2_ClientPartyWarning_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CMsgGCCStrike15_v2_ClientPartyWarning_Entry| { &m.accountid },
                    |m: &mut CMsgGCCStrike15_v2_ClientPartyWarning_Entry| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "warntype",
                    |m: &CMsgGCCStrike15_v2_ClientPartyWarning_Entry| { &m.warntype },
                    |m: &mut CMsgGCCStrike15_v2_ClientPartyWarning_Entry| { &mut m.warntype },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_ClientPartyWarning_Entry>(
                    "CMsgGCCStrike15_v2_ClientPartyWarning_Entry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_ClientPartyWarning_Entry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_ClientPartyWarning_Entry,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_ClientPartyWarning_Entry::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.warntype = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientPartyWarning_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_SetEventFavorite {
    // message fields
    eventid: ::std::option::Option<u64>,
    is_favorite: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_SetEventFavorite {
    fn default() -> &'a CMsgGCCStrike15_v2_SetEventFavorite {
        <CMsgGCCStrike15_v2_SetEventFavorite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_SetEventFavorite {
    pub fn new() -> CMsgGCCStrike15_v2_SetEventFavorite {
        ::std::default::Default::default()
    }

    // optional uint64 eventid = 1;


    pub fn get_eventid(&self) -> u64 {
        self.eventid.unwrap_or(0)
    }
    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: u64) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional bool is_favorite = 2;


    pub fn get_is_favorite(&self) -> bool {
        self.is_favorite.unwrap_or(false)
    }
    pub fn clear_is_favorite(&mut self) {
        self.is_favorite = ::std::option::Option::None;
    }

    pub fn has_is_favorite(&self) -> bool {
        self.is_favorite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_favorite(&mut self, v: bool) {
        self.is_favorite = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_SetEventFavorite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.eventid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_favorite = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_favorite {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.is_favorite {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_SetEventFavorite {
        CMsgGCCStrike15_v2_SetEventFavorite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "eventid",
                    |m: &CMsgGCCStrike15_v2_SetEventFavorite| { &m.eventid },
                    |m: &mut CMsgGCCStrike15_v2_SetEventFavorite| { &mut m.eventid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_favorite",
                    |m: &CMsgGCCStrike15_v2_SetEventFavorite| { &m.is_favorite },
                    |m: &mut CMsgGCCStrike15_v2_SetEventFavorite| { &mut m.is_favorite },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_SetEventFavorite>(
                    "CMsgGCCStrike15_v2_SetEventFavorite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_SetEventFavorite {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_SetEventFavorite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_SetEventFavorite,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_SetEventFavorite::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_SetEventFavorite {
    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.is_favorite = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_SetEventFavorite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_SetEventFavorite {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GetEventFavorites_Request {
    // message fields
    all_events: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GetEventFavorites_Request {
    fn default() -> &'a CMsgGCCStrike15_v2_GetEventFavorites_Request {
        <CMsgGCCStrike15_v2_GetEventFavorites_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GetEventFavorites_Request {
    pub fn new() -> CMsgGCCStrike15_v2_GetEventFavorites_Request {
        ::std::default::Default::default()
    }

    // optional bool all_events = 1;


    pub fn get_all_events(&self) -> bool {
        self.all_events.unwrap_or(false)
    }
    pub fn clear_all_events(&mut self) {
        self.all_events = ::std::option::Option::None;
    }

    pub fn has_all_events(&self) -> bool {
        self.all_events.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_events(&mut self, v: bool) {
        self.all_events = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GetEventFavorites_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all_events = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.all_events {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.all_events {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_GetEventFavorites_Request {
        CMsgGCCStrike15_v2_GetEventFavorites_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "all_events",
                    |m: &CMsgGCCStrike15_v2_GetEventFavorites_Request| { &m.all_events },
                    |m: &mut CMsgGCCStrike15_v2_GetEventFavorites_Request| { &mut m.all_events },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GetEventFavorites_Request>(
                    "CMsgGCCStrike15_v2_GetEventFavorites_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GetEventFavorites_Request {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GetEventFavorites_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GetEventFavorites_Request,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GetEventFavorites_Request::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GetEventFavorites_Request {
    fn clear(&mut self) {
        self.all_events = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GetEventFavorites_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GetEventFavorites_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCStrike15_v2_GetEventFavorites_Response {
    // message fields
    all_events: ::std::option::Option<bool>,
    json_favorites: ::protobuf::SingularField<::std::string::String>,
    json_featured: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GetEventFavorites_Response {
    fn default() -> &'a CMsgGCCStrike15_v2_GetEventFavorites_Response {
        <CMsgGCCStrike15_v2_GetEventFavorites_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GetEventFavorites_Response {
    pub fn new() -> CMsgGCCStrike15_v2_GetEventFavorites_Response {
        ::std::default::Default::default()
    }

    // optional bool all_events = 1;


    pub fn get_all_events(&self) -> bool {
        self.all_events.unwrap_or(false)
    }
    pub fn clear_all_events(&mut self) {
        self.all_events = ::std::option::Option::None;
    }

    pub fn has_all_events(&self) -> bool {
        self.all_events.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_events(&mut self, v: bool) {
        self.all_events = ::std::option::Option::Some(v);
    }

    // optional string json_favorites = 2;


    pub fn get_json_favorites(&self) -> &str {
        match self.json_favorites.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_json_favorites(&mut self) {
        self.json_favorites.clear();
    }

    pub fn has_json_favorites(&self) -> bool {
        self.json_favorites.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_favorites(&mut self, v: ::std::string::String) {
        self.json_favorites = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_favorites(&mut self) -> &mut ::std::string::String {
        if self.json_favorites.is_none() {
            self.json_favorites.set_default();
        }
        self.json_favorites.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_favorites(&mut self) -> ::std::string::String {
        self.json_favorites.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string json_featured = 3;


    pub fn get_json_featured(&self) -> &str {
        match self.json_featured.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_json_featured(&mut self) {
        self.json_featured.clear();
    }

    pub fn has_json_featured(&self) -> bool {
        self.json_featured.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_featured(&mut self, v: ::std::string::String) {
        self.json_featured = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_featured(&mut self) -> &mut ::std::string::String {
        if self.json_featured.is_none() {
            self.json_featured.set_default();
        }
        self.json_featured.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_featured(&mut self) -> ::std::string::String {
        self.json_featured.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GetEventFavorites_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all_events = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.json_favorites)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.json_featured)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.all_events {
            my_size += 2;
        }
        if let Some(ref v) = self.json_favorites.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.json_featured.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.all_events {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.json_favorites.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.json_featured.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCStrike15_v2_GetEventFavorites_Response {
        CMsgGCCStrike15_v2_GetEventFavorites_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "all_events",
                    |m: &CMsgGCCStrike15_v2_GetEventFavorites_Response| { &m.all_events },
                    |m: &mut CMsgGCCStrike15_v2_GetEventFavorites_Response| { &mut m.all_events },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "json_favorites",
                    |m: &CMsgGCCStrike15_v2_GetEventFavorites_Response| { &m.json_favorites },
                    |m: &mut CMsgGCCStrike15_v2_GetEventFavorites_Response| { &mut m.json_favorites },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "json_featured",
                    |m: &CMsgGCCStrike15_v2_GetEventFavorites_Response| { &m.json_featured },
                    |m: &mut CMsgGCCStrike15_v2_GetEventFavorites_Response| { &mut m.json_featured },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCStrike15_v2_GetEventFavorites_Response>(
                    "CMsgGCCStrike15_v2_GetEventFavorites_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GetEventFavorites_Response {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCStrike15_v2_GetEventFavorites_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCStrike15_v2_GetEventFavorites_Response,
        };
        unsafe {
            instance.get(CMsgGCCStrike15_v2_GetEventFavorites_Response::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGCCStrike15_v2_GetEventFavorites_Response {
    fn clear(&mut self) {
        self.all_events = ::std::option::Option::None;
        self.json_favorites.clear();
        self.json_featured.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCStrike15_v2_GetEventFavorites_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GetEventFavorites_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ECsgoGCMsg {
    k_EMsgGCCStrike15_v2_Base = 9100,
    k_EMsgGCCStrike15_v2_MatchmakingStart = 9101,
    k_EMsgGCCStrike15_v2_MatchmakingStop = 9102,
    k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing = 9103,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = 9104,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = 9105,
    k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse = 9106,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = 9107,
    k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats = 9108,
    k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello = 9109,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello = 9110,
    k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd = 9111,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = 9112,
    k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick = 9113,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = 9114,
    k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats = 9115,
    k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = 9116,
    k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = 9117,
    k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty = 9118,
    k_EMsgGCCStrike15_v2_ClientReportPlayer = 9119,
    k_EMsgGCCStrike15_v2_ClientReportServer = 9120,
    k_EMsgGCCStrike15_v2_ClientCommendPlayer = 9121,
    k_EMsgGCCStrike15_v2_ClientReportResponse = 9122,
    k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery = 9123,
    k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse = 9124,
    k_EMsgGCCStrike15_v2_WatchInfoUsers = 9126,
    k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile = 9127,
    k_EMsgGCCStrike15_v2_PlayersProfile = 9128,
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = 9131,
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = 9132,
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = 9133,
    k_EMsgGCCStrike15_v2_GC2ClientTextMsg = 9134,
    k_EMsgGCCStrike15_v2_Client2GCTextMsg = 9135,
    k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops = 9136,
    k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification = 9137,
    k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 = 9138,
    k_EMsgGCCStrike15_v2_MatchList = 9139,
    k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = 9140,
    k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames = 9141,
    k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate = 9142,
    k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo = 9144,
    k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = 9145,
    k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames = 9146,
    k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo = 9147,
    k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest = 9148,
    k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse = 9149,
    k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo = 9150,
    k_EMsgGCToGCReloadVersions = 9151,
    k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote = 9152,
    k_EMsgGCCStrike15_v2_Server2GCClientValidate = 9153,
    k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = 9154,
    k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = 9155,
    k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = 9156,
    k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = 9157,
    k_EMsgGCCStrike15_v2_AccountPrivacySettings = 9158,
    k_EMsgGCCStrike15_v2_SetMyActivityInfo = 9159,
    k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions = 9160,
    k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions = 9161,
    k_EMsgGCCStrike15_v2_DraftSummary = 9162,
    k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData = 9163,
    k_EMsgGCCStrike15_v2_ClientRequestJoinServerData = 9164,
    k_EMsgGCCStrike15_v2_ClientRequestNewMission = 9165,
    k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded = 9166,
    k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo = 9167,
    k_EMsgGC_GlobalGame_Subscribe = 9168,
    k_EMsgGC_GlobalGame_Unsubscribe = 9169,
    k_EMsgGC_GlobalGame_Play = 9170,
    k_EMsgGCCStrike15_v2_AcknowledgePenalty = 9171,
    k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = 9172,
    k_EMsgGCCStrike15_v2_GC2ClientGlobalStats = 9173,
    k_EMsgGCCStrike15_v2_Client2GCStreamUnlock = 9174,
    k_EMsgGCCStrike15_v2_FantasyRequestClientData = 9175,
    k_EMsgGCCStrike15_v2_FantasyUpdateClientData = 9176,
    k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket = 9177,
    k_EMsgGCCStrike15_v2_ClientToGCRequestTicket = 9178,
    k_EMsgGCCStrike15_v2_ClientToGCRequestElevate = 9179,
    k_EMsgGCCStrike15_v2_GlobalChat = 9180,
    k_EMsgGCCStrike15_v2_GlobalChat_Subscribe = 9181,
    k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe = 9182,
    k_EMsgGCCStrike15_v2_ClientAuthKeyCode = 9183,
    k_EMsgGCCStrike15_v2_GotvSyncPacket = 9184,
    k_EMsgGCCStrike15_v2_ClientPlayerDecalSign = 9185,
    k_EMsgGCCStrike15_v2_ClientLogonFatalError = 9187,
    k_EMsgGCCStrike15_v2_ClientPollState = 9188,
    k_EMsgGCCStrike15_v2_Party_Register = 9189,
    k_EMsgGCCStrike15_v2_Party_Unregister = 9190,
    k_EMsgGCCStrike15_v2_Party_Search = 9191,
    k_EMsgGCCStrike15_v2_Party_Invite = 9192,
    k_EMsgGCCStrike15_v2_Account_RequestCoPlays = 9193,
    k_EMsgGCCStrike15_v2_ClientGCRankUpdate = 9194,
    k_EMsgGCCStrike15_v2_ClientRequestOffers = 9195,
    k_EMsgGCCStrike15_v2_ClientAccountBalance = 9196,
    k_EMsgGCCStrike15_v2_ClientPartyJoinRelay = 9197,
    k_EMsgGCCStrike15_v2_ClientPartyWarning = 9198,
    k_EMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial = 9199,
    k_EMsgGCCStrike15_v2_SetEventFavorite = 9200,
    k_EMsgGCCStrike15_v2_GetEventFavorites_Request = 9201,
    k_EMsgGCCStrike15_v2_GetEventFavorites_Response = 9203,
    k_EMsgGCCStrike15_v2_ClientRequestSouvenir = 9204,
}

impl ::protobuf::ProtobufEnum for ECsgoGCMsg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECsgoGCMsg> {
        match value {
            9100 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base),
            9101 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart),
            9102 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop),
            9103 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing),
            9104 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate),
            9105 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve),
            9106 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse),
            9107 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve),
            9108 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats),
            9109 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello),
            9110 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello),
            9111 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd),
            9112 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon),
            9113 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick),
            9114 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm),
            9115 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats),
            9116 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate),
            9117 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate),
            9118 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty),
            9119 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer),
            9120 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer),
            9121 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer),
            9122 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse),
            9123 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery),
            9124 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse),
            9126 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers),
            9127 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile),
            9128 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile),
            9131 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate),
            9132 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment),
            9133 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus),
            9134 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg),
            9135 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg),
            9136 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops),
            9137 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification),
            9138 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2),
            9139 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList),
            9140 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames),
            9141 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames),
            9142 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate),
            9144 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo),
            9145 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification),
            9146 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames),
            9147 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo),
            9148 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest),
            9149 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse),
            9150 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo),
            9151 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCToGCReloadVersions),
            9152 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote),
            9153 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate),
            9154 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser),
            9155 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure),
            9156 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest),
            9157 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse),
            9158 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings),
            9159 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo),
            9160 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions),
            9161 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions),
            9162 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary),
            9163 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData),
            9164 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData),
            9165 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission),
            9166 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded),
            9167 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo),
            9168 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe),
            9169 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe),
            9170 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Play),
            9171 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty),
            9172 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin),
            9173 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats),
            9174 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock),
            9175 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData),
            9176 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData),
            9177 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket),
            9178 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket),
            9179 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate),
            9180 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat),
            9181 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe),
            9182 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe),
            9183 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAuthKeyCode),
            9184 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GotvSyncPacket),
            9185 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPlayerDecalSign),
            9187 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientLogonFatalError),
            9188 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPollState),
            9189 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Register),
            9190 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Unregister),
            9191 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Search),
            9192 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Invite),
            9193 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Account_RequestCoPlays),
            9194 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientGCRankUpdate),
            9195 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestOffers),
            9196 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAccountBalance),
            9197 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyJoinRelay),
            9198 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyWarning),
            9199 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial),
            9200 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetEventFavorite),
            9201 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Request),
            9203 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Response),
            9204 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestSouvenir),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ECsgoGCMsg] = &[
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo,
            ECsgoGCMsg::k_EMsgGCToGCReloadVersions,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Play,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAuthKeyCode,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GotvSyncPacket,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPlayerDecalSign,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientLogonFatalError,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPollState,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Register,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Unregister,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Search,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Invite,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Account_RequestCoPlays,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientGCRankUpdate,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestOffers,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAccountBalance,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyJoinRelay,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyWarning,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetEventFavorite,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Request,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Response,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestSouvenir,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ECsgoGCMsg", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ECsgoGCMsg {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ECsgoGCMsg {
    fn default() -> Self {
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base
    }
}

impl ::protobuf::reflect::ProtobufValue for ECsgoGCMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ECsgoSteamUserStat {
    k_ECsgoSteamUserStat_XpEarnedGames = 1,
    k_ECsgoSteamUserStat_MatchWinsCompetitive = 2,
    k_ECsgoSteamUserStat_SurvivedDangerZone = 3,
}

impl ::protobuf::ProtobufEnum for ECsgoSteamUserStat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECsgoSteamUserStat> {
        match value {
            1 => ::std::option::Option::Some(ECsgoSteamUserStat::k_ECsgoSteamUserStat_XpEarnedGames),
            2 => ::std::option::Option::Some(ECsgoSteamUserStat::k_ECsgoSteamUserStat_MatchWinsCompetitive),
            3 => ::std::option::Option::Some(ECsgoSteamUserStat::k_ECsgoSteamUserStat_SurvivedDangerZone),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ECsgoSteamUserStat] = &[
            ECsgoSteamUserStat::k_ECsgoSteamUserStat_XpEarnedGames,
            ECsgoSteamUserStat::k_ECsgoSteamUserStat_MatchWinsCompetitive,
            ECsgoSteamUserStat::k_ECsgoSteamUserStat_SurvivedDangerZone,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ECsgoSteamUserStat", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ECsgoSteamUserStat {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ECsgoSteamUserStat {
    fn default() -> Self {
        ECsgoSteamUserStat::k_ECsgoSteamUserStat_XpEarnedGames
    }
}

impl ::protobuf::reflect::ProtobufValue for ECsgoSteamUserStat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1acstrike15_gcmessages.proto\x1a\x13steammessages.proto\x1a\x17engin\
    e_gcmessages.proto\"R\n\x0eGameServerPing\x12\x12\n\x04ping\x18\x02\x20\
    \x01(\x05R\x04ping\x12\x0e\n\x02ip\x18\x03\x20\x01(\rR\x02ip\x12\x1c\n\t\
    instances\x18\x05\x20\x01(\rR\tinstances\"J\n\x0eDataCenterPing\x12$\n\
    \x0edata_center_id\x18\x01\x20\x01(\x07R\x0cdataCenterId\x12\x12\n\x04pi\
    ng\x18\x02\x20\x01(\x11R\x04ping\"\x8b\x01\n\x17DetailedSearchStatistic\
    \x12\x1b\n\tgame_type\x18\x01\x20\x01(\rR\x08gameType\x12&\n\x0fsearch_t\
    ime_avg\x18\x02\x20\x01(\rR\rsearchTimeAvg\x12+\n\x11players_searching\
    \x18\x04\x20\x01(\rR\x10playersSearching\"\xfd\x01\n\x10TournamentPlayer\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1f\n\x0bplaye\
    r_nick\x18\x02\x20\x01(\tR\nplayerNick\x12\x1f\n\x0bplayer_name\x18\x03\
    \x20\x01(\tR\nplayerName\x12\x1d\n\nplayer_dob\x18\x04\x20\x01(\rR\tplay\
    erDob\x12\x1f\n\x0bplayer_flag\x18\x05\x20\x01(\tR\nplayerFlag\x12'\n\
    \x0fplayer_location\x18\x06\x20\x01(\tR\x0eplayerLocation\x12\x1f\n\x0bp\
    layer_desc\x18\x07\x20\x01(\tR\nplayerDesc\"\xab\x01\n\x0eTournamentTeam\
    \x12\x17\n\x07team_id\x18\x01\x20\x01(\x05R\x06teamId\x12\x19\n\x08team_\
    tag\x18\x02\x20\x01(\tR\x07teamTag\x12\x1b\n\tteam_flag\x18\x03\x20\x01(\
    \tR\x08teamFlag\x12\x1b\n\tteam_name\x18\x04\x20\x01(\tR\x08teamName\x12\
    +\n\x07players\x18\x05\x20\x03(\x0b2\x11.TournamentPlayerR\x07players\"\
    \xd7\x02\n\x0fTournamentEvent\x12\x19\n\x08event_id\x18\x01\x20\x01(\x05\
    R\x07eventId\x12\x1b\n\tevent_tag\x18\x02\x20\x01(\tR\x08eventTag\x12\
    \x1d\n\nevent_name\x18\x03\x20\x01(\tR\teventName\x12(\n\x10event_time_s\
    tart\x18\x04\x20\x01(\rR\x0eeventTimeStart\x12$\n\x0eevent_time_end\x18\
    \x05\x20\x01(\rR\x0ceventTimeEnd\x12!\n\x0cevent_public\x18\x06\x20\x01(\
    \x05R\x0beventPublic\x12$\n\x0eevent_stage_id\x18\x07\x20\x01(\x05R\x0ce\
    ventStageId\x12(\n\x10event_stage_name\x18\x08\x20\x01(\tR\x0eeventStage\
    Name\x12*\n\x11active_section_id\x18\t\x20\x01(\rR\x0factiveSectionId\"\
    \xc8\x05\n\x10GlobalStatistics\x12%\n\x0eplayers_online\x18\x01\x20\x01(\
    \rR\rplayersOnline\x12%\n\x0eservers_online\x18\x02\x20\x01(\rR\rservers\
    Online\x12+\n\x11players_searching\x18\x03\x20\x01(\rR\x10playersSearchi\
    ng\x12+\n\x11servers_available\x18\x04\x20\x01(\rR\x10serversAvailable\
    \x12'\n\x0fongoing_matches\x18\x05\x20\x01(\rR\x0eongoingMatches\x12&\n\
    \x0fsearch_time_avg\x18\x06\x20\x01(\rR\rsearchTimeAvg\x12E\n\x11search_\
    statistics\x18\x07\x20\x03(\x0b2\x18.DetailedSearchStatisticR\x10searchS\
    tatistics\x12\"\n\rmain_post_url\x18\x08\x20\x01(\tR\x0bmainPostUrl\x124\
    \n\x16required_appid_version\x18\t\x20\x01(\rR\x14requiredAppidVersion\
    \x12-\n\x12pricesheet_version\x18\n\x20\x01(\rR\x11pricesheetVersion\x12\
    4\n\x16twitch_streams_version\x18\x0b\x20\x01(\rR\x14twitchStreamsVersio\
    n\x12:\n\x19active_tournament_eventid\x18\x0c\x20\x01(\rR\x17activeTourn\
    amentEventid\x12(\n\x10active_survey_id\x18\r\x20\x01(\rR\x0eactiveSurve\
    yId\x12\x1f\n\x0brtime32_cur\x18\x0e\x20\x01(\rR\nrtime32Cur\x12.\n\x13r\
    time32_event_start\x18\x0f\x20\x01(\rR\x11rtime32EventStart\"K\n\x1fOper\
    ationalStatisticDescription\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04nam\
    e\x12\x14\n\x05idkey\x18\x02\x20\x01(\rR\x05idkey\"K\n\x1bOperationalSta\
    tisticElement\x12\x14\n\x05idkey\x18\x01\x20\x01(\rR\x05idkey\x12\x16\n\
    \x06values\x18\x02\x20\x03(\x05R\x06values\"\x91\x01\n\x1bOperationalSta\
    tisticsPacket\x12\x1a\n\x08packetid\x18\x01\x20\x01(\x05R\x08packetid\
    \x12\x20\n\x0bmstimestamp\x18\x02\x20\x01(\x05R\x0bmstimestamp\x124\n\
    \x06values\x18\x03\x20\x03(\x0b2\x1c.OperationalStatisticElementR\x06val\
    ues\"\xa2\x01\n\x11PlayerRankingInfo\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\x12\x17\n\x07rank_id\x18\x02\x20\x01(\rR\x06rankId\
    \x12\x12\n\x04wins\x18\x03\x20\x01(\rR\x04wins\x12\x1f\n\x0brank_change\
    \x18\x04\x20\x01(\x02R\nrankChange\x12\x20\n\x0crank_type_id\x18\x06\x20\
    \x01(\rR\nrankTypeId\"}\n\x16PlayerCommendationInfo\x12!\n\x0ccmd_friend\
    ly\x18\x01\x20\x01(\rR\x0bcmdFriendly\x12!\n\x0ccmd_teaching\x18\x02\x20\
    \x01(\rR\x0bcmdTeaching\x12\x1d\n\ncmd_leader\x18\x04\x20\x01(\rR\tcmdLe\
    ader\"\x85\x01\n\x10PlayerMedalsInfo\x120\n\x14display_items_defidx\x18\
    \x07\x20\x03(\rR\x12displayItemsDefidx\x12?\n\x1cfeatured_display_item_d\
    efidx\x18\x08\x20\x01(\rR\x19featuredDisplayItemDefidx\"m\n\x0fAccountAc\
    tivity\x12\x1a\n\x08activity\x18\x01\x20\x01(\rR\x08activity\x12\x12\n\
    \x04mode\x18\x02\x20\x01(\rR\x04mode\x12\x10\n\x03map\x18\x03\x20\x01(\r\
    R\x03map\x12\x18\n\x07matchid\x18\x04\x20\x01(\x04R\x07matchid\"\x91\x01\
    \n\x14TournamentMatchSetup\x12\x19\n\x08event_id\x18\x01\x20\x01(\x05R\
    \x07eventId\x12\x1c\n\nteam_id_ct\x18\x02\x20\x01(\x05R\x08teamIdCt\x12\
    \x1a\n\tteam_id_t\x18\x03\x20\x01(\x05R\x07teamIdT\x12$\n\x0eevent_stage\
    _id\x18\x04\x20\x01(\x05R\x0ceventStageId\"\xcf\x05\n\x0eServerHltvInfo\
    \x12\x1e\n\x0btv_udp_port\x18\x01\x20\x01(\rR\ttvUdpPort\x12\x20\n\x0ctv\
    _watch_key\x18\x02\x20\x01(\x04R\ntvWatchKey\x12\x19\n\x08tv_slots\x18\
    \x03\x20\x01(\rR\x07tvSlots\x12\x1d\n\ntv_clients\x18\x04\x20\x01(\rR\tt\
    vClients\x12\x1d\n\ntv_proxies\x18\x05\x20\x01(\rR\ttvProxies\x12\x17\n\
    \x07tv_time\x18\x06\x20\x01(\rR\x06tvTime\x12\x1b\n\tgame_type\x18\x08\
    \x20\x01(\rR\x08gameType\x12#\n\rgame_mapgroup\x18\t\x20\x01(\tR\x0cgame\
    Mapgroup\x12\x19\n\x08game_map\x18\n\x20\x01(\tR\x07gameMap\x12*\n\x11tv\
    _master_steamid\x18\x0b\x20\x01(\x04R\x0ftvMasterSteamid\x12$\n\x0etv_lo\
    cal_slots\x18\x0c\x20\x01(\rR\x0ctvLocalSlots\x12(\n\x10tv_local_clients\
    \x18\r\x20\x01(\rR\x0etvLocalClients\x12(\n\x10tv_local_proxies\x18\x0e\
    \x20\x01(\rR\x0etvLocalProxies\x12$\n\x0etv_relay_slots\x18\x0f\x20\x01(\
    \rR\x0ctvRelaySlots\x12(\n\x10tv_relay_clients\x18\x10\x20\x01(\rR\x0etv\
    RelayClients\x12(\n\x10tv_relay_proxies\x18\x11\x20\x01(\rR\x0etvRelayPr\
    oxies\x12(\n\x10tv_relay_address\x18\x12\x20\x01(\rR\x0etvRelayAddress\
    \x12\"\n\rtv_relay_port\x18\x13\x20\x01(\rR\x0btvRelayPort\x12(\n\x10tv_\
    relay_steamid\x18\x14\x20\x01(\x04R\x0etvRelaySteamid\x12\x14\n\x05flags\
    \x18\x15\x20\x01(\rR\x05flags\"q\n\rIpAddressMask\x12\x0c\n\x01a\x18\x01\
    \x20\x01(\rR\x01a\x12\x0c\n\x01b\x18\x02\x20\x01(\rR\x01b\x12\x0c\n\x01c\
    \x18\x03\x20\x01(\rR\x01c\x12\x0c\n\x01d\x18\x04\x20\x01(\rR\x01d\x12\
    \x12\n\x04bits\x18\x05\x20\x01(\rR\x04bits\x12\x14\n\x05token\x18\x06\
    \x20\x01(\rR\x05token\"\x7f\n\x1bCMsgCsgoSteamUserStatChange\x12.\n\x12e\
    csgosteamuserstat\x18\x01\x20\x01(\x05R\x12ecsgosteamuserstat\x12\x14\n\
    \x05delta\x18\x02\x20\x01(\x05R\x05delta\x12\x1a\n\x08absolute\x18\x03\
    \x20\x01(\x08R\x08absolute\"N\n\x0eXpProgressData\x12\x1b\n\txp_points\
    \x18\x01\x20\x01(\rR\x08xpPoints\x12\x1f\n\x0bxp_category\x18\x02\x20\
    \x01(\x05R\nxpCategory\"\x8b\x01\n\x13MatchEndItemUpdates\x12\x17\n\x07i\
    tem_id\x18\x01\x20\x01(\x04R\x06itemId\x12(\n\x10item_attr_defidx\x18\
    \x02\x20\x01(\rR\x0eitemAttrDefidx\x121\n\x15item_attr_delta_value\x18\
    \x03\x20\x01(\rR\x12itemAttrDeltaValue\"\xea\x02\n\x14ScoreLeaderboardDa\
    ta\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\x12\x14\n\x05s\
    core\x18\x02\x20\x01(\rR\x05score\x12L\n\x0eaccountentries\x18\x03\x20\
    \x03(\x0b2$.ScoreLeaderboardData.AccountEntriesR\x0eaccountentries\x12?\
    \n\x0cmatchentries\x18\x05\x20\x03(\x0b2\x1b.ScoreLeaderboardData.EntryR\
    \x0cmatchentries\x1a+\n\x05Entry\x12\x10\n\x03tag\x18\x01\x20\x01(\rR\
    \x03tag\x12\x10\n\x03val\x18\x02\x20\x01(\rR\x03val\x1ae\n\x0eAccountEnt\
    ries\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x125\n\x07entri\
    es\x18\x02\x20\x03(\x0b2\x1b.ScoreLeaderboardData.EntryR\x07entries\"\
    \xe7\x04\n\x0fPlayerQuestData\x12,\n\x12quester_account_id\x18\x01\x20\
    \x01(\rR\x10questerAccountId\x12F\n\x0fquest_item_data\x18\x02\x20\x03(\
    \x0b2\x1e.PlayerQuestData.QuestItemDataR\rquestItemData\x129\n\x10xp_pro\
    gress_data\x18\x03\x20\x03(\x0b2\x0f.XpProgressDataR\x0expProgressData\
    \x12\x1f\n\x0btime_played\x18\x04\x20\x01(\rR\ntimePlayed\x12\x20\n\x0cm\
    m_game_mode\x18\x05\x20\x01(\rR\nmmGameMode\x127\n\x0citem_updates\x18\
    \x06\x20\x03(\x0b2\x14.MatchEndItemUpdatesR\x0bitemUpdates\x12:\n\x19ope\
    ration_points_eligible\x18\x07\x20\x01(\x08R\x17operationPointsEligible\
    \x12F\n\x0fuserstatchanges\x18\x08\x20\x03(\x0b2\x1c.CMsgCsgoSteamUserSt\
    atChangeR\x0fuserstatchanges\x1a\xa2\x01\n\rQuestItemData\x12\x19\n\x08q\
    uest_id\x18\x01\x20\x01(\x04R\x07questId\x12;\n\x1aquest_normal_points_e\
    arned\x18\x02\x20\x01(\x05R\x17questNormalPointsEarned\x129\n\x19quest_b\
    onus_points_earned\x18\x03\x20\x01(\x05R\x16questBonusPointsEarned\"\xde\
    \x01\n\x1cCMsgGC_ServerQuestUpdateData\x12<\n\x11player_quest_data\x18\
    \x01\x20\x03(\x0b2\x10.PlayerQuestDataR\x0fplayerQuestData\x12\x1f\n\x0b\
    binary_data\x18\x02\x20\x01(\x0cR\nbinaryData\x12\x20\n\x0cmm_game_mode\
    \x18\x03\x20\x01(\rR\nmmGameMode\x12=\n\x0emissionlbsdata\x18\x04\x20\
    \x01(\x0b2\x15.ScoreLeaderboardDataR\x0emissionlbsdata\"\xc4\x01\n0CMsgG\
    CCStrike15_v2_MatchmakingGCOperationalStats\x12\x1a\n\x08packetid\x18\
    \x01\x20\x01(\x05R\x08packetid\x12<\n\x08namekeys\x18\x02\x20\x03(\x0b2\
    \x20.OperationalStatisticDescriptionR\x08namekeys\x126\n\x07packets\x18\
    \x03\x20\x03(\x0b2\x1c.OperationalStatisticsPacketR\x07packets\"x\n.CMsg\
    GCCStrike15_v2_MatchmakingGC2ServerConfirm\x12\x14\n\x05token\x18\x01\
    \x20\x01(\rR\x05token\x12\x14\n\x05stamp\x18\x02\x20\x01(\rR\x05stamp\
    \x12\x1a\n\x08exchange\x18\x03\x20\x01(\x04R\x08exchange\"\x9b\x01\n-CMs\
    gGCCStrike15_v2_GC2ServerReservationUpdate\x124\n\x16viewers_external_to\
    tal\x18\x01\x20\x01(\rR\x14viewersExternalTotal\x124\n\x16viewers_extern\
    al_steam\x18\x02\x20\x01(\rR\x14viewersExternalSteam\"\x8c\x02\n#CMsgGCC\
    Strike15_v2_MatchmakingStart\x12\x1f\n\x0baccount_ids\x18\x01\x20\x03(\r\
    R\naccountIds\x12\x1b\n\tgame_type\x18\x02\x20\x01(\rR\x08gameType\x12\
    \x1f\n\x0bticket_data\x18\x03\x20\x01(\tR\nticketData\x12%\n\x0eclient_v\
    ersion\x18\x04\x20\x01(\rR\rclientVersion\x12@\n\x10tournament_match\x18\
    \x05\x20\x01(\x0b2\x15.TournamentMatchSetupR\x0ftournamentMatch\x12\x1d\
    \n\nprime_only\x18\x06\x20\x01(\x08R\tprimeOnly\">\n\"CMsgGCCStrike15_v2\
    _MatchmakingStop\x12\x18\n\x07abandon\x18\x01\x20\x01(\x05R\x07abandon\"\
    \xa7\x02\n/CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\x129\n\x0fgam\
    eserverpings\x18\x01\x20\x03(\x0b2\x0f.GameServerPingR\x0fgameserverping\
    s\x12!\n\x0coffset_index\x18\x02\x20\x01(\x05R\x0boffsetIndex\x12\x1f\n\
    \x0bfinal_batch\x18\x03\x20\x01(\x05R\nfinalBatch\x12;\n\x11data_center_\
    pings\x18\x04\x20\x03(\x0b2\x0f.DataCenterPingR\x0fdataCenterPings\x12\
    \x19\n\x08max_ping\x18\x05\x20\x01(\rR\x07maxPing\x12\x1d\n\ntest_token\
    \x18\x06\x20\x01(\x07R\ttestToken\"\xb2\x08\n-CMsgGCCStrike15_v2_Matchma\
    kingGC2ClientUpdate\x12\x20\n\x0bmatchmaking\x18\x01\x20\x01(\x05R\x0bma\
    tchmaking\x12=\n\x1bwaiting_account_id_sessions\x18\x02\x20\x03(\rR\x18w\
    aitingAccountIdSessions\x12\x14\n\x05error\x18\x03\x20\x01(\tR\x05error\
    \x12G\n\x20ongoingmatch_account_id_sessions\x18\x06\x20\x03(\rR\x1dongoi\
    ngmatchAccountIdSessions\x124\n\x0cglobal_stats\x18\x07\x20\x01(\x0b2\
    \x11.GlobalStatisticsR\x0bglobalStats\x12?\n\x1cfailping_account_id_sess\
    ions\x18\x08\x20\x03(\rR\x19failpingAccountIdSessions\x12=\n\x1bpenalty_\
    account_id_sessions\x18\t\x20\x03(\rR\x18penaltyAccountIdSessions\x12A\n\
    \x1dfailready_account_id_sessions\x18\n\x20\x03(\rR\x1afailreadyAccountI\
    dSessions\x12A\n\x1dvacbanned_account_id_sessions\x18\x0b\x20\x03(\rR\
    \x1avacbannedAccountIdSessions\x12B\n\x15server_ipaddress_mask\x18\x0c\
    \x20\x01(\x0b2\x0e.IpAddressMaskR\x13serverIpaddressMask\x12I\n\x05notes\
    \x18\r\x20\x03(\x0b23.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\
    R\x05notes\x12H\n!penalty_account_id_sessions_green\x18\x0e\x20\x03(\rR\
    \x1dpenaltyAccountIdSessionsGreen\x12=\n\x1ainsufficientlevel_sessions\
    \x18\x0f\x20\x03(\rR\x19insufficientlevelSessions\x12?\n\x1cvsncheck_acc\
    ount_id_sessions\x18\x10\x20\x03(\rR\x19vsncheckAccountIdSessions\x12<\n\
    \x1alauncher_mismatch_sessions\x18\x11\x20\x03(\rR\x18launcherMismatchSe\
    ssions\x1an\n\x04Note\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\
    \x12\x1b\n\tregion_id\x18\x02\x20\x01(\x05R\x08regionId\x12\x19\n\x08reg\
    ion_r\x18\x03\x20\x01(\x02R\x07regionR\x12\x1a\n\x08distance\x18\x04\x20\
    \x01(\x02R\x08distance\"\xd7\x03\n(CDataGCCStrike15_v2_TournamentMatchDr\
    aft\x12\x19\n\x08event_id\x18\x01\x20\x01(\x05R\x07eventId\x12$\n\x0eeve\
    nt_stage_id\x18\x02\x20\x01(\x05R\x0ceventStageId\x12\x1a\n\tteam_id_0\
    \x18\x03\x20\x01(\x05R\x07teamId0\x12\x1a\n\tteam_id_1\x18\x04\x20\x01(\
    \x05R\x07teamId1\x12\x1d\n\nmaps_count\x18\x05\x20\x01(\x05R\tmapsCount\
    \x12!\n\x0cmaps_current\x18\x06\x20\x01(\x05R\x0bmapsCurrent\x12\"\n\rte\
    am_id_start\x18\x07\x20\x01(\x05R\x0bteamIdStart\x12\"\n\rteam_id_veto1\
    \x18\x08\x20\x01(\x05R\x0bteamIdVeto1\x12\"\n\rteam_id_pickn\x18\t\x20\
    \x01(\x05R\x0bteamIdPickn\x12G\n\x06drafts\x18\n\x20\x03(\x0b2/.CDataGCC\
    Strike15_v2_TournamentMatchDraft.EntryR\x06drafts\x1a;\n\x05Entry\x12\
    \x14\n\x05mapid\x18\x01\x20\x01(\x05R\x05mapid\x12\x1c\n\nteam_id_ct\x18\
    \x02\x20\x01(\x05R\x08teamIdCt\"\xcf\x02\n\x11CPreMatchInfoData\x12'\n\
    \x0fpredictions_pct\x18\x01\x20\x01(\x05R\x0epredictionsPct\x12?\n\x05dr\
    aft\x18\x04\x20\x01(\x0b2).CDataGCCStrike15_v2_TournamentMatchDraftR\x05\
    draft\x122\n\x05stats\x18\x05\x20\x03(\x0b2\x1c.CPreMatchInfoData.TeamSt\
    atsR\x05stats\x12\x12\n\x04wins\x18\x06\x20\x03(\x05R\x04wins\x1a\x87\
    \x01\n\tTeamStats\x12*\n\x11match_info_idxtxt\x18\x01\x20\x01(\x05R\x0fm\
    atchInfoIdxtxt\x12$\n\x0ematch_info_txt\x18\x02\x20\x01(\tR\x0cmatchInfo\
    Txt\x12(\n\x10match_info_teams\x18\x03\x20\x03(\tR\x0ematchInfoTeams\"\
    \xb3\x06\n.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\x12\x1f\n\x0ba\
    ccount_ids\x18\x01\x20\x03(\rR\naccountIds\x12\x1b\n\tgame_type\x18\x02\
    \x20\x01(\rR\x08gameType\x12\x19\n\x08match_id\x18\x03\x20\x01(\x04R\x07\
    matchId\x12%\n\x0eserver_version\x18\x04\x20\x01(\rR\rserverVersion\x12\
    \x14\n\x05flags\x18\x12\x20\x01(\rR\x05flags\x12.\n\x08rankings\x18\x05\
    \x20\x03(\x0b2\x12.PlayerRankingInfoR\x08rankings\x12%\n\x0eencryption_k\
    ey\x18\x06\x20\x01(\x04R\rencryptionKey\x12,\n\x12encryption_key_pub\x18\
    \x07\x20\x01(\x04R\x10encryptionKeyPub\x12\x1b\n\tparty_ids\x18\x08\x20\
    \x03(\rR\x08partyIds\x12,\n\twhitelist\x18\t\x20\x03(\x0b2\x0e.IpAddress\
    MaskR\twhitelist\x12*\n\x11tv_master_steamid\x18\n\x20\x01(\x04R\x0ftvMa\
    sterSteamid\x12;\n\x10tournament_event\x18\x0b\x20\x01(\x0b2\x10.Tournam\
    entEventR\x0ftournamentEvent\x12:\n\x10tournament_teams\x18\x0c\x20\x03(\
    \x0b2\x0f.TournamentTeamR\x0ftournamentTeams\x12C\n\x1etournament_caster\
    s_account_ids\x18\r\x20\x03(\rR\x1btournamentCastersAccountIds\x12(\n\
    \x10tv_relay_steamid\x18\x0e\x20\x01(\x04R\x0etvRelaySteamid\x128\n\x0ep\
    re_match_data\x18\x0f\x20\x01(\x0b2\x12.CPreMatchInfoDataR\x0cpreMatchDa\
    ta\x12.\n\x13rtime32_event_start\x18\x10\x20\x01(\rR\x11rtime32EventStar\
    t\x12\x1d\n\ntv_control\x18\x11\x20\x01(\rR\ttvControl\"\xcf\x06\n7CMsgG\
    CCStrike15_v2_MatchmakingServerReservationResponse\x12$\n\rreservationid\
    \x18\x01\x20\x01(\x04R\rreservationid\x12Q\n\x0breservation\x18\x02\x20\
    \x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserveR\x0breservati\
    on\x12\x10\n\x03map\x18\x03\x20\x01(\tR\x03map\x12.\n\x13gc_reservation_\
    sent\x18\x04\x20\x01(\x04R\x11gcReservationSent\x12%\n\x0eserver_version\
    \x18\x05\x20\x01(\rR\rserverVersion\x12(\n\x07tv_info\x18\x06\x20\x01(\
    \x0b2\x0f.ServerHltvInfoR\x06tvInfo\x124\n\x16reward_player_accounts\x18\
    \x07\x20\x03(\rR\x14rewardPlayerAccounts\x120\n\x14idle_player_accounts\
    \x18\x08\x20\x03(\rR\x12idlePlayerAccounts\x126\n\x18reward_item_attr_de\
    f_idx\x18\t\x20\x01(\rR\x14rewardItemAttrDefIdx\x123\n\x16reward_item_at\
    tr_value\x18\n\x20\x01(\rR\x13rewardItemAttrValue\x12<\n\x1breward_item_\
    attr_reward_idx\x18\x0b\x20\x01(\rR\x17rewardItemAttrRewardIdx\x12(\n\
    \x10reward_drop_list\x18\x0c\x20\x01(\rR\x0erewardDropList\x12%\n\x0etou\
    rnament_tag\x18\r\x20\x01(\tR\rtournamentTag\x12:\n\x19legacy_steamdatag\
    ram_port\x18\x0e\x20\x01(\rR\x17legacySteamdatagramPort\x123\n\x15steamd\
    atagram_routing\x18\x11\x20\x01(\rR\x14steamdatagramRouting\x12\x1d\n\nt\
    est_token\x18\x0f\x20\x01(\x07R\ttestToken\x12\x14\n\x05flags\x18\x10\
    \x20\x01(\rR\x05flags\"\xca\x02\n.CMsgGCCStrike15_v2_MatchmakingGC2Clien\
    tReserve\x12\x1a\n\x08serverid\x18\x01\x20\x01(\x04R\x08serverid\x12\"\n\
    \rdirect_udp_ip\x18\x02\x20\x01(\rR\x0bdirectUdpIp\x12&\n\x0fdirect_udp_\
    port\x18\x03\x20\x01(\rR\rdirectUdpPort\x12$\n\rreservationid\x18\x04\
    \x20\x01(\x04R\rreservationid\x12Q\n\x0breservation\x18\x05\x20\x01(\x0b\
    2/.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserveR\x0breservation\x12\
    \x10\n\x03map\x18\x06\x20\x01(\tR\x03map\x12%\n\x0eserver_address\x18\
    \x07\x20\x01(\tR\rserverAddress\"\xbb\x08\n.CMsgGCCStrike15_v2_Matchmaki\
    ngServerRoundStats\x12$\n\rreservationid\x18\x01\x20\x01(\x04R\rreservat\
    ionid\x12Q\n\x0breservation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Ma\
    tchmakingGC2ServerReserveR\x0breservation\x12\x10\n\x03map\x18\x03\x20\
    \x01(\tR\x03map\x12\x14\n\x05round\x18\x04\x20\x01(\x05R\x05round\x12\
    \x14\n\x05kills\x18\x05\x20\x03(\x05R\x05kills\x12\x18\n\x07assists\x18\
    \x06\x20\x03(\x05R\x07assists\x12\x16\n\x06deaths\x18\x07\x20\x03(\x05R\
    \x06deaths\x12\x16\n\x06scores\x18\x08\x20\x03(\x05R\x06scores\x12\x14\n\
    \x05pings\x18\t\x20\x03(\x05R\x05pings\x12!\n\x0cround_result\x18\n\x20\
    \x01(\x05R\x0broundResult\x12!\n\x0cmatch_result\x18\x0b\x20\x01(\x05R\
    \x0bmatchResult\x12\x1f\n\x0bteam_scores\x18\x0c\x20\x03(\x05R\nteamScor\
    es\x12I\n\x07confirm\x18\r\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matchmaking\
    GC2ServerConfirmR\x07confirm\x12+\n\x11reservation_stage\x18\x0e\x20\x01\
    (\x05R\x10reservationStage\x12%\n\x0ematch_duration\x18\x0f\x20\x01(\x05\
    R\rmatchDuration\x12\x1f\n\x0benemy_kills\x18\x10\x20\x03(\x05R\nenemyKi\
    lls\x12'\n\x0fenemy_headshots\x18\x11\x20\x03(\x05R\x0eenemyHeadshots\
    \x12\x1b\n\tenemy_3ks\x18\x12\x20\x03(\x05R\x08enemy3ks\x12\x1b\n\tenemy\
    _4ks\x18\x13\x20\x03(\x05R\x08enemy4ks\x12\x1b\n\tenemy_5ks\x18\x14\x20\
    \x03(\x05R\x08enemy5ks\x12\x12\n\x04mvps\x18\x15\x20\x03(\x05R\x04mvps\
    \x12)\n\x10spectators_count\x18\x16\x20\x01(\rR\x0fspectatorsCount\x12.\
    \n\x13spectators_count_tv\x18\x17\x20\x01(\rR\x11spectatorsCountTv\x120\
    \n\x14spectators_count_lnk\x18\x18\x20\x01(\rR\x12spectatorsCountLnk\x12\
    &\n\x0fenemy_kills_agg\x18\x19\x20\x03(\x05R\renemyKillsAgg\x12U\n\tdrop\
    _info\x18\x1a\x20\x01(\x0b28.CMsgGCCStrike15_v2_MatchmakingServerRoundSt\
    ats.DropInfoR\x08dropInfo\x1a+\n\x08DropInfo\x12\x1f\n\x0baccount_mvp\
    \x18\x01\x20\x01(\rR\naccountMvp\"\xc5\x03\n,CMsgGCCStrike15_v2_Matchmak\
    ingServerMatchEnd\x12E\n\x05stats\x18\x01\x20\x01(\x0b2/.CMsgGCCStrike15\
    _v2_MatchmakingServerRoundStatsR\x05stats\x12I\n\x07confirm\x18\x03\x20\
    \x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirmR\x07confirm\
    \x12\x18\n\x07rematch\x18\x04\x20\x01(\x04R\x07rematch\x12!\n\x0creplay_\
    token\x18\x05\x20\x01(\rR\x0breplayToken\x12*\n\x11replay_cluster_id\x18\
    \x06\x20\x01(\rR\x0freplayClusterId\x12#\n\raborted_match\x18\x07\x20\
    \x01(\x08R\x0cabortedMatch\x12N\n\x14match_end_quest_data\x18\x08\x20\
    \x01(\x0b2\x1d.CMsgGC_ServerQuestUpdateDataR\x11matchEndQuestData\x12%\n\
    \x0eserver_version\x18\t\x20\x01(\rR\rserverVersion\"\xfe\x02\n3CMsgGCCS\
    trike15_v2_MatchmakingServerMatchEndPartial\x12$\n\rreservationid\x18\
    \x01\x20\x01(\x04R\rreservationid\x12Q\n\x0breservation\x18\x02\x20\x01(\
    \x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserveR\x0breservation\
    \x12I\n\x07confirm\x18\x03\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matchmaking\
    GC2ServerConfirmR\x07confirm\x12\\\n\x1bcompleted_player_quest_data\x18\
    \x04\x20\x01(\x0b2\x1d.CMsgGC_ServerQuestUpdateDataR\x18completedPlayerQ\
    uestData\x12%\n\x0eserver_version\x18\x05\x20\x01(\rR\rserverVersion\".\
    \n,CMsgGCCStrike15_v2_MatchmakingClient2GCHello\"\xda\x07\n,CMsgGCCStrik\
    e15_v2_MatchmakingGC2ClientHello\x12\x1d\n\naccount_id\x18\x01\x20\x01(\
    \rR\taccountId\x12S\n\x0congoingmatch\x18\x02\x20\x01(\x0b2/.CMsgGCCStri\
    ke15_v2_MatchmakingGC2ClientReserveR\x0congoingmatch\x124\n\x0cglobal_st\
    ats\x18\x03\x20\x01(\x0b2\x11.GlobalStatisticsR\x0bglobalStats\x12'\n\
    \x0fpenalty_seconds\x18\x04\x20\x01(\rR\x0epenaltySeconds\x12%\n\x0epena\
    lty_reason\x18\x05\x20\x01(\rR\rpenaltyReason\x12\x1d\n\nvac_banned\x18\
    \x06\x20\x01(\x05R\tvacBanned\x12,\n\x07ranking\x18\x07\x20\x01(\x0b2\
    \x12.PlayerRankingInfoR\x07ranking\x12;\n\x0ccommendation\x18\x08\x20\
    \x01(\x0b2\x17.PlayerCommendationInfoR\x0ccommendation\x12)\n\x06medals\
    \x18\t\x20\x01(\x0b2\x11.PlayerMedalsInfoR\x06medals\x12:\n\x10my_curren\
    t_event\x18\n\x20\x01(\x0b2\x10.TournamentEventR\x0emyCurrentEvent\x12D\
    \n\x16my_current_event_teams\x18\x0b\x20\x03(\x0b2\x0f.TournamentTeamR\
    \x13myCurrentEventTeams\x127\n\x0fmy_current_team\x18\x0c\x20\x01(\x0b2\
    \x0f.TournamentTeamR\rmyCurrentTeam\x12G\n\x17my_current_event_stages\
    \x18\r\x20\x03(\x0b2\x10.TournamentEventR\x14myCurrentEventStages\x12\
    \x1f\n\x0bsurvey_vote\x18\x0e\x20\x01(\rR\nsurveyVote\x12,\n\x08activity\
    \x18\x0f\x20\x01(\x0b2\x10.AccountActivityR\x08activity\x12!\n\x0cplayer\
    _level\x18\x11\x20\x01(\x05R\x0bplayerLevel\x12\"\n\rplayer_cur_xp\x18\
    \x12\x20\x01(\x05R\x0bplayerCurXp\x121\n\x15player_xp_bonus_flags\x18\
    \x13\x20\x01(\x05R\x12playerXpBonusFlags\x12.\n\x08rankings\x18\x14\x20\
    \x03(\x0b2\x12.PlayerRankingInfoR\x08rankings\"\xce\x01\n)CMsgGCCStrike1\
    5_v2_AccountPrivacySettings\x12N\n\x08settings\x18\x01\x20\x03(\x0b22.CM\
    sgGCCStrike15_v2_AccountPrivacySettings.SettingR\x08settings\x1aQ\n\x07S\
    etting\x12!\n\x0csetting_type\x18\x01\x20\x01(\rR\x0bsettingType\x12#\n\
    \rsetting_value\x18\x02\x20\x01(\rR\x0csettingValue\"\xf9\x01\n.CMsgGCCS\
    trike15_v2_MatchmakingGC2ClientAbandon\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\x12X\n\x0fabandoned_match\x18\x02\x20\x01(\x0b2/.CMs\
    gGCCStrike15_v2_MatchmakingGC2ClientReserveR\x0eabandonedMatch\x12'\n\
    \x0fpenalty_seconds\x18\x03\x20\x01(\rR\x0epenaltySeconds\x12%\n\x0epena\
    lty_reason\x18\x04\x20\x01(\rR\rpenaltyReason\"\xb7\x01\n+CMsgGCCStrike1\
    5_v2_MatchmakingServer2GCKick\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountId\x12Q\n\x0breservation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15\
    _v2_MatchmakingGC2ServerReserveR\x0breservation\x12\x16\n\x06reason\x18\
    \x03\x20\x01(\rR\x06reason\"~\n1CMsgGCCStrike15_v2_MatchmakingGC2ServerR\
    ankUpdate\x12.\n\x08rankings\x18\x01\x20\x03(\x0b2\x12.PlayerRankingInfo\
    R\x08rankings\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matchId\"W\
    \n%CMsgGCCStrike15_v2_ClientGCRankUpdate\x12.\n\x08rankings\x18\x01\x20\
    \x03(\x0b2\x12.PlayerRankingInfoR\x08rankings\"Y\n3CMsgGCCStrike15_v2_Ma\
    tchmakingOperator2GCBlogUpdate\x12\"\n\rmain_post_url\x18\x01\x20\x01(\t\
    R\x0bmainPostUrl\"\x86\x01\n3CMsgGCCStrike15_v2_ServerNotificationForUse\
    rPenalty\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x16\n\
    \x06reason\x18\x02\x20\x01(\rR\x06reason\x12\x18\n\x07seconds\x18\x03\
    \x20\x01(\rR\x07seconds\"\xb7\x02\n%CMsgGCCStrike15_v2_ClientReportPlaye\
    r\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1d\n\nrpt_ai\
    mbot\x18\x02\x20\x01(\rR\trptAimbot\x12!\n\x0crpt_wallhack\x18\x03\x20\
    \x01(\rR\x0brptWallhack\x12#\n\rrpt_speedhack\x18\x04\x20\x01(\rR\x0crpt\
    Speedhack\x12!\n\x0crpt_teamharm\x18\x05\x20\x01(\rR\x0brptTeamharm\x12#\
    \n\rrpt_textabuse\x18\x06\x20\x01(\rR\x0crptTextabuse\x12%\n\x0erpt_voic\
    eabuse\x18\x07\x20\x01(\rR\rrptVoiceabuse\x12\x19\n\x08match_id\x18\x08\
    \x20\x01(\x04R\x07matchId\"\xb7\x01\n&CMsgGCCStrike15_v2_ClientCommendPl\
    ayer\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x19\n\x08m\
    atch_id\x18\x08\x20\x01(\x04R\x07matchId\x12;\n\x0ccommendation\x18\t\
    \x20\x01(\x0b2\x17.PlayerCommendationInfoR\x0ccommendation\x12\x16\n\x06\
    tokens\x18\n\x20\x01(\rR\x06tokens\"\x8d\x02\n%CMsgGCCStrike15_v2_Client\
    ReportServer\x12!\n\x0crpt_poorperf\x18\x01\x20\x01(\rR\x0brptPoorperf\
    \x12+\n\x11rpt_abusivemodels\x18\x02\x20\x01(\rR\x10rptAbusivemodels\x12\
    \x1f\n\x0brpt_badmotd\x18\x03\x20\x01(\rR\nrptBadmotd\x12)\n\x10rpt_list\
    ingabuse\x18\x04\x20\x01(\rR\x0frptListingabuse\x12-\n\x12rpt_inventorya\
    buse\x18\x05\x20\x01(\rR\x11rptInventoryabuse\x12\x19\n\x08match_id\x18\
    \x08\x20\x01(\x04R\x07matchId\"\xf4\x01\n'CMsgGCCStrike15_v2_ClientRepor\
    tResponse\x12'\n\x0fconfirmation_id\x18\x01\x20\x01(\x04R\x0econfirmatio\
    nId\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x1b\n\tserv\
    er_ip\x18\x03\x20\x01(\rR\x08serverIp\x12#\n\rresponse_type\x18\x04\x20\
    \x01(\rR\x0cresponseType\x12'\n\x0fresponse_result\x18\x05\x20\x01(\rR\
    \x0eresponseResult\x12\x16\n\x06tokens\x18\x06\x20\x01(\rR\x06tokens\"\
    \x8e\x02\n0CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\x12\x1d\n\nr\
    equest_id\x18\x01\x20\x01(\rR\trequestId\x12\x1f\n\x0baccount_ids\x18\
    \x02\x20\x03(\rR\naccountIds\x12\x1a\n\x08serverid\x18\x03\x20\x01(\x04R\
    \x08serverid\x12\x18\n\x07matchid\x18\x04\x20\x01(\x04R\x07matchid\x12'\
    \n\x0fclient_launcher\x18\x05\x20\x01(\rR\x0eclientLauncher\x12;\n\x11da\
    ta_center_pings\x18\x06\x20\x03(\x0b2\x0f.DataCenterPingR\x0fdataCenterP\
    ings\"\xd3\x03\n\x12WatchableMatchInfo\x12\x1b\n\tserver_ip\x18\x01\x20\
    \x01(\rR\x08serverIp\x12\x17\n\x07tv_port\x18\x02\x20\x01(\rR\x06tvPort\
    \x12#\n\rtv_spectators\x18\x03\x20\x01(\rR\x0ctvSpectators\x12\x17\n\x07\
    tv_time\x18\x04\x20\x01(\rR\x06tvTime\x12*\n\x11tv_watch_password\x18\
    \x05\x20\x01(\x0cR\x0ftvWatchPassword\x12,\n\x12cl_decryptdata_key\x18\
    \x06\x20\x01(\x04R\x10clDecryptdataKey\x123\n\x16cl_decryptdata_key_pub\
    \x18\x07\x20\x01(\x04R\x13clDecryptdataKeyPub\x12\x1b\n\tgame_type\x18\
    \x08\x20\x01(\rR\x08gameType\x12#\n\rgame_mapgroup\x18\t\x20\x01(\tR\x0c\
    gameMapgroup\x12\x19\n\x08game_map\x18\n\x20\x01(\tR\x07gameMap\x12\x1b\
    \n\tserver_id\x18\x0b\x20\x01(\x04R\x08serverId\x12\x19\n\x08match_id\
    \x18\x0c\x20\x01(\x04R\x07matchId\x12%\n\x0ereservation_id\x18\r\x20\x01\
    (\x04R\rreservationId\"\x82\x02\n.CMsgGCCStrike15_v2_ClientRequestJoinFr\
    iendData\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x1d\n\n\
    account_id\x18\x02\x20\x01(\rR\taccountId\x12\x1d\n\njoin_token\x18\x03\
    \x20\x01(\rR\tjoinToken\x12\x19\n\x08join_ipp\x18\x04\x20\x01(\rR\x07joi\
    nIpp\x12A\n\x03res\x18\x05\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matchmaking\
    GC2ClientReserveR\x03res\x12\x1a\n\x08errormsg\x18\x06\x20\x01(\tR\x08er\
    rormsg\"\xa2\x02\n.CMsgGCCStrike15_v2_ClientRequestJoinServerData\x12\
    \x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x1d\n\naccount_id\
    \x18\x02\x20\x01(\rR\taccountId\x12\x1a\n\x08serverid\x18\x03\x20\x01(\
    \x04R\x08serverid\x12\x1b\n\tserver_ip\x18\x04\x20\x01(\rR\x08serverIp\
    \x12\x1f\n\x0bserver_port\x18\x05\x20\x01(\rR\nserverPort\x12A\n\x03res\
    \x18\x06\x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserveR\
    \x03res\x12\x1a\n\x08errormsg\x18\x07\x20\x01(\tR\x08errormsg\"l\n*CMsgG\
    CCstrike15_v2_ClientRequestNewMission\x12\x1d\n\nmission_id\x18\x02\x20\
    \x01(\rR\tmissionId\x12\x1f\n\x0bcampaign_id\x18\x03\x20\x01(\rR\ncampai\
    gnId\"\xaf\x02\n,CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\x129\n\x10\
    xp_progress_data\x18\x01\x20\x03(\x0b2\x0f.XpProgressDataR\x0expProgress\
    Data\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x1d\n\ncur\
    rent_xp\x18\x03\x20\x01(\rR\tcurrentXp\x12#\n\rcurrent_level\x18\x04\x20\
    \x01(\rR\x0ccurrentLevel\x12'\n\x0fupgraded_defidx\x18\x05\x20\x01(\rR\
    \x0eupgradedDefidx\x128\n\x18operation_points_awarded\x18\x06\x20\x01(\r\
    R\x16operationPointsAwarded\"\xd7\x01\n!CMsgGCCStrike15_v2_WatchInfoUser\
    s\x12\x1d\n\nrequest_id\x18\x01\x20\x01(\rR\trequestId\x12\x1f\n\x0bacco\
    unt_ids\x18\x02\x20\x03(\rR\naccountIds\x12G\n\x15watchable_match_infos\
    \x18\x03\x20\x03(\x0b2\x13.WatchableMatchInfoR\x13watchableMatchInfos\
    \x12)\n\x10extended_timeout\x18\x05\x20\x01(\rR\x0fextendedTimeout\"\xe0\
    \x01\n.CMsgGCCStrike15_v2_ClientRequestPlayersProfile\x123\n\x16request_\
    id__deprecated\x18\x01\x20\x01(\rR\x13requestIdDeprecated\x125\n\x17acco\
    unt_ids__deprecated\x18\x02\x20\x03(\rR\x14accountIdsDeprecated\x12\x1d\
    \n\naccount_id\x18\x03\x20\x01(\rR\taccountId\x12#\n\rrequest_level\x18\
    \x04\x20\x01(\rR\x0crequestLevel\"\x9c\x01\n!CMsgGCCStrike15_v2_PlayersP\
    rofile\x12\x1d\n\nrequest_id\x18\x01\x20\x01(\rR\trequestId\x12X\n\x10ac\
    count_profiles\x18\x02\x20\x03(\x0b2-.CMsgGCCStrike15_v2_MatchmakingGC2C\
    lientHelloR\x0faccountProfiles\"\xa6\x02\n,CMsgGCCStrike15_v2_PlayerOver\
    watchCaseUpdate\x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\
    \x1c\n\tsuspectid\x18\x03\x20\x01(\rR\tsuspectid\x12\x1e\n\nfractionid\
    \x18\x04\x20\x01(\rR\nfractionid\x12\x1d\n\nrpt_aimbot\x18\x05\x20\x01(\
    \rR\trptAimbot\x12!\n\x0crpt_wallhack\x18\x06\x20\x01(\rR\x0brptWallhack\
    \x12#\n\rrpt_speedhack\x18\x07\x20\x01(\rR\x0crptSpeedhack\x12!\n\x0crpt\
    _teamharm\x18\x08\x20\x01(\rR\x0brptTeamharm\x12\x16\n\x06reason\x18\t\
    \x20\x01(\rR\x06reason\"\x90\x03\n0CMsgGCCStrike15_v2_PlayerOverwatchCas\
    eAssignment\x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\x18\
    \n\x07caseurl\x18\x02\x20\x01(\tR\x07caseurl\x12\x18\n\x07verdict\x18\
    \x03\x20\x01(\rR\x07verdict\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\rR\tti\
    mestamp\x12(\n\x0fthrottleseconds\x18\x05\x20\x01(\rR\x0fthrottleseconds\
    \x12\x1c\n\tsuspectid\x18\x06\x20\x01(\rR\tsuspectid\x12\x1e\n\nfraction\
    id\x18\x07\x20\x01(\rR\nfractionid\x12\x1c\n\tnumrounds\x18\x08\x20\x01(\
    \rR\tnumrounds\x12&\n\x0efractionrounds\x18\t\x20\x01(\rR\x0efractionrou\
    nds\x12,\n\x11streakconvictions\x18\n\x20\x01(\x05R\x11streakconvictions\
    \x12\x16\n\x06reason\x18\x0b\x20\x01(\rR\x06reason\"b\n,CMsgGCCStrike15_\
    v2_PlayerOverwatchCaseStatus\x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\
    \x06caseid\x12\x1a\n\x08statusid\x18\x02\x20\x01(\rR\x08statusid\"V\n\
    \x1eCClientHeaderOverwatchEvidence\x12\x1c\n\taccountid\x18\x01\x20\x01(\
    \rR\taccountid\x12\x16\n\x06caseid\x18\x02\x20\x01(\x04R\x06caseid\"c\n#\
    CMsgGCCStrike15_v2_GC2ClientTextMsg\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\
    \x02id\x12\x12\n\x04type\x18\x02\x20\x01(\rR\x04type\x12\x18\n\x07payloa\
    d\x18\x03\x20\x01(\x0cR\x07payload\"I\n#CMsgGCCStrike15_v2_Client2GCText\
    Msg\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04args\x18\x02\
    \x20\x03(\x0cR\x04args\"\xd5\x01\n)CMsgGCCStrike15_v2_MatchEndRunRewardD\
    rops\x12X\n\nserverinfo\x18\x03\x20\x01(\x0b28.CMsgGCCStrike15_v2_Matchm\
    akingServerReservationResponseR\nserverinfo\x12N\n\x14match_end_quest_da\
    ta\x18\x04\x20\x01(\x0b2\x1d.CMsgGC_ServerQuestUpdateDataR\x11matchEndQu\
    estData\"\xfd\x05\n\x19CEconItemPreviewDataBlock\x12\x1c\n\taccountid\
    \x18\x01\x20\x01(\rR\taccountid\x12\x16\n\x06itemid\x18\x02\x20\x01(\x04\
    R\x06itemid\x12\x1a\n\x08defindex\x18\x03\x20\x01(\rR\x08defindex\x12\
    \x1e\n\npaintindex\x18\x04\x20\x01(\rR\npaintindex\x12\x16\n\x06rarity\
    \x18\x05\x20\x01(\rR\x06rarity\x12\x18\n\x07quality\x18\x06\x20\x01(\rR\
    \x07quality\x12\x1c\n\tpaintwear\x18\x07\x20\x01(\rR\tpaintwear\x12\x1c\
    \n\tpaintseed\x18\x08\x20\x01(\rR\tpaintseed\x12.\n\x12killeaterscoretyp\
    e\x18\t\x20\x01(\rR\x12killeaterscoretype\x12&\n\x0ekilleatervalue\x18\n\
    \x20\x01(\rR\x0ekilleatervalue\x12\x1e\n\ncustomname\x18\x0b\x20\x01(\tR\
    \ncustomname\x12>\n\x08stickers\x18\x0c\x20\x03(\x0b2\".CEconItemPreview\
    DataBlock.StickerR\x08stickers\x12\x1c\n\tinventory\x18\r\x20\x01(\rR\ti\
    nventory\x12\x16\n\x06origin\x18\x0e\x20\x01(\rR\x06origin\x12\x18\n\x07\
    questid\x18\x0f\x20\x01(\rR\x07questid\x12\x1e\n\ndropreason\x18\x10\x20\
    \x01(\rR\ndropreason\x12\x1e\n\nmusicindex\x18\x11\x20\x01(\rR\nmusicind\
    ex\x12\x1a\n\x08entindex\x18\x12\x20\x01(\x05R\x08entindex\x1a\x9b\x01\n\
    \x07Sticker\x12\x12\n\x04slot\x18\x01\x20\x01(\rR\x04slot\x12\x1d\n\nsti\
    cker_id\x18\x02\x20\x01(\rR\tstickerId\x12\x12\n\x04wear\x18\x03\x20\x01\
    (\x02R\x04wear\x12\x14\n\x05scale\x18\x04\x20\x01(\x02R\x05scale\x12\x1a\
    \n\x08rotation\x18\x05\x20\x01(\x02R\x08rotation\x12\x17\n\x07tint_id\
    \x18\x06\x20\x01(\rR\x06tintId\"l\n2CMsgGCCStrike15_v2_MatchEndRewardDro\
    psNotification\x126\n\x08iteminfo\x18\x06\x20\x01(\x0b2\x1a.CEconItemPre\
    viewDataBlockR\x08iteminfo\"N\n\x14CMsgItemAcknowledged\x126\n\x08itemin\
    fo\x18\x01\x20\x01(\x0b2\x1a.CEconItemPreviewDataBlockR\x08iteminfo\"\
    \x9d\x01\n7CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\x12\
    \x17\n\x07param_s\x18\x01\x20\x01(\x04R\x06paramS\x12\x17\n\x07param_a\
    \x18\x02\x20\x01(\x04R\x06paramA\x12\x17\n\x07param_d\x18\x03\x20\x01(\
    \x04R\x06paramD\x12\x17\n\x07param_m\x18\x04\x20\x01(\x04R\x06paramM\"r\
    \n8CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\x126\n\x08it\
    eminfo\x18\x01\x20\x01(\x0b2\x1a.CEconItemPreviewDataBlockR\x08iteminfo\
    \"\x92\x01\n9CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\
    \x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1a\n\x08def\
    index\x18\x02\x20\x01(\rR\x08defindex\x12\x1e\n\naccountids\x18\x03\x20\
    \x03(\rR\naccountids\"5\n3CMsgGCCStrike15_v2_MatchListRequestCurrentLive\
    Games\"R\n2CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\x12\x1c\n\
    \taccountid\x18\x01\x20\x01(\rR\taccountid\"R\n2CMsgGCCStrike15_v2_Match\
    ListRequestRecentUserGames\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\tacc\
    ountid\"N\n2CMsgGCCStrike15_v2_MatchListRequestTournamentGames\x12\x18\n\
    \x07eventid\x18\x01\x20\x01(\x05R\x07eventid\"\x7f\n/CMsgGCCStrike15_v2_\
    MatchListRequestFullGameInfo\x12\x18\n\x07matchid\x18\x01\x20\x01(\x04R\
    \x07matchid\x12\x1c\n\toutcomeid\x18\x02\x20\x01(\x04R\toutcomeid\x12\
    \x14\n\x05token\x18\x03\x20\x01(\rR\x05token\"\xd1\x02\n\x1dCDataGCCStri\
    ke15_v2_MatchInfo\x12\x18\n\x07matchid\x18\x01\x20\x01(\x04R\x07matchid\
    \x12\x1c\n\tmatchtime\x18\x02\x20\x01(\rR\tmatchtime\x12C\n\x12watchable\
    matchinfo\x18\x03\x20\x01(\x0b2\x13.WatchableMatchInfoR\x12watchablematc\
    hinfo\x12\\\n\x11roundstats_legacy\x18\x04\x20\x01(\x0b2/.CMsgGCCStrike1\
    5_v2_MatchmakingServerRoundStatsR\x10roundstatsLegacy\x12U\n\rroundstats\
    all\x18\x05\x20\x03(\x0b2/.CMsgGCCStrike15_v2_MatchmakingServerRoundStat\
    sR\rroundstatsall\"z\n'CDataGCCStrike15_v2_TournamentGroupTeam\x12\x17\n\
    \x07team_id\x18\x01\x20\x01(\x05R\x06teamId\x12\x14\n\x05score\x18\x02\
    \x20\x01(\x05R\x05score\x12\x20\n\x0bcorrectpick\x18\x03\x20\x01(\x08R\
    \x0bcorrectpick\"\xd1\x03\n#CDataGCCStrike15_v2_TournamentGroup\x12\x18\
    \n\x07groupid\x18\x01\x20\x01(\rR\x07groupid\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x12\n\x04desc\x18\x03\x20\x01(\tR\x04desc\x12*\
    \n\x11picks__deprecated\x18\x04\x20\x01(\rR\x0fpicksDeprecated\x12>\n\
    \x05teams\x18\x05\x20\x03(\x0b2(.CDataGCCStrike15_v2_TournamentGroupTeam\
    R\x05teams\x12\x1b\n\tstage_ids\x18\x06\x20\x03(\x05R\x08stageIds\x12,\n\
    \x11picklockuntiltime\x18\x07\x20\x01(\rR\x11picklockuntiltime\x12$\n\rp\
    ickableteams\x18\x08\x20\x01(\rR\rpickableteams\x12&\n\x0fpoints_per_pic\
    k\x18\t\x20\x01(\rR\rpointsPerPick\x12@\n\x05picks\x18\n\x20\x03(\x0b2*.\
    CDataGCCStrike15_v2_TournamentGroup.PicksR\x05picks\x1a!\n\x05Picks\x12\
    \x18\n\x07pickids\x18\x01\x20\x03(\x05R\x07pickids\"\xab\x01\n%CDataGCCS\
    trike15_v2_TournamentSection\x12\x1c\n\tsectionid\x18\x01\x20\x01(\rR\ts\
    ectionid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04desc\
    \x18\x03\x20\x01(\tR\x04desc\x12<\n\x06groups\x18\x04\x20\x03(\x0b2$.CDa\
    taGCCStrike15_v2_TournamentGroupR\x06groups\"\xe1\x01\n\"CDataGCCStrike1\
    5_v2_TournamentInfo\x12B\n\x08sections\x18\x01\x20\x03(\x0b2&.CDataGCCSt\
    rike15_v2_TournamentSectionR\x08sections\x12;\n\x10tournament_event\x18\
    \x02\x20\x01(\x0b2\x10.TournamentEventR\x0ftournamentEvent\x12:\n\x10tou\
    rnament_teams\x18\x03\x20\x03(\x0b2\x0f.TournamentTeamR\x0ftournamentTea\
    ms\"\xb2\x02\n\x1cCMsgGCCStrike15_v2_MatchList\x12\"\n\x0cmsgrequestid\
    \x18\x01\x20\x01(\rR\x0cmsgrequestid\x12\x1c\n\taccountid\x18\x02\x20\
    \x01(\rR\taccountid\x12\x1e\n\nservertime\x18\x03\x20\x01(\rR\nservertim\
    e\x128\n\x07matches\x18\x04\x20\x03(\x0b2\x1e.CDataGCCStrike15_v2_MatchI\
    nfoR\x07matches\x12)\n\x07streams\x18\x05\x20\x03(\x0b2\x0f.TournamentTe\
    amR\x07streams\x12K\n\x0etournamentinfo\x18\x06\x20\x01(\x0b2#.CDataGCCS\
    trike15_v2_TournamentInfoR\x0etournamentinfo\"\xb9\x02\n\x1eCMsgGCCStrik\
    e15_v2_Predictions\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\
    \x12g\n\x16group_match_team_picks\x18\x02\x20\x03(\x0b22.CMsgGCCStrike15\
    _v2_Predictions.GroupMatchTeamPickR\x13groupMatchTeamPicks\x1a\x92\x01\n\
    \x12GroupMatchTeamPick\x12\x1c\n\tsectionid\x18\x01\x20\x01(\x05R\tsecti\
    onid\x12\x18\n\x07groupid\x18\x02\x20\x01(\x05R\x07groupid\x12\x14\n\x05\
    index\x18\x03\x20\x01(\x05R\x05index\x12\x16\n\x06teamid\x18\x04\x20\x01\
    (\x05R\x06teamid\x12\x16\n\x06itemid\x18\x05\x20\x01(\x04R\x06itemid\"\
    \xb1\x02\n\x1aCMsgGCCStrike15_v2_Fantasy\x12\x19\n\x08event_id\x18\x01\
    \x20\x01(\rR\x07eventId\x12=\n\x05teams\x18\x02\x20\x03(\x0b2'.CMsgGCCSt\
    rike15_v2_Fantasy.FantasyTeamR\x05teams\x1aM\n\x0bFantasySlot\x12\x12\n\
    \x04type\x18\x01\x20\x01(\x05R\x04type\x12\x12\n\x04pick\x18\x02\x20\x01\
    (\x05R\x04pick\x12\x16\n\x06itemid\x18\x03\x20\x01(\x04R\x06itemid\x1aj\
    \n\x0bFantasyTeam\x12\x1c\n\tsectionid\x18\x01\x20\x01(\x05R\tsectionid\
    \x12=\n\x05slots\x18\x02\x20\x03(\x0b2'.CMsgGCCStrike15_v2_Fantasy.Fanta\
    sySlotR\x05slots\")\n\x11CAttribute_String\x12\x14\n\x05value\x18\x01\
    \x20\x01(\tR\x05value\"\x1a\n\x18CMsgGCToGCReloadVersions\"\xb2\x02\n\
    \x14CMsgCStrike15Welcome\x12&\n\x0fstore_item_hash\x18\x05\x20\x01(\rR\r\
    storeItemHash\x128\n\x17timeplayedconsecutively\x18\x06\x20\x01(\rR\x17t\
    imeplayedconsecutively\x12*\n\x11time_first_played\x18\n\x20\x01(\rR\x0f\
    timeFirstPlayed\x12(\n\x10last_time_played\x18\x0c\x20\x01(\rR\x0elastTi\
    mePlayed\x12&\n\x0flast_ip_address\x18\r\x20\x01(\rR\rlastIpAddress\x12\
    \x1e\n\ngscookieid\x18\x12\x20\x01(\x04R\ngscookieid\x12\x1a\n\x08unique\
    id\x18\x13\x20\x01(\x04R\x08uniqueid\"\xd6\x01\n1CMsgGCCStrike15_v2_Clie\
    ntVarValueNotificationInfo\x12\x1d\n\nvalue_name\x18\x01\x20\x01(\tR\tva\
    lueName\x12\x1b\n\tvalue_int\x18\x02\x20\x01(\x05R\x08valueInt\x12\x1f\n\
    \x0bserver_addr\x18\x03\x20\x01(\rR\nserverAddr\x12\x1f\n\x0bserver_port\
    \x18\x04\x20\x01(\rR\nserverPort\x12#\n\rchoked_blocks\x18\x05\x20\x03(\
    \tR\x0cchokedBlocks\"\x85\x01\n1CMsgGCCStrike15_v2_ServerVarValueNotific\
    ationInfo\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x1e\n\
    \nviewangles\x18\x02\x20\x03(\rR\nviewangles\x12\x12\n\x04type\x18\x03\
    \x20\x01(\rR\x04type\",\n*CMsgGCCStrike15_v2_GiftsLeaderboardRequest\"\
    \xf5\x02\n+CMsgGCCStrike15_v2_GiftsLeaderboardResponse\x12\x1e\n\nserver\
    time\x18\x01\x20\x01(\rR\nservertime\x12.\n\x13time_period_seconds\x18\
    \x02\x20\x01(\rR\x11timePeriodSeconds\x12*\n\x11total_gifts_given\x18\
    \x03\x20\x01(\rR\x0ftotalGiftsGiven\x12!\n\x0ctotal_givers\x18\x04\x20\
    \x01(\rR\x0btotalGivers\x12[\n\x07entries\x18\x05\x20\x03(\x0b2A.CMsgGCC\
    Strike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntryR\x07entries\
    \x1aJ\n\x14GiftLeaderboardEntry\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\
    \taccountid\x12\x14\n\x05gifts\x18\x02\x20\x01(\rR\x05gifts\"\\\n)CMsgGC\
    CStrike15_v2_ClientSubmitSurveyVote\x12\x1b\n\tsurvey_id\x18\x01\x20\x01\
    (\rR\x08surveyId\x12\x12\n\x04vote\x18\x02\x20\x01(\rR\x04vote\"J\n*CMsg\
    GCCStrike15_v2_Server2GCClientValidate\x12\x1c\n\taccountid\x18\x01\x20\
    \x01(\rR\taccountid\"\xfa\x01\n7CMsgGCCStrike15_v2_Server2GCPureServerVa\
    lidationFailure\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\
    \x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\x12\n\x04file\x18\x03\x20\
    \x01(\tR\x04file\x12\x10\n\x03crc\x18\x04\x20\x01(\rR\x03crc\x12\x12\n\
    \x04hash\x18\x05\x20\x01(\x05R\x04hash\x12\x10\n\x03len\x18\x06\x20\x01(\
    \x05R\x03len\x12\x1f\n\x0bpack_number\x18\x07\x20\x01(\x05R\npackNumber\
    \x12\x20\n\x0cpack_file_id\x18\x08\x20\x01(\x05R\npackFileId\"\x97\x01\n\
    *CMsgGCCStrike15_v2_GC2ClientTournamentInfo\x12\x18\n\x07eventid\x18\x01\
    \x20\x01(\rR\x07eventid\x12\x18\n\x07stageid\x18\x02\x20\x01(\rR\x07stag\
    eid\x12\x1b\n\tgame_type\x18\x03\x20\x01(\rR\x08gameType\x12\x18\n\x07te\
    amids\x18\x04\x20\x03(\rR\x07teamids\"p\n\rCSOEconCoupon\x12\x1e\n\x07en\
    tryid\x18\x01\x20\x01(\rR\x07entryidB\x04\x80\xa6\x1d\x01\x12\x16\n\x06d\
    efidx\x18\x02\x20\x01(\rR\x06defidx\x12'\n\x0fexpiration_date\x18\x03\
    \x20\x01(\x07R\x0eexpirationDate\"\x80\x01\n\x10CSOQuestProgress\x12\x1e\
    \n\x07questid\x18\x01\x20\x01(\rR\x07questidB\x04\x80\xa6\x1d\x01\x12)\n\
    \x10points_remaining\x18\x02\x20\x01(\rR\x0fpointsRemaining\x12!\n\x0cbo\
    nus_points\x18\x03\x20\x01(\rR\x0bbonusPoints\"\x9d\x01\n\x14CSOPersonaD\
    ataPublic\x12!\n\x0cplayer_level\x18\x01\x20\x01(\x05R\x0bplayerLevel\
    \x12;\n\x0ccommendation\x18\x02\x20\x01(\x0b2\x17.PlayerCommendationInfo\
    R\x0ccommendation\x12%\n\x0eelevated_state\x18\x03\x20\x01(\x08R\relevat\
    edState\"5\n\x1bCMsgGC_GlobalGame_Subscribe\x12\x16\n\x06ticket\x18\x01\
    \x20\x01(\x04R\x06ticket\";\n\x1dCMsgGC_GlobalGame_Unsubscribe\x12\x1a\n\
    \x08timeleft\x18\x01\x20\x01(\x05R\x08timeleft\"p\n\x16CMsgGC_GlobalGame\
    _Play\x12\x16\n\x06ticket\x18\x01\x20\x01(\x04R\x06ticket\x12\x1e\n\ngam\
    etimems\x18\x02\x20\x01(\rR\ngametimems\x12\x1e\n\nmsperpoint\x18\x03\
    \x20\x01(\rR\nmsperpoint\"K\n%CMsgGCCStrike15_v2_AcknowledgePenalty\x12\
    \"\n\x0cacknowledged\x18\x01\x20\x01(\x05R\x0cacknowledged\"\xa5\x01\n/C\
    MsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\x12\x1a\n\x08defindex\x18\
    \x01\x20\x01(\rR\x08defindex\x12\x1c\n\tupgradeid\x18\x02\x20\x01(\x04R\
    \tupgradeid\x12\x14\n\x05hours\x18\x03\x20\x01(\rR\x05hours\x12\"\n\x0cp\
    restigetime\x18\x04\x20\x01(\rR\x0cprestigetime\"R\n(CMsgGCCStrike15_v2_\
    Client2GCStreamUnlock\x12\x16\n\x06ticket\x18\x01\x20\x01(\x04R\x06ticke\
    t\x12\x0e\n\x02os\x18\x02\x20\x01(\x05R\x02os\"C\n+CMsgGCCStrike15_v2_Cl\
    ientToGCRequestElevate\x12\x14\n\x05stage\x18\x01\x20\x01(\rR\x05stage\"\
    R\n!CMsgGCCStrike15_v2_ClientToGCChat\x12\x19\n\x08match_id\x18\x01\x20\
    \x01(\x04R\x07matchId\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\"V\n\
    !CMsgGCCStrike15_v2_GCToClientChat\x12\x1d\n\naccount_id\x18\x01\x20\x01\
    (\rR\taccountId\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\"T\n$CMsgG\
    CCStrike15_v2_ClientAuthKeyCode\x12\x18\n\x07eventid\x18\x01\x20\x01(\rR\
    \x07eventid\x12\x12\n\x04code\x18\x02\x20\x01(\tR\x04code\"L\n\x1eCMsgGC\
    CStrike15_GotvSyncPacket\x12*\n\x04data\x18\x01\x20\x01(\x0b2\x16.CEngin\
    eGotvSyncPacketR\x04data\"\x98\x03\n\x1bPlayerDecalDigitalSignature\x12\
    \x1c\n\tsignature\x18\x01\x20\x01(\x0cR\tsignature\x12\x1c\n\taccountid\
    \x18\x02\x20\x01(\rR\taccountid\x12\x14\n\x05rtime\x18\x03\x20\x01(\rR\
    \x05rtime\x12\x16\n\x06endpos\x18\x04\x20\x03(\x02R\x06endpos\x12\x1a\n\
    \x08startpos\x18\x05\x20\x03(\x02R\x08startpos\x12\x14\n\x05right\x18\
    \x06\x20\x03(\x02R\x05right\x12\x1b\n\ttx_defidx\x18\x07\x20\x01(\rR\x08\
    txDefidx\x12\x1a\n\x08entindex\x18\x08\x20\x01(\x05R\x08entindex\x12\x16\
    \n\x06hitbox\x18\t\x20\x01(\rR\x06hitbox\x12\"\n\x0ccreationtime\x18\n\
    \x20\x01(\x02R\x0ccreationtime\x12\x1c\n\tequipslot\x18\x0b\x20\x01(\rR\
    \tequipslot\x12\x19\n\x08trace_id\x18\x0c\x20\x01(\rR\x07traceId\x12\x16\
    \n\x06normal\x18\r\x20\x03(\x02R\x06normal\x12\x17\n\x07tint_id\x18\x0e\
    \x20\x01(\rR\x06tintId\"t\n(CMsgGCCStrike15_v2_ClientPlayerDecalSign\x12\
    0\n\x04data\x18\x01\x20\x01(\x0b2\x1c.PlayerDecalDigitalSignatureR\x04da\
    ta\x12\x16\n\x06itemid\x18\x02\x20\x01(\x04R\x06itemid\"|\n(CMsgGCCStrik\
    e15_v2_ClientLogonFatalError\x12\x1c\n\terrorcode\x18\x01\x20\x01(\rR\te\
    rrorcode\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\x12\x18\n\
    \x07country\x18\x03\x20\x01(\tR\x07country\"j\n\"CMsgGCCStrike15_v2_Clie\
    ntPollState\x12\x16\n\x06pollid\x18\x01\x20\x01(\rR\x06pollid\x12\x14\n\
    \x05names\x18\x02\x20\x03(\tR\x05names\x12\x16\n\x06values\x18\x03\x20\
    \x03(\x05R\x06values\"\xdc\x01\n!CMsgGCCStrike15_v2_Party_Register\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x10\n\x03ver\x18\x02\x20\x01(\
    \rR\x03ver\x12\x10\n\x03apr\x18\x03\x20\x01(\rR\x03apr\x12\x10\n\x03ark\
    \x18\x04\x20\x01(\rR\x03ark\x12\x10\n\x03nby\x18\x05\x20\x01(\rR\x03nby\
    \x12\x10\n\x03grp\x18\x06\x20\x01(\rR\x03grp\x12\x14\n\x05slots\x18\x07\
    \x20\x01(\rR\x05slots\x12\x1a\n\x08launcher\x18\x08\x20\x01(\rR\x08launc\
    her\x12\x1b\n\tgame_type\x18\t\x20\x01(\rR\x08gameType\"\xa4\x01\n\x1fCM\
    sgGCCStrike15_v2_Party_Search\x12\x10\n\x03ver\x18\x01\x20\x01(\rR\x03ve\
    r\x12\x10\n\x03apr\x18\x02\x20\x01(\rR\x03apr\x12\x10\n\x03ark\x18\x03\
    \x20\x01(\rR\x03ark\x12\x12\n\x04grps\x18\x04\x20\x03(\rR\x04grps\x12\
    \x1a\n\x08launcher\x18\x05\x20\x01(\rR\x08launcher\x12\x1b\n\tgame_type\
    \x18\x06\x20\x01(\rR\x08gameType\"\xef\x01\n&CMsgGCCStrike15_v2_Party_Se\
    archResults\x12G\n\x07entries\x18\x01\x20\x03(\x0b2-.CMsgGCCStrike15_v2_\
    Party_SearchResults.EntryR\x07entries\x1a|\n\x05Entry\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\rR\x02id\x12\x10\n\x03grp\x18\x02\x20\x01(\rR\x03grp\
    \x12\x1b\n\tgame_type\x18\x03\x20\x01(\rR\x08gameType\x12\x10\n\x03apr\
    \x18\x04\x20\x01(\rR\x03apr\x12\x10\n\x03ark\x18\x05\x20\x01(\rR\x03ark\
    \x12\x10\n\x03loc\x18\x06\x20\x01(\rR\x03loc\"Y\n\x1fCMsgGCCStrike15_v2_\
    Party_Invite\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x18\
    \n\x07lobbyid\x18\x02\x20\x01(\rR\x07lobbyid\"\xf4\x01\n)CMsgGCCStrike15\
    _v2_Account_RequestCoPlays\x12K\n\x07players\x18\x01\x20\x03(\x0b21.CMsg\
    GCCStrike15_v2_Account_RequestCoPlays.PlayerR\x07players\x12\x1e\n\nserv\
    ertime\x18\x02\x20\x01(\rR\nservertime\x1aZ\n\x06Player\x12\x1c\n\taccou\
    ntid\x18\x01\x20\x01(\rR\taccountid\x12\x1a\n\x08rtcoplay\x18\x02\x20\
    \x01(\rR\x08rtcoplay\x12\x16\n\x06online\x18\x03\x20\x01(\x08R\x06online\
    \"\xf4\x01\n*CMsgGCCStrike15_v2_ClientToGCRequestTicket\x12.\n\x13author\
    ized_steam_id\x18\x01\x20\x01(\x06R\x11authorizedSteamId\x120\n\x14autho\
    rized_public_ip\x18\x02\x20\x01(\x07R\x12authorizedPublicIp\x12.\n\x13ga\
    meserver_steam_id\x18\x03\x20\x01(\x06R\x11gameserverSteamId\x124\n\x16g\
    ameserver_sdr_routing\x18\x05\x20\x01(\tR\x14gameserverSdrRouting\"P\n!C\
    MsgGCToClientSteamDatagramTicket\x12+\n\x11serialized_ticket\x18\x10\x20\
    \x01(\x0cR\x10serializedTicket\"(\n&CMsgGCCStrike15_v2_ClientRequestOffe\
    rs\"v\n(CMsgGCCStrike15_v2_ClientRequestSouvenir\x12\x16\n\x06itemid\x18\
    \x01\x20\x01(\x04R\x06itemid\x12\x18\n\x07matchid\x18\x02\x20\x01(\x04R\
    \x07matchid\x12\x18\n\x07eventid\x18\x03\x20\x01(\x05R\x07eventid\"S\n'C\
    MsgGCCStrike15_v2_ClientAccountBalance\x12\x16\n\x06amount\x18\x01\x20\
    \x01(\x04R\x06amount\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\"a\n'CM\
    sgGCCStrike15_v2_ClientPartyJoinRelay\x12\x1c\n\taccountid\x18\x01\x20\
    \x01(\rR\taccountid\x12\x18\n\x07lobbyid\x18\x02\x20\x01(\x04R\x07lobbyi\
    d\"\xb2\x01\n%CMsgGCCStrike15_v2_ClientPartyWarning\x12F\n\x07entries\
    \x18\x01\x20\x03(\x0b2,.CMsgGCCStrike15_v2_ClientPartyWarning.EntryR\x07\
    entries\x1aA\n\x05Entry\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccoun\
    tid\x12\x1a\n\x08warntype\x18\x02\x20\x01(\rR\x08warntype\"`\n#CMsgGCCSt\
    rike15_v2_SetEventFavorite\x12\x18\n\x07eventid\x18\x01\x20\x01(\x04R\
    \x07eventid\x12\x1f\n\x0bis_favorite\x18\x02\x20\x01(\x08R\nisFavorite\"\
    M\n,CMsgGCCStrike15_v2_GetEventFavorites_Request\x12\x1d\n\nall_events\
    \x18\x01\x20\x01(\x08R\tallEvents\"\x9a\x01\n-CMsgGCCStrike15_v2_GetEven\
    tFavorites_Response\x12\x1d\n\nall_events\x18\x01\x20\x01(\x08R\tallEven\
    ts\x12%\n\x0ejson_favorites\x18\x02\x20\x01(\tR\rjsonFavorites\x12#\n\rj\
    son_featured\x18\x03\x20\x01(\tR\x0cjsonFeatured*\xb9'\n\nECsgoGCMsg\x12\
    \x1e\n\x19k_EMsgGCCStrike15_v2_Base\x10\x8cG\x12*\n%k_EMsgGCCStrike15_v2\
    _MatchmakingStart\x10\x8dG\x12)\n$k_EMsgGCCStrike15_v2_MatchmakingStop\
    \x10\x8eG\x126\n1k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing\x10\
    \x8fG\x124\n/k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\x10\x90G\
    \x125\n0k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\x10\x91G\x12>\n\
    9k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse\x10\x92G\x125\
    \n0k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\x10\x93G\x125\n0k_EM\
    sgGCCStrike15_v2_MatchmakingServerRoundStats\x10\x94G\x123\n.k_EMsgGCCSt\
    rike15_v2_MatchmakingClient2GCHello\x10\x95G\x123\n.k_EMsgGCCStrike15_v2\
    _MatchmakingGC2ClientHello\x10\x96G\x123\n.k_EMsgGCCStrike15_v2_Matchmak\
    ingServerMatchEnd\x10\x97G\x125\n0k_EMsgGCCStrike15_v2_MatchmakingGC2Cli\
    entAbandon\x10\x98G\x122\n-k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick\
    \x10\x99G\x125\n0k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\x10\
    \x9aG\x127\n2k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats\x10\x9bG\
    \x128\n3k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\x10\x9cG\x12\
    :\n5k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\x10\x9dG\x12:\
    \n5k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty\x10\x9eG\x12,\n\
    'k_EMsgGCCStrike15_v2_ClientReportPlayer\x10\x9fG\x12,\n'k_EMsgGCCStrike\
    15_v2_ClientReportServer\x10\xa0G\x12-\n(k_EMsgGCCStrike15_v2_ClientComm\
    endPlayer\x10\xa1G\x12.\n)k_EMsgGCCStrike15_v2_ClientReportResponse\x10\
    \xa2G\x122\n-k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery\x10\xa3G\x12:\
    \n5k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse\x10\xa4G\x12(\n\
    #k_EMsgGCCStrike15_v2_WatchInfoUsers\x10\xa6G\x125\n0k_EMsgGCCStrike15_v\
    2_ClientRequestPlayersProfile\x10\xa7G\x12(\n#k_EMsgGCCStrike15_v2_Playe\
    rsProfile\x10\xa8G\x123\n.k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\
    \x10\xabG\x127\n2k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\x10\
    \xacG\x123\n.k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\x10\xadG\x12\
    *\n%k_EMsgGCCStrike15_v2_GC2ClientTextMsg\x10\xaeG\x12*\n%k_EMsgGCCStrik\
    e15_v2_Client2GCTextMsg\x10\xafG\x120\n+k_EMsgGCCStrike15_v2_MatchEndRun\
    RewardDrops\x10\xb0G\x129\n4k_EMsgGCCStrike15_v2_MatchEndRewardDropsNoti\
    fication\x10\xb1G\x128\n3k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFrie\
    nds2\x10\xb2G\x12#\n\x1ek_EMsgGCCStrike15_v2_MatchList\x10\xb3G\x12:\n5k\
    _EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\x10\xb4G\x129\n4k_E\
    MsgGCCStrike15_v2_MatchListRequestRecentUserGames\x10\xb5G\x124\n/k_EMsg\
    GCCStrike15_v2_GC2ServerReservationUpdate\x10\xb6G\x128\n3k_EMsgGCCStrik\
    e15_v2_ClientVarValueNotificationInfo\x10\xb8G\x12@\n;k_EMsgGCCStrike15_\
    v2_TournamentMatchRewardDropsNotification\x10\xb9G\x129\n4k_EMsgGCCStrik\
    e15_v2_MatchListRequestTournamentGames\x10\xbaG\x126\n1k_EMsgGCCStrike15\
    _v2_MatchListRequestFullGameInfo\x10\xbbG\x121\n,k_EMsgGCCStrike15_v2_Gi\
    ftsLeaderboardRequest\x10\xbcG\x122\n-k_EMsgGCCStrike15_v2_GiftsLeaderbo\
    ardResponse\x10\xbdG\x128\n3k_EMsgGCCStrike15_v2_ServerVarValueNotificat\
    ionInfo\x10\xbeG\x12\x1f\n\x1ak_EMsgGCToGCReloadVersions\x10\xbfG\x120\n\
    +k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote\x10\xc0G\x121\n,k_EMsgGCCSt\
    rike15_v2_Server2GCClientValidate\x10\xc1G\x129\n4k_EMsgGCCStrike15_v2_M\
    atchListRequestLiveGameForUser\x10\xc2G\x12>\n9k_EMsgGCCStrike15_v2_Serv\
    er2GCPureServerValidationFailure\x10\xc3G\x12>\n9k_EMsgGCCStrike15_v2_Cl\
    ient2GCEconPreviewDataBlockRequest\x10\xc4G\x12?\n:k_EMsgGCCStrike15_v2_\
    Client2GCEconPreviewDataBlockResponse\x10\xc5G\x120\n+k_EMsgGCCStrike15_\
    v2_AccountPrivacySettings\x10\xc6G\x12+\n&k_EMsgGCCStrike15_v2_SetMyActi\
    vityInfo\x10\xc7G\x12?\n:k_EMsgGCCStrike15_v2_MatchListRequestTournament\
    Predictions\x10\xc8G\x12>\n9k_EMsgGCCStrike15_v2_MatchListUploadTourname\
    ntPredictions\x10\xc9G\x12&\n!k_EMsgGCCStrike15_v2_DraftSummary\x10\xcaG\
    \x125\n0k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData\x10\xcbG\x125\n\
    0k_EMsgGCCStrike15_v2_ClientRequestJoinServerData\x10\xccG\x121\n,k_EMsg\
    GCCStrike15_v2_ClientRequestNewMission\x10\xcdG\x123\n.k_EMsgGCCStrike15\
    _v2_GC2ServerNotifyXPRewarded\x10\xceG\x121\n,k_EMsgGCCStrike15_v2_GC2Cl\
    ientTournamentInfo\x10\xcfG\x12\"\n\x1dk_EMsgGC_GlobalGame_Subscribe\x10\
    \xd0G\x12$\n\x1fk_EMsgGC_GlobalGame_Unsubscribe\x10\xd1G\x12\x1d\n\x18k_\
    EMsgGC_GlobalGame_Play\x10\xd2G\x12,\n'k_EMsgGCCStrike15_v2_AcknowledgeP\
    enalty\x10\xd3G\x126\n1k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\
    \x10\xd4G\x12.\n)k_EMsgGCCStrike15_v2_GC2ClientGlobalStats\x10\xd5G\x12/\
    \n*k_EMsgGCCStrike15_v2_Client2GCStreamUnlock\x10\xd6G\x122\n-k_EMsgGCCS\
    trike15_v2_FantasyRequestClientData\x10\xd7G\x121\n,k_EMsgGCCStrike15_v2\
    _FantasyUpdateClientData\x10\xd8G\x127\n2k_EMsgGCCStrike15_v2_GCToClient\
    SteamdatagramTicket\x10\xd9G\x121\n,k_EMsgGCCStrike15_v2_ClientToGCReque\
    stTicket\x10\xdaG\x122\n-k_EMsgGCCStrike15_v2_ClientToGCRequestElevate\
    \x10\xdbG\x12$\n\x1fk_EMsgGCCStrike15_v2_GlobalChat\x10\xdcG\x12.\n)k_EM\
    sgGCCStrike15_v2_GlobalChat_Subscribe\x10\xddG\x120\n+k_EMsgGCCStrike15_\
    v2_GlobalChat_Unsubscribe\x10\xdeG\x12+\n&k_EMsgGCCStrike15_v2_ClientAut\
    hKeyCode\x10\xdfG\x12(\n#k_EMsgGCCStrike15_v2_GotvSyncPacket\x10\xe0G\
    \x12/\n*k_EMsgGCCStrike15_v2_ClientPlayerDecalSign\x10\xe1G\x12/\n*k_EMs\
    gGCCStrike15_v2_ClientLogonFatalError\x10\xe3G\x12)\n$k_EMsgGCCStrike15_\
    v2_ClientPollState\x10\xe4G\x12(\n#k_EMsgGCCStrike15_v2_Party_Register\
    \x10\xe5G\x12*\n%k_EMsgGCCStrike15_v2_Party_Unregister\x10\xe6G\x12&\n!k\
    _EMsgGCCStrike15_v2_Party_Search\x10\xe7G\x12&\n!k_EMsgGCCStrike15_v2_Pa\
    rty_Invite\x10\xe8G\x120\n+k_EMsgGCCStrike15_v2_Account_RequestCoPlays\
    \x10\xe9G\x12,\n'k_EMsgGCCStrike15_v2_ClientGCRankUpdate\x10\xeaG\x12-\n\
    (k_EMsgGCCStrike15_v2_ClientRequestOffers\x10\xebG\x12.\n)k_EMsgGCCStrik\
    e15_v2_ClientAccountBalance\x10\xecG\x12.\n)k_EMsgGCCStrike15_v2_ClientP\
    artyJoinRelay\x10\xedG\x12,\n'k_EMsgGCCStrike15_v2_ClientPartyWarning\
    \x10\xeeG\x12:\n5k_EMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial\
    \x10\xefG\x12*\n%k_EMsgGCCStrike15_v2_SetEventFavorite\x10\xf0G\x123\n.k\
    _EMsgGCCStrike15_v2_GetEventFavorites_Request\x10\xf1G\x124\n/k_EMsgGCCS\
    trike15_v2_GetEventFavorites_Response\x10\xf3G\x12/\n*k_EMsgGCCStrike15_\
    v2_ClientRequestSouvenir\x10\xf4G*\x98\x01\n\x12ECsgoSteamUserStat\x12&\
    \n\"k_ECsgoSteamUserStat_XpEarnedGames\x10\x01\x12-\n)k_ECsgoSteamUserSt\
    at_MatchWinsCompetitive\x10\x02\x12+\n'k_ECsgoSteamUserStat_SurvivedDang\
    erZone\x10\x03B\x05H\x01\x80\x01\0\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
