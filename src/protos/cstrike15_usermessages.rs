// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cstrike15_usermessages.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VGUIMenu {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    show: ::std::option::Option<bool>,
    subkeys: ::protobuf::RepeatedField<CCSUsrMsg_VGUIMenu_Subkey>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VGUIMenu {
    fn default() -> &'a CCSUsrMsg_VGUIMenu {
        <CCSUsrMsg_VGUIMenu as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VGUIMenu {
    pub fn new() -> CCSUsrMsg_VGUIMenu {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool show = 2;


    pub fn get_show(&self) -> bool {
        self.show.unwrap_or(false)
    }
    pub fn clear_show(&mut self) {
        self.show = ::std::option::Option::None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = ::std::option::Option::Some(v);
    }

    // repeated .CCSUsrMsg_VGUIMenu.Subkey subkeys = 3;


    pub fn get_subkeys(&self) -> &[CCSUsrMsg_VGUIMenu_Subkey] {
        &self.subkeys
    }
    pub fn clear_subkeys(&mut self) {
        self.subkeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_subkeys(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_VGUIMenu_Subkey>) {
        self.subkeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subkeys(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_VGUIMenu_Subkey> {
        &mut self.subkeys
    }

    // Take field
    pub fn take_subkeys(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_VGUIMenu_Subkey> {
        ::std::mem::replace(&mut self.subkeys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_VGUIMenu {
    fn is_initialized(&self) -> bool {
        for v in &self.subkeys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subkeys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.show {
            my_size += 2;
        }
        for value in &self.subkeys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.show {
            os.write_bool(2, v)?;
        }
        for v in &self.subkeys {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VGUIMenu {
        CCSUsrMsg_VGUIMenu::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CCSUsrMsg_VGUIMenu| { &m.name },
                    |m: &mut CCSUsrMsg_VGUIMenu| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show",
                    |m: &CCSUsrMsg_VGUIMenu| { &m.show },
                    |m: &mut CCSUsrMsg_VGUIMenu| { &mut m.show },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_VGUIMenu_Subkey>>(
                    "subkeys",
                    |m: &CCSUsrMsg_VGUIMenu| { &m.subkeys },
                    |m: &mut CCSUsrMsg_VGUIMenu| { &mut m.subkeys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_VGUIMenu>(
                    "CCSUsrMsg_VGUIMenu",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_VGUIMenu {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_VGUIMenu> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_VGUIMenu,
        };
        unsafe {
            instance.get(CCSUsrMsg_VGUIMenu::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VGUIMenu {
    fn clear(&mut self) {
        self.name.clear();
        self.show = ::std::option::Option::None;
        self.subkeys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VGUIMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VGUIMenu {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VGUIMenu_Subkey {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    str: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VGUIMenu_Subkey {
    fn default() -> &'a CCSUsrMsg_VGUIMenu_Subkey {
        <CCSUsrMsg_VGUIMenu_Subkey as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VGUIMenu_Subkey {
    pub fn new() -> CCSUsrMsg_VGUIMenu_Subkey {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string str = 2;


    pub fn get_str(&self) -> &str {
        match self.str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_str(&mut self) {
        self.str.clear();
    }

    pub fn has_str(&self) -> bool {
        self.str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_str(&mut self, v: ::std::string::String) {
        self.str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_str(&mut self) -> &mut ::std::string::String {
        if self.str.is_none() {
            self.str.set_default();
        }
        self.str.as_mut().unwrap()
    }

    // Take field
    pub fn take_str(&mut self) -> ::std::string::String {
        self.str.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_VGUIMenu_Subkey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.str)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.str.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.str.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VGUIMenu_Subkey {
        CCSUsrMsg_VGUIMenu_Subkey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CCSUsrMsg_VGUIMenu_Subkey| { &m.name },
                    |m: &mut CCSUsrMsg_VGUIMenu_Subkey| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "str",
                    |m: &CCSUsrMsg_VGUIMenu_Subkey| { &m.str },
                    |m: &mut CCSUsrMsg_VGUIMenu_Subkey| { &mut m.str },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_VGUIMenu_Subkey>(
                    "CCSUsrMsg_VGUIMenu_Subkey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_VGUIMenu_Subkey {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_VGUIMenu_Subkey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_VGUIMenu_Subkey,
        };
        unsafe {
            instance.get(CCSUsrMsg_VGUIMenu_Subkey::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VGUIMenu_Subkey {
    fn clear(&mut self) {
        self.name.clear();
        self.str.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VGUIMenu_Subkey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VGUIMenu_Subkey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Geiger {
    // message fields
    range: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Geiger {
    fn default() -> &'a CCSUsrMsg_Geiger {
        <CCSUsrMsg_Geiger as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Geiger {
    pub fn new() -> CCSUsrMsg_Geiger {
        ::std::default::Default::default()
    }

    // optional int32 range = 1;


    pub fn get_range(&self) -> i32 {
        self.range.unwrap_or(0)
    }
    pub fn clear_range(&mut self) {
        self.range = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: i32) {
        self.range = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_Geiger {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.range = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.range {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.range {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Geiger {
        CCSUsrMsg_Geiger::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "range",
                    |m: &CCSUsrMsg_Geiger| { &m.range },
                    |m: &mut CCSUsrMsg_Geiger| { &mut m.range },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_Geiger>(
                    "CCSUsrMsg_Geiger",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_Geiger {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_Geiger> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_Geiger,
        };
        unsafe {
            instance.get(CCSUsrMsg_Geiger::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Geiger {
    fn clear(&mut self) {
        self.range = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Geiger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Geiger {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Train {
    // message fields
    train: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Train {
    fn default() -> &'a CCSUsrMsg_Train {
        <CCSUsrMsg_Train as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Train {
    pub fn new() -> CCSUsrMsg_Train {
        ::std::default::Default::default()
    }

    // optional int32 train = 1;


    pub fn get_train(&self) -> i32 {
        self.train.unwrap_or(0)
    }
    pub fn clear_train(&mut self) {
        self.train = ::std::option::Option::None;
    }

    pub fn has_train(&self) -> bool {
        self.train.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train(&mut self, v: i32) {
        self.train = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_Train {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.train = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.train {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.train {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Train {
        CCSUsrMsg_Train::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "train",
                    |m: &CCSUsrMsg_Train| { &m.train },
                    |m: &mut CCSUsrMsg_Train| { &mut m.train },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_Train>(
                    "CCSUsrMsg_Train",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_Train {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_Train> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_Train,
        };
        unsafe {
            instance.get(CCSUsrMsg_Train::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Train {
    fn clear(&mut self) {
        self.train = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Train {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Train {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_HudText {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HudText {
    fn default() -> &'a CCSUsrMsg_HudText {
        <CCSUsrMsg_HudText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HudText {
    pub fn new() -> CCSUsrMsg_HudText {
        ::std::default::Default::default()
    }

    // optional string text = 1;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_HudText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_HudText {
        CCSUsrMsg_HudText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CCSUsrMsg_HudText| { &m.text },
                    |m: &mut CCSUsrMsg_HudText| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_HudText>(
                    "CCSUsrMsg_HudText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_HudText {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_HudText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_HudText,
        };
        unsafe {
            instance.get(CCSUsrMsg_HudText::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_HudText {
    fn clear(&mut self) {
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_HudText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_HudText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SayText {
    // message fields
    ent_idx: ::std::option::Option<i32>,
    text: ::protobuf::SingularField<::std::string::String>,
    chat: ::std::option::Option<bool>,
    textallchat: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SayText {
    fn default() -> &'a CCSUsrMsg_SayText {
        <CCSUsrMsg_SayText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SayText {
    pub fn new() -> CCSUsrMsg_SayText {
        ::std::default::Default::default()
    }

    // optional int32 ent_idx = 1;


    pub fn get_ent_idx(&self) -> i32 {
        self.ent_idx.unwrap_or(0)
    }
    pub fn clear_ent_idx(&mut self) {
        self.ent_idx = ::std::option::Option::None;
    }

    pub fn has_ent_idx(&self) -> bool {
        self.ent_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_idx(&mut self, v: i32) {
        self.ent_idx = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool chat = 3;


    pub fn get_chat(&self) -> bool {
        self.chat.unwrap_or(false)
    }
    pub fn clear_chat(&mut self) {
        self.chat = ::std::option::Option::None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = ::std::option::Option::Some(v);
    }

    // optional bool textallchat = 4;


    pub fn get_textallchat(&self) -> bool {
        self.textallchat.unwrap_or(false)
    }
    pub fn clear_textallchat(&mut self) {
        self.textallchat = ::std::option::Option::None;
    }

    pub fn has_textallchat(&self) -> bool {
        self.textallchat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textallchat(&mut self, v: bool) {
        self.textallchat = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SayText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ent_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chat = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.textallchat = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ent_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat {
            my_size += 2;
        }
        if let Some(v) = self.textallchat {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ent_idx {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.chat {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.textallchat {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SayText {
        CCSUsrMsg_SayText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ent_idx",
                    |m: &CCSUsrMsg_SayText| { &m.ent_idx },
                    |m: &mut CCSUsrMsg_SayText| { &mut m.ent_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CCSUsrMsg_SayText| { &m.text },
                    |m: &mut CCSUsrMsg_SayText| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "chat",
                    |m: &CCSUsrMsg_SayText| { &m.chat },
                    |m: &mut CCSUsrMsg_SayText| { &mut m.chat },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "textallchat",
                    |m: &CCSUsrMsg_SayText| { &m.textallchat },
                    |m: &mut CCSUsrMsg_SayText| { &mut m.textallchat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SayText>(
                    "CCSUsrMsg_SayText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SayText {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SayText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SayText,
        };
        unsafe {
            instance.get(CCSUsrMsg_SayText::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SayText {
    fn clear(&mut self) {
        self.ent_idx = ::std::option::Option::None;
        self.text.clear();
        self.chat = ::std::option::Option::None;
        self.textallchat = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SayText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SayText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SayText2 {
    // message fields
    ent_idx: ::std::option::Option<i32>,
    chat: ::std::option::Option<bool>,
    msg_name: ::protobuf::SingularField<::std::string::String>,
    params: ::protobuf::RepeatedField<::std::string::String>,
    textallchat: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SayText2 {
    fn default() -> &'a CCSUsrMsg_SayText2 {
        <CCSUsrMsg_SayText2 as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SayText2 {
    pub fn new() -> CCSUsrMsg_SayText2 {
        ::std::default::Default::default()
    }

    // optional int32 ent_idx = 1;


    pub fn get_ent_idx(&self) -> i32 {
        self.ent_idx.unwrap_or(0)
    }
    pub fn clear_ent_idx(&mut self) {
        self.ent_idx = ::std::option::Option::None;
    }

    pub fn has_ent_idx(&self) -> bool {
        self.ent_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_idx(&mut self, v: i32) {
        self.ent_idx = ::std::option::Option::Some(v);
    }

    // optional bool chat = 2;


    pub fn get_chat(&self) -> bool {
        self.chat.unwrap_or(false)
    }
    pub fn clear_chat(&mut self) {
        self.chat = ::std::option::Option::None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = ::std::option::Option::Some(v);
    }

    // optional string msg_name = 3;


    pub fn get_msg_name(&self) -> &str {
        match self.msg_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_msg_name(&mut self) {
        self.msg_name.clear();
    }

    pub fn has_msg_name(&self) -> bool {
        self.msg_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_name(&mut self, v: ::std::string::String) {
        self.msg_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_name(&mut self) -> &mut ::std::string::String {
        if self.msg_name.is_none() {
            self.msg_name.set_default();
        }
        self.msg_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_name(&mut self) -> ::std::string::String {
        self.msg_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string params = 4;


    pub fn get_params(&self) -> &[::std::string::String] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }

    // optional bool textallchat = 5;


    pub fn get_textallchat(&self) -> bool {
        self.textallchat.unwrap_or(false)
    }
    pub fn clear_textallchat(&mut self) {
        self.textallchat = ::std::option::Option::None;
    }

    pub fn has_textallchat(&self) -> bool {
        self.textallchat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textallchat(&mut self, v: bool) {
        self.textallchat = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SayText2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ent_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chat = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.msg_name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.params)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.textallchat = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ent_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat {
            my_size += 2;
        }
        if let Some(ref v) = self.msg_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.textallchat {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ent_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.chat {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.msg_name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.params {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.textallchat {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SayText2 {
        CCSUsrMsg_SayText2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ent_idx",
                    |m: &CCSUsrMsg_SayText2| { &m.ent_idx },
                    |m: &mut CCSUsrMsg_SayText2| { &mut m.ent_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "chat",
                    |m: &CCSUsrMsg_SayText2| { &m.chat },
                    |m: &mut CCSUsrMsg_SayText2| { &mut m.chat },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "msg_name",
                    |m: &CCSUsrMsg_SayText2| { &m.msg_name },
                    |m: &mut CCSUsrMsg_SayText2| { &mut m.msg_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "params",
                    |m: &CCSUsrMsg_SayText2| { &m.params },
                    |m: &mut CCSUsrMsg_SayText2| { &mut m.params },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "textallchat",
                    |m: &CCSUsrMsg_SayText2| { &m.textallchat },
                    |m: &mut CCSUsrMsg_SayText2| { &mut m.textallchat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SayText2>(
                    "CCSUsrMsg_SayText2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SayText2 {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SayText2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SayText2,
        };
        unsafe {
            instance.get(CCSUsrMsg_SayText2::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SayText2 {
    fn clear(&mut self) {
        self.ent_idx = ::std::option::Option::None;
        self.chat = ::std::option::Option::None;
        self.msg_name.clear();
        self.params.clear();
        self.textallchat = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SayText2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SayText2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_TextMsg {
    // message fields
    msg_dst: ::std::option::Option<i32>,
    params: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_TextMsg {
    fn default() -> &'a CCSUsrMsg_TextMsg {
        <CCSUsrMsg_TextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_TextMsg {
    pub fn new() -> CCSUsrMsg_TextMsg {
        ::std::default::Default::default()
    }

    // optional int32 msg_dst = 1;


    pub fn get_msg_dst(&self) -> i32 {
        self.msg_dst.unwrap_or(0)
    }
    pub fn clear_msg_dst(&mut self) {
        self.msg_dst = ::std::option::Option::None;
    }

    pub fn has_msg_dst(&self) -> bool {
        self.msg_dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_dst(&mut self, v: i32) {
        self.msg_dst = ::std::option::Option::Some(v);
    }

    // repeated string params = 3;


    pub fn get_params(&self) -> &[::std::string::String] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_TextMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.msg_dst = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msg_dst {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msg_dst {
            os.write_int32(1, v)?;
        }
        for v in &self.params {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_TextMsg {
        CCSUsrMsg_TextMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "msg_dst",
                    |m: &CCSUsrMsg_TextMsg| { &m.msg_dst },
                    |m: &mut CCSUsrMsg_TextMsg| { &mut m.msg_dst },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "params",
                    |m: &CCSUsrMsg_TextMsg| { &m.params },
                    |m: &mut CCSUsrMsg_TextMsg| { &mut m.params },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_TextMsg>(
                    "CCSUsrMsg_TextMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_TextMsg {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_TextMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_TextMsg,
        };
        unsafe {
            instance.get(CCSUsrMsg_TextMsg::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_TextMsg {
    fn clear(&mut self) {
        self.msg_dst = ::std::option::Option::None;
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_TextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_TextMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_HudMsg {
    // message fields
    channel: ::std::option::Option<i32>,
    pos: ::protobuf::SingularPtrField<super::netmessages::CMsgVector2D>,
    clr1: ::protobuf::SingularPtrField<super::netmessages::CMsgRGBA>,
    clr2: ::protobuf::SingularPtrField<super::netmessages::CMsgRGBA>,
    effect: ::std::option::Option<i32>,
    fade_in_time: ::std::option::Option<f32>,
    fade_out_time: ::std::option::Option<f32>,
    hold_time: ::std::option::Option<f32>,
    fx_time: ::std::option::Option<f32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HudMsg {
    fn default() -> &'a CCSUsrMsg_HudMsg {
        <CCSUsrMsg_HudMsg as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HudMsg {
    pub fn new() -> CCSUsrMsg_HudMsg {
        ::std::default::Default::default()
    }

    // optional int32 channel = 1;


    pub fn get_channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }
    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .CMsgVector2D pos = 2;


    pub fn get_pos(&self) -> &super::netmessages::CMsgVector2D {
        self.pos.as_ref().unwrap_or_else(|| super::netmessages::CMsgVector2D::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: super::netmessages::CMsgVector2D) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut super::netmessages::CMsgVector2D {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> super::netmessages::CMsgVector2D {
        self.pos.take().unwrap_or_else(|| super::netmessages::CMsgVector2D::new())
    }

    // optional .CMsgRGBA clr1 = 3;


    pub fn get_clr1(&self) -> &super::netmessages::CMsgRGBA {
        self.clr1.as_ref().unwrap_or_else(|| super::netmessages::CMsgRGBA::default_instance())
    }
    pub fn clear_clr1(&mut self) {
        self.clr1.clear();
    }

    pub fn has_clr1(&self) -> bool {
        self.clr1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clr1(&mut self, v: super::netmessages::CMsgRGBA) {
        self.clr1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clr1(&mut self) -> &mut super::netmessages::CMsgRGBA {
        if self.clr1.is_none() {
            self.clr1.set_default();
        }
        self.clr1.as_mut().unwrap()
    }

    // Take field
    pub fn take_clr1(&mut self) -> super::netmessages::CMsgRGBA {
        self.clr1.take().unwrap_or_else(|| super::netmessages::CMsgRGBA::new())
    }

    // optional .CMsgRGBA clr2 = 4;


    pub fn get_clr2(&self) -> &super::netmessages::CMsgRGBA {
        self.clr2.as_ref().unwrap_or_else(|| super::netmessages::CMsgRGBA::default_instance())
    }
    pub fn clear_clr2(&mut self) {
        self.clr2.clear();
    }

    pub fn has_clr2(&self) -> bool {
        self.clr2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clr2(&mut self, v: super::netmessages::CMsgRGBA) {
        self.clr2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clr2(&mut self) -> &mut super::netmessages::CMsgRGBA {
        if self.clr2.is_none() {
            self.clr2.set_default();
        }
        self.clr2.as_mut().unwrap()
    }

    // Take field
    pub fn take_clr2(&mut self) -> super::netmessages::CMsgRGBA {
        self.clr2.take().unwrap_or_else(|| super::netmessages::CMsgRGBA::new())
    }

    // optional int32 effect = 5;


    pub fn get_effect(&self) -> i32 {
        self.effect.unwrap_or(0)
    }
    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: i32) {
        self.effect = ::std::option::Option::Some(v);
    }

    // optional float fade_in_time = 6;


    pub fn get_fade_in_time(&self) -> f32 {
        self.fade_in_time.unwrap_or(0.)
    }
    pub fn clear_fade_in_time(&mut self) {
        self.fade_in_time = ::std::option::Option::None;
    }

    pub fn has_fade_in_time(&self) -> bool {
        self.fade_in_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_in_time(&mut self, v: f32) {
        self.fade_in_time = ::std::option::Option::Some(v);
    }

    // optional float fade_out_time = 7;


    pub fn get_fade_out_time(&self) -> f32 {
        self.fade_out_time.unwrap_or(0.)
    }
    pub fn clear_fade_out_time(&mut self) {
        self.fade_out_time = ::std::option::Option::None;
    }

    pub fn has_fade_out_time(&self) -> bool {
        self.fade_out_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_out_time(&mut self, v: f32) {
        self.fade_out_time = ::std::option::Option::Some(v);
    }

    // optional float hold_time = 9;


    pub fn get_hold_time(&self) -> f32 {
        self.hold_time.unwrap_or(0.)
    }
    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: f32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional float fx_time = 10;


    pub fn get_fx_time(&self) -> f32 {
        self.fx_time.unwrap_or(0.)
    }
    pub fn clear_fx_time(&mut self) {
        self.fx_time = ::std::option::Option::None;
    }

    pub fn has_fx_time(&self) -> bool {
        self.fx_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fx_time(&mut self, v: f32) {
        self.fx_time = ::std::option::Option::Some(v);
    }

    // optional string text = 11;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_HudMsg {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clr1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clr2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.channel = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clr1)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clr2)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.effect = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fade_in_time = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fade_out_time = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.hold_time = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fx_time = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clr1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clr2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.effect {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fade_in_time {
            my_size += 5;
        }
        if let Some(v) = self.fade_out_time {
            my_size += 5;
        }
        if let Some(v) = self.hold_time {
            my_size += 5;
        }
        if let Some(v) = self.fx_time {
            my_size += 5;
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clr1.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clr2.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.effect {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.fade_in_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.fade_out_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.fx_time {
            os.write_float(10, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_HudMsg {
        CCSUsrMsg_HudMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "channel",
                    |m: &CCSUsrMsg_HudMsg| { &m.channel },
                    |m: &mut CCSUsrMsg_HudMsg| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::netmessages::CMsgVector2D>>(
                    "pos",
                    |m: &CCSUsrMsg_HudMsg| { &m.pos },
                    |m: &mut CCSUsrMsg_HudMsg| { &mut m.pos },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::netmessages::CMsgRGBA>>(
                    "clr1",
                    |m: &CCSUsrMsg_HudMsg| { &m.clr1 },
                    |m: &mut CCSUsrMsg_HudMsg| { &mut m.clr1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::netmessages::CMsgRGBA>>(
                    "clr2",
                    |m: &CCSUsrMsg_HudMsg| { &m.clr2 },
                    |m: &mut CCSUsrMsg_HudMsg| { &mut m.clr2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "effect",
                    |m: &CCSUsrMsg_HudMsg| { &m.effect },
                    |m: &mut CCSUsrMsg_HudMsg| { &mut m.effect },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fade_in_time",
                    |m: &CCSUsrMsg_HudMsg| { &m.fade_in_time },
                    |m: &mut CCSUsrMsg_HudMsg| { &mut m.fade_in_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fade_out_time",
                    |m: &CCSUsrMsg_HudMsg| { &m.fade_out_time },
                    |m: &mut CCSUsrMsg_HudMsg| { &mut m.fade_out_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "hold_time",
                    |m: &CCSUsrMsg_HudMsg| { &m.hold_time },
                    |m: &mut CCSUsrMsg_HudMsg| { &mut m.hold_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fx_time",
                    |m: &CCSUsrMsg_HudMsg| { &m.fx_time },
                    |m: &mut CCSUsrMsg_HudMsg| { &mut m.fx_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CCSUsrMsg_HudMsg| { &m.text },
                    |m: &mut CCSUsrMsg_HudMsg| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_HudMsg>(
                    "CCSUsrMsg_HudMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_HudMsg {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_HudMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_HudMsg,
        };
        unsafe {
            instance.get(CCSUsrMsg_HudMsg::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_HudMsg {
    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.pos.clear();
        self.clr1.clear();
        self.clr2.clear();
        self.effect = ::std::option::Option::None;
        self.fade_in_time = ::std::option::Option::None;
        self.fade_out_time = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.fx_time = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_HudMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_HudMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Shake {
    // message fields
    command: ::std::option::Option<i32>,
    local_amplitude: ::std::option::Option<f32>,
    frequency: ::std::option::Option<f32>,
    duration: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Shake {
    fn default() -> &'a CCSUsrMsg_Shake {
        <CCSUsrMsg_Shake as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Shake {
    pub fn new() -> CCSUsrMsg_Shake {
        ::std::default::Default::default()
    }

    // optional int32 command = 1;


    pub fn get_command(&self) -> i32 {
        self.command.unwrap_or(0)
    }
    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: i32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional float local_amplitude = 2;


    pub fn get_local_amplitude(&self) -> f32 {
        self.local_amplitude.unwrap_or(0.)
    }
    pub fn clear_local_amplitude(&mut self) {
        self.local_amplitude = ::std::option::Option::None;
    }

    pub fn has_local_amplitude(&self) -> bool {
        self.local_amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_amplitude(&mut self, v: f32) {
        self.local_amplitude = ::std::option::Option::Some(v);
    }

    // optional float frequency = 3;


    pub fn get_frequency(&self) -> f32 {
        self.frequency.unwrap_or(0.)
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: f32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;


    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_Shake {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.command = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.local_amplitude = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.frequency = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.local_amplitude {
            my_size += 5;
        }
        if let Some(v) = self.frequency {
            my_size += 5;
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.command {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.local_amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Shake {
        CCSUsrMsg_Shake::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "command",
                    |m: &CCSUsrMsg_Shake| { &m.command },
                    |m: &mut CCSUsrMsg_Shake| { &mut m.command },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "local_amplitude",
                    |m: &CCSUsrMsg_Shake| { &m.local_amplitude },
                    |m: &mut CCSUsrMsg_Shake| { &mut m.local_amplitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "frequency",
                    |m: &CCSUsrMsg_Shake| { &m.frequency },
                    |m: &mut CCSUsrMsg_Shake| { &mut m.frequency },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "duration",
                    |m: &CCSUsrMsg_Shake| { &m.duration },
                    |m: &mut CCSUsrMsg_Shake| { &mut m.duration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_Shake>(
                    "CCSUsrMsg_Shake",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_Shake {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_Shake> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_Shake,
        };
        unsafe {
            instance.get(CCSUsrMsg_Shake::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Shake {
    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.local_amplitude = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Shake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Shake {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Fade {
    // message fields
    duration: ::std::option::Option<i32>,
    hold_time: ::std::option::Option<i32>,
    flags: ::std::option::Option<i32>,
    clr: ::protobuf::SingularPtrField<super::netmessages::CMsgRGBA>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Fade {
    fn default() -> &'a CCSUsrMsg_Fade {
        <CCSUsrMsg_Fade as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Fade {
    pub fn new() -> CCSUsrMsg_Fade {
        ::std::default::Default::default()
    }

    // optional int32 duration = 1;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 hold_time = 2;


    pub fn get_hold_time(&self) -> i32 {
        self.hold_time.unwrap_or(0)
    }
    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: i32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;


    pub fn get_flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional .CMsgRGBA clr = 4;


    pub fn get_clr(&self) -> &super::netmessages::CMsgRGBA {
        self.clr.as_ref().unwrap_or_else(|| super::netmessages::CMsgRGBA::default_instance())
    }
    pub fn clear_clr(&mut self) {
        self.clr.clear();
    }

    pub fn has_clr(&self) -> bool {
        self.clr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clr(&mut self, v: super::netmessages::CMsgRGBA) {
        self.clr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clr(&mut self) -> &mut super::netmessages::CMsgRGBA {
        if self.clr.is_none() {
            self.clr.set_default();
        }
        self.clr.as_mut().unwrap()
    }

    // Take field
    pub fn take_clr(&mut self) -> super::netmessages::CMsgRGBA {
        self.clr.take().unwrap_or_else(|| super::netmessages::CMsgRGBA::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_Fade {
    fn is_initialized(&self) -> bool {
        for v in &self.clr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hold_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hold_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.duration {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.clr.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Fade {
        CCSUsrMsg_Fade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "duration",
                    |m: &CCSUsrMsg_Fade| { &m.duration },
                    |m: &mut CCSUsrMsg_Fade| { &mut m.duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hold_time",
                    |m: &CCSUsrMsg_Fade| { &m.hold_time },
                    |m: &mut CCSUsrMsg_Fade| { &mut m.hold_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "flags",
                    |m: &CCSUsrMsg_Fade| { &m.flags },
                    |m: &mut CCSUsrMsg_Fade| { &mut m.flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::netmessages::CMsgRGBA>>(
                    "clr",
                    |m: &CCSUsrMsg_Fade| { &m.clr },
                    |m: &mut CCSUsrMsg_Fade| { &mut m.clr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_Fade>(
                    "CCSUsrMsg_Fade",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_Fade {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_Fade> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_Fade,
        };
        unsafe {
            instance.get(CCSUsrMsg_Fade::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Fade {
    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.clr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Fade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Fade {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Rumble {
    // message fields
    index: ::std::option::Option<i32>,
    data: ::std::option::Option<i32>,
    flags: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Rumble {
    fn default() -> &'a CCSUsrMsg_Rumble {
        <CCSUsrMsg_Rumble as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Rumble {
    pub fn new() -> CCSUsrMsg_Rumble {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 data = 2;


    pub fn get_data(&self) -> i32 {
        self.data.unwrap_or(0)
    }
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;


    pub fn get_flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_Rumble {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.data = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Rumble {
        CCSUsrMsg_Rumble::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    |m: &CCSUsrMsg_Rumble| { &m.index },
                    |m: &mut CCSUsrMsg_Rumble| { &mut m.index },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "data",
                    |m: &CCSUsrMsg_Rumble| { &m.data },
                    |m: &mut CCSUsrMsg_Rumble| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "flags",
                    |m: &CCSUsrMsg_Rumble| { &m.flags },
                    |m: &mut CCSUsrMsg_Rumble| { &mut m.flags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_Rumble>(
                    "CCSUsrMsg_Rumble",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_Rumble {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_Rumble> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_Rumble,
        };
        unsafe {
            instance.get(CCSUsrMsg_Rumble::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Rumble {
    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Rumble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Rumble {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_CloseCaption {
    // message fields
    hash: ::std::option::Option<u32>,
    duration: ::std::option::Option<i32>,
    from_player: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CloseCaption {
    fn default() -> &'a CCSUsrMsg_CloseCaption {
        <CCSUsrMsg_CloseCaption as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CloseCaption {
    pub fn new() -> CCSUsrMsg_CloseCaption {
        ::std::default::Default::default()
    }

    // optional uint32 hash = 1;


    pub fn get_hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }
    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 2;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;


    pub fn get_from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }
    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_CloseCaption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hash = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.from_player = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_player {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_CloseCaption {
        CCSUsrMsg_CloseCaption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hash",
                    |m: &CCSUsrMsg_CloseCaption| { &m.hash },
                    |m: &mut CCSUsrMsg_CloseCaption| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "duration",
                    |m: &CCSUsrMsg_CloseCaption| { &m.duration },
                    |m: &mut CCSUsrMsg_CloseCaption| { &mut m.duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "from_player",
                    |m: &CCSUsrMsg_CloseCaption| { &m.from_player },
                    |m: &mut CCSUsrMsg_CloseCaption| { &mut m.from_player },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_CloseCaption>(
                    "CCSUsrMsg_CloseCaption",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_CloseCaption {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_CloseCaption> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_CloseCaption,
        };
        unsafe {
            instance.get(CCSUsrMsg_CloseCaption::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_CloseCaption {
    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_CloseCaption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CloseCaption {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_CloseCaptionDirect {
    // message fields
    hash: ::std::option::Option<u32>,
    duration: ::std::option::Option<i32>,
    from_player: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CloseCaptionDirect {
    fn default() -> &'a CCSUsrMsg_CloseCaptionDirect {
        <CCSUsrMsg_CloseCaptionDirect as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CloseCaptionDirect {
    pub fn new() -> CCSUsrMsg_CloseCaptionDirect {
        ::std::default::Default::default()
    }

    // optional uint32 hash = 1;


    pub fn get_hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }
    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 2;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;


    pub fn get_from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }
    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_CloseCaptionDirect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hash = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.from_player = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_player {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_CloseCaptionDirect {
        CCSUsrMsg_CloseCaptionDirect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hash",
                    |m: &CCSUsrMsg_CloseCaptionDirect| { &m.hash },
                    |m: &mut CCSUsrMsg_CloseCaptionDirect| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "duration",
                    |m: &CCSUsrMsg_CloseCaptionDirect| { &m.duration },
                    |m: &mut CCSUsrMsg_CloseCaptionDirect| { &mut m.duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "from_player",
                    |m: &CCSUsrMsg_CloseCaptionDirect| { &m.from_player },
                    |m: &mut CCSUsrMsg_CloseCaptionDirect| { &mut m.from_player },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_CloseCaptionDirect>(
                    "CCSUsrMsg_CloseCaptionDirect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_CloseCaptionDirect {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_CloseCaptionDirect> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_CloseCaptionDirect,
        };
        unsafe {
            instance.get(CCSUsrMsg_CloseCaptionDirect::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_CloseCaptionDirect {
    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_CloseCaptionDirect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CloseCaptionDirect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SendAudio {
    // message fields
    radio_sound: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendAudio {
    fn default() -> &'a CCSUsrMsg_SendAudio {
        <CCSUsrMsg_SendAudio as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendAudio {
    pub fn new() -> CCSUsrMsg_SendAudio {
        ::std::default::Default::default()
    }

    // optional string radio_sound = 1;


    pub fn get_radio_sound(&self) -> &str {
        match self.radio_sound.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_radio_sound(&mut self) {
        self.radio_sound.clear();
    }

    pub fn has_radio_sound(&self) -> bool {
        self.radio_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_sound(&mut self, v: ::std::string::String) {
        self.radio_sound = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radio_sound(&mut self) -> &mut ::std::string::String {
        if self.radio_sound.is_none() {
            self.radio_sound.set_default();
        }
        self.radio_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_radio_sound(&mut self) -> ::std::string::String {
        self.radio_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendAudio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.radio_sound)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.radio_sound.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.radio_sound.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SendAudio {
        CCSUsrMsg_SendAudio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "radio_sound",
                    |m: &CCSUsrMsg_SendAudio| { &m.radio_sound },
                    |m: &mut CCSUsrMsg_SendAudio| { &mut m.radio_sound },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SendAudio>(
                    "CCSUsrMsg_SendAudio",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SendAudio {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SendAudio> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SendAudio,
        };
        unsafe {
            instance.get(CCSUsrMsg_SendAudio::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SendAudio {
    fn clear(&mut self) {
        self.radio_sound.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SendAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendAudio {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RawAudio {
    // message fields
    pitch: ::std::option::Option<i32>,
    entidx: ::std::option::Option<i32>,
    duration: ::std::option::Option<f32>,
    voice_filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RawAudio {
    fn default() -> &'a CCSUsrMsg_RawAudio {
        <CCSUsrMsg_RawAudio as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RawAudio {
    pub fn new() -> CCSUsrMsg_RawAudio {
        ::std::default::Default::default()
    }

    // optional int32 pitch = 1;


    pub fn get_pitch(&self) -> i32 {
        self.pitch.unwrap_or(0)
    }
    pub fn clear_pitch(&mut self) {
        self.pitch = ::std::option::Option::None;
    }

    pub fn has_pitch(&self) -> bool {
        self.pitch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch(&mut self, v: i32) {
        self.pitch = ::std::option::Option::Some(v);
    }

    // optional int32 entidx = 2;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;


    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string voice_filename = 4;


    pub fn get_voice_filename(&self) -> &str {
        match self.voice_filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_voice_filename(&mut self) {
        self.voice_filename.clear();
    }

    pub fn has_voice_filename(&self) -> bool {
        self.voice_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_filename(&mut self, v: ::std::string::String) {
        self.voice_filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_filename(&mut self) -> &mut ::std::string::String {
        if self.voice_filename.is_none() {
            self.voice_filename.set_default();
        }
        self.voice_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_filename(&mut self) -> ::std::string::String {
        self.voice_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_RawAudio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pitch = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.voice_filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pitch {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        if let Some(ref v) = self.voice_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pitch {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entidx {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        if let Some(ref v) = self.voice_filename.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RawAudio {
        CCSUsrMsg_RawAudio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "pitch",
                    |m: &CCSUsrMsg_RawAudio| { &m.pitch },
                    |m: &mut CCSUsrMsg_RawAudio| { &mut m.pitch },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entidx",
                    |m: &CCSUsrMsg_RawAudio| { &m.entidx },
                    |m: &mut CCSUsrMsg_RawAudio| { &mut m.entidx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "duration",
                    |m: &CCSUsrMsg_RawAudio| { &m.duration },
                    |m: &mut CCSUsrMsg_RawAudio| { &mut m.duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "voice_filename",
                    |m: &CCSUsrMsg_RawAudio| { &m.voice_filename },
                    |m: &mut CCSUsrMsg_RawAudio| { &mut m.voice_filename },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_RawAudio>(
                    "CCSUsrMsg_RawAudio",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_RawAudio {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_RawAudio> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_RawAudio,
        };
        unsafe {
            instance.get(CCSUsrMsg_RawAudio::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RawAudio {
    fn clear(&mut self) {
        self.pitch = ::std::option::Option::None;
        self.entidx = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.voice_filename.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RawAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RawAudio {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VoiceMask {
    // message fields
    player_masks: ::protobuf::RepeatedField<CCSUsrMsg_VoiceMask_PlayerMask>,
    player_mod_enable: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoiceMask {
    fn default() -> &'a CCSUsrMsg_VoiceMask {
        <CCSUsrMsg_VoiceMask as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoiceMask {
    pub fn new() -> CCSUsrMsg_VoiceMask {
        ::std::default::Default::default()
    }

    // repeated .CCSUsrMsg_VoiceMask.PlayerMask player_masks = 1;


    pub fn get_player_masks(&self) -> &[CCSUsrMsg_VoiceMask_PlayerMask] {
        &self.player_masks
    }
    pub fn clear_player_masks(&mut self) {
        self.player_masks.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_masks(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_VoiceMask_PlayerMask>) {
        self.player_masks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_masks(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_VoiceMask_PlayerMask> {
        &mut self.player_masks
    }

    // Take field
    pub fn take_player_masks(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_VoiceMask_PlayerMask> {
        ::std::mem::replace(&mut self.player_masks, ::protobuf::RepeatedField::new())
    }

    // optional bool player_mod_enable = 2;


    pub fn get_player_mod_enable(&self) -> bool {
        self.player_mod_enable.unwrap_or(false)
    }
    pub fn clear_player_mod_enable(&mut self) {
        self.player_mod_enable = ::std::option::Option::None;
    }

    pub fn has_player_mod_enable(&self) -> bool {
        self.player_mod_enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_mod_enable(&mut self, v: bool) {
        self.player_mod_enable = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoiceMask {
    fn is_initialized(&self) -> bool {
        for v in &self.player_masks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_masks)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.player_mod_enable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_masks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.player_mod_enable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_masks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.player_mod_enable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VoiceMask {
        CCSUsrMsg_VoiceMask::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_VoiceMask_PlayerMask>>(
                    "player_masks",
                    |m: &CCSUsrMsg_VoiceMask| { &m.player_masks },
                    |m: &mut CCSUsrMsg_VoiceMask| { &mut m.player_masks },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "player_mod_enable",
                    |m: &CCSUsrMsg_VoiceMask| { &m.player_mod_enable },
                    |m: &mut CCSUsrMsg_VoiceMask| { &mut m.player_mod_enable },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_VoiceMask>(
                    "CCSUsrMsg_VoiceMask",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_VoiceMask {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_VoiceMask> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_VoiceMask,
        };
        unsafe {
            instance.get(CCSUsrMsg_VoiceMask::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VoiceMask {
    fn clear(&mut self) {
        self.player_masks.clear();
        self.player_mod_enable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VoiceMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoiceMask {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VoiceMask_PlayerMask {
    // message fields
    game_rules_mask: ::std::option::Option<i32>,
    ban_masks: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoiceMask_PlayerMask {
    fn default() -> &'a CCSUsrMsg_VoiceMask_PlayerMask {
        <CCSUsrMsg_VoiceMask_PlayerMask as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoiceMask_PlayerMask {
    pub fn new() -> CCSUsrMsg_VoiceMask_PlayerMask {
        ::std::default::Default::default()
    }

    // optional int32 game_rules_mask = 1;


    pub fn get_game_rules_mask(&self) -> i32 {
        self.game_rules_mask.unwrap_or(0)
    }
    pub fn clear_game_rules_mask(&mut self) {
        self.game_rules_mask = ::std::option::Option::None;
    }

    pub fn has_game_rules_mask(&self) -> bool {
        self.game_rules_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_rules_mask(&mut self, v: i32) {
        self.game_rules_mask = ::std::option::Option::Some(v);
    }

    // optional int32 ban_masks = 2;


    pub fn get_ban_masks(&self) -> i32 {
        self.ban_masks.unwrap_or(0)
    }
    pub fn clear_ban_masks(&mut self) {
        self.ban_masks = ::std::option::Option::None;
    }

    pub fn has_ban_masks(&self) -> bool {
        self.ban_masks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_masks(&mut self, v: i32) {
        self.ban_masks = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoiceMask_PlayerMask {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_rules_mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ban_masks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_rules_mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ban_masks {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_rules_mask {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ban_masks {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VoiceMask_PlayerMask {
        CCSUsrMsg_VoiceMask_PlayerMask::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "game_rules_mask",
                    |m: &CCSUsrMsg_VoiceMask_PlayerMask| { &m.game_rules_mask },
                    |m: &mut CCSUsrMsg_VoiceMask_PlayerMask| { &mut m.game_rules_mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ban_masks",
                    |m: &CCSUsrMsg_VoiceMask_PlayerMask| { &m.ban_masks },
                    |m: &mut CCSUsrMsg_VoiceMask_PlayerMask| { &mut m.ban_masks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_VoiceMask_PlayerMask>(
                    "CCSUsrMsg_VoiceMask_PlayerMask",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_VoiceMask_PlayerMask {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_VoiceMask_PlayerMask> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_VoiceMask_PlayerMask,
        };
        unsafe {
            instance.get(CCSUsrMsg_VoiceMask_PlayerMask::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VoiceMask_PlayerMask {
    fn clear(&mut self) {
        self.game_rules_mask = ::std::option::Option::None;
        self.ban_masks = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VoiceMask_PlayerMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoiceMask_PlayerMask {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Damage {
    // message fields
    amount: ::std::option::Option<i32>,
    inflictor_world_pos: ::protobuf::SingularPtrField<super::netmessages::CMsgVector>,
    victim_entindex: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Damage {
    fn default() -> &'a CCSUsrMsg_Damage {
        <CCSUsrMsg_Damage as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Damage {
    pub fn new() -> CCSUsrMsg_Damage {
        ::std::default::Default::default()
    }

    // optional int32 amount = 1;


    pub fn get_amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional .CMsgVector inflictor_world_pos = 2;


    pub fn get_inflictor_world_pos(&self) -> &super::netmessages::CMsgVector {
        self.inflictor_world_pos.as_ref().unwrap_or_else(|| super::netmessages::CMsgVector::default_instance())
    }
    pub fn clear_inflictor_world_pos(&mut self) {
        self.inflictor_world_pos.clear();
    }

    pub fn has_inflictor_world_pos(&self) -> bool {
        self.inflictor_world_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inflictor_world_pos(&mut self, v: super::netmessages::CMsgVector) {
        self.inflictor_world_pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inflictor_world_pos(&mut self) -> &mut super::netmessages::CMsgVector {
        if self.inflictor_world_pos.is_none() {
            self.inflictor_world_pos.set_default();
        }
        self.inflictor_world_pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_inflictor_world_pos(&mut self) -> super::netmessages::CMsgVector {
        self.inflictor_world_pos.take().unwrap_or_else(|| super::netmessages::CMsgVector::new())
    }

    // optional int32 victim_entindex = 3;


    pub fn get_victim_entindex(&self) -> i32 {
        self.victim_entindex.unwrap_or(0)
    }
    pub fn clear_victim_entindex(&mut self) {
        self.victim_entindex = ::std::option::Option::None;
    }

    pub fn has_victim_entindex(&self) -> bool {
        self.victim_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_entindex(&mut self, v: i32) {
        self.victim_entindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_Damage {
    fn is_initialized(&self) -> bool {
        for v in &self.inflictor_world_pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inflictor_world_pos)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.victim_entindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.inflictor_world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.victim_entindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.amount {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.inflictor_world_pos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.victim_entindex {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Damage {
        CCSUsrMsg_Damage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "amount",
                    |m: &CCSUsrMsg_Damage| { &m.amount },
                    |m: &mut CCSUsrMsg_Damage| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::netmessages::CMsgVector>>(
                    "inflictor_world_pos",
                    |m: &CCSUsrMsg_Damage| { &m.inflictor_world_pos },
                    |m: &mut CCSUsrMsg_Damage| { &mut m.inflictor_world_pos },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "victim_entindex",
                    |m: &CCSUsrMsg_Damage| { &m.victim_entindex },
                    |m: &mut CCSUsrMsg_Damage| { &mut m.victim_entindex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_Damage>(
                    "CCSUsrMsg_Damage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_Damage {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_Damage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_Damage,
        };
        unsafe {
            instance.get(CCSUsrMsg_Damage::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Damage {
    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.inflictor_world_pos.clear();
        self.victim_entindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Damage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Damage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RadioText {
    // message fields
    msg_dst: ::std::option::Option<i32>,
    client: ::std::option::Option<i32>,
    msg_name: ::protobuf::SingularField<::std::string::String>,
    params: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RadioText {
    fn default() -> &'a CCSUsrMsg_RadioText {
        <CCSUsrMsg_RadioText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RadioText {
    pub fn new() -> CCSUsrMsg_RadioText {
        ::std::default::Default::default()
    }

    // optional int32 msg_dst = 1;


    pub fn get_msg_dst(&self) -> i32 {
        self.msg_dst.unwrap_or(0)
    }
    pub fn clear_msg_dst(&mut self) {
        self.msg_dst = ::std::option::Option::None;
    }

    pub fn has_msg_dst(&self) -> bool {
        self.msg_dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_dst(&mut self, v: i32) {
        self.msg_dst = ::std::option::Option::Some(v);
    }

    // optional int32 client = 2;


    pub fn get_client(&self) -> i32 {
        self.client.unwrap_or(0)
    }
    pub fn clear_client(&mut self) {
        self.client = ::std::option::Option::None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: i32) {
        self.client = ::std::option::Option::Some(v);
    }

    // optional string msg_name = 3;


    pub fn get_msg_name(&self) -> &str {
        match self.msg_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_msg_name(&mut self) {
        self.msg_name.clear();
    }

    pub fn has_msg_name(&self) -> bool {
        self.msg_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_name(&mut self, v: ::std::string::String) {
        self.msg_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_name(&mut self) -> &mut ::std::string::String {
        if self.msg_name.is_none() {
            self.msg_name.set_default();
        }
        self.msg_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_name(&mut self) -> ::std::string::String {
        self.msg_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string params = 4;


    pub fn get_params(&self) -> &[::std::string::String] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_RadioText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.msg_dst = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.client = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.msg_name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msg_dst {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.msg_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msg_dst {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.client {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.msg_name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.params {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RadioText {
        CCSUsrMsg_RadioText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "msg_dst",
                    |m: &CCSUsrMsg_RadioText| { &m.msg_dst },
                    |m: &mut CCSUsrMsg_RadioText| { &mut m.msg_dst },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "client",
                    |m: &CCSUsrMsg_RadioText| { &m.client },
                    |m: &mut CCSUsrMsg_RadioText| { &mut m.client },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "msg_name",
                    |m: &CCSUsrMsg_RadioText| { &m.msg_name },
                    |m: &mut CCSUsrMsg_RadioText| { &mut m.msg_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "params",
                    |m: &CCSUsrMsg_RadioText| { &m.params },
                    |m: &mut CCSUsrMsg_RadioText| { &mut m.params },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_RadioText>(
                    "CCSUsrMsg_RadioText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_RadioText {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_RadioText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_RadioText,
        };
        unsafe {
            instance.get(CCSUsrMsg_RadioText::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RadioText {
    fn clear(&mut self) {
        self.msg_dst = ::std::option::Option::None;
        self.client = ::std::option::Option::None;
        self.msg_name.clear();
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RadioText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RadioText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_HintText {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HintText {
    fn default() -> &'a CCSUsrMsg_HintText {
        <CCSUsrMsg_HintText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HintText {
    pub fn new() -> CCSUsrMsg_HintText {
        ::std::default::Default::default()
    }

    // optional string text = 1;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_HintText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_HintText {
        CCSUsrMsg_HintText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CCSUsrMsg_HintText| { &m.text },
                    |m: &mut CCSUsrMsg_HintText| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_HintText>(
                    "CCSUsrMsg_HintText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_HintText {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_HintText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_HintText,
        };
        unsafe {
            instance.get(CCSUsrMsg_HintText::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_HintText {
    fn clear(&mut self) {
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_HintText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_HintText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_KeyHintText {
    // message fields
    hints: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_KeyHintText {
    fn default() -> &'a CCSUsrMsg_KeyHintText {
        <CCSUsrMsg_KeyHintText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_KeyHintText {
    pub fn new() -> CCSUsrMsg_KeyHintText {
        ::std::default::Default::default()
    }

    // repeated string hints = 1;


    pub fn get_hints(&self) -> &[::std::string::String] {
        &self.hints
    }
    pub fn clear_hints(&mut self) {
        self.hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_hints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hints
    }

    // Take field
    pub fn take_hints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.hints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_KeyHintText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hints {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hints {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_KeyHintText {
        CCSUsrMsg_KeyHintText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hints",
                    |m: &CCSUsrMsg_KeyHintText| { &m.hints },
                    |m: &mut CCSUsrMsg_KeyHintText| { &mut m.hints },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_KeyHintText>(
                    "CCSUsrMsg_KeyHintText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_KeyHintText {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_KeyHintText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_KeyHintText,
        };
        unsafe {
            instance.get(CCSUsrMsg_KeyHintText::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_KeyHintText {
    fn clear(&mut self) {
        self.hints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_KeyHintText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_KeyHintText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ProcessSpottedEntityUpdate {
    // message fields
    new_update: ::std::option::Option<bool>,
    entity_updates: ::protobuf::RepeatedField<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn default() -> &'a CCSUsrMsg_ProcessSpottedEntityUpdate {
        <CCSUsrMsg_ProcessSpottedEntityUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ProcessSpottedEntityUpdate {
    pub fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate {
        ::std::default::Default::default()
    }

    // optional bool new_update = 1;


    pub fn get_new_update(&self) -> bool {
        self.new_update.unwrap_or(false)
    }
    pub fn clear_new_update(&mut self) {
        self.new_update = ::std::option::Option::None;
    }

    pub fn has_new_update(&self) -> bool {
        self.new_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_update(&mut self, v: bool) {
        self.new_update = ::std::option::Option::Some(v);
    }

    // repeated .CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate entity_updates = 2;


    pub fn get_entity_updates(&self) -> &[CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate] {
        &self.entity_updates
    }
    pub fn clear_entity_updates(&mut self) {
        self.entity_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_updates(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate>) {
        self.entity_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entity_updates(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate> {
        &mut self.entity_updates
    }

    // Take field
    pub fn take_entity_updates(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate> {
        ::std::mem::replace(&mut self.entity_updates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.entity_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.new_update = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entity_updates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.new_update {
            my_size += 2;
        }
        for value in &self.entity_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.new_update {
            os.write_bool(1, v)?;
        }
        for v in &self.entity_updates {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate {
        CCSUsrMsg_ProcessSpottedEntityUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "new_update",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate| { &m.new_update },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate| { &mut m.new_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate>>(
                    "entity_updates",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate| { &m.entity_updates },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate| { &mut m.entity_updates },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ProcessSpottedEntityUpdate>(
                    "CCSUsrMsg_ProcessSpottedEntityUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ProcessSpottedEntityUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ProcessSpottedEntityUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ProcessSpottedEntityUpdate,
        };
        unsafe {
            instance.get(CCSUsrMsg_ProcessSpottedEntityUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn clear(&mut self) {
        self.new_update = ::std::option::Option::None;
        self.entity_updates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    // message fields
    entity_idx: ::std::option::Option<i32>,
    class_id: ::std::option::Option<i32>,
    origin_x: ::std::option::Option<i32>,
    origin_y: ::std::option::Option<i32>,
    origin_z: ::std::option::Option<i32>,
    angle_y: ::std::option::Option<i32>,
    defuser: ::std::option::Option<bool>,
    player_has_defuser: ::std::option::Option<bool>,
    player_has_c4: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    fn default() -> &'a CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
        <CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    pub fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
        ::std::default::Default::default()
    }

    // optional int32 entity_idx = 1;


    pub fn get_entity_idx(&self) -> i32 {
        self.entity_idx.unwrap_or(0)
    }
    pub fn clear_entity_idx(&mut self) {
        self.entity_idx = ::std::option::Option::None;
    }

    pub fn has_entity_idx(&self) -> bool {
        self.entity_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_idx(&mut self, v: i32) {
        self.entity_idx = ::std::option::Option::Some(v);
    }

    // optional int32 class_id = 2;


    pub fn get_class_id(&self) -> i32 {
        self.class_id.unwrap_or(0)
    }
    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: i32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional int32 origin_x = 3;


    pub fn get_origin_x(&self) -> i32 {
        self.origin_x.unwrap_or(0)
    }
    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: i32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional int32 origin_y = 4;


    pub fn get_origin_y(&self) -> i32 {
        self.origin_y.unwrap_or(0)
    }
    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: i32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional int32 origin_z = 5;


    pub fn get_origin_z(&self) -> i32 {
        self.origin_z.unwrap_or(0)
    }
    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: i32) {
        self.origin_z = ::std::option::Option::Some(v);
    }

    // optional int32 angle_y = 6;


    pub fn get_angle_y(&self) -> i32 {
        self.angle_y.unwrap_or(0)
    }
    pub fn clear_angle_y(&mut self) {
        self.angle_y = ::std::option::Option::None;
    }

    pub fn has_angle_y(&self) -> bool {
        self.angle_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_angle_y(&mut self, v: i32) {
        self.angle_y = ::std::option::Option::Some(v);
    }

    // optional bool defuser = 7;


    pub fn get_defuser(&self) -> bool {
        self.defuser.unwrap_or(false)
    }
    pub fn clear_defuser(&mut self) {
        self.defuser = ::std::option::Option::None;
    }

    pub fn has_defuser(&self) -> bool {
        self.defuser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defuser(&mut self, v: bool) {
        self.defuser = ::std::option::Option::Some(v);
    }

    // optional bool player_has_defuser = 8;


    pub fn get_player_has_defuser(&self) -> bool {
        self.player_has_defuser.unwrap_or(false)
    }
    pub fn clear_player_has_defuser(&mut self) {
        self.player_has_defuser = ::std::option::Option::None;
    }

    pub fn has_player_has_defuser(&self) -> bool {
        self.player_has_defuser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_has_defuser(&mut self, v: bool) {
        self.player_has_defuser = ::std::option::Option::Some(v);
    }

    // optional bool player_has_c4 = 9;


    pub fn get_player_has_c4(&self) -> bool {
        self.player_has_c4.unwrap_or(false)
    }
    pub fn clear_player_has_c4(&mut self) {
        self.player_has_c4 = ::std::option::Option::None;
    }

    pub fn has_player_has_c4(&self) -> bool {
        self.player_has_c4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_has_c4(&mut self, v: bool) {
        self.player_has_c4 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.class_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.origin_x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.origin_y = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.origin_z = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.angle_y = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.defuser = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.player_has_defuser = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.player_has_c4 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entity_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin_x {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin_y {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin_z {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.angle_y {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defuser {
            my_size += 2;
        }
        if let Some(v) = self.player_has_defuser {
            my_size += 2;
        }
        if let Some(v) = self.player_has_c4 {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entity_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.class_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.angle_y {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.defuser {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.player_has_defuser {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.player_has_c4 {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
        CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_idx",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.entity_idx },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.entity_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "class_id",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.class_id },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.class_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "origin_x",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.origin_x },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.origin_x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "origin_y",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.origin_y },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.origin_y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "origin_z",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.origin_z },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.origin_z },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "angle_y",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.angle_y },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.angle_y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "defuser",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.defuser },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.defuser },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "player_has_defuser",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.player_has_defuser },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.player_has_defuser },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "player_has_c4",
                    |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.player_has_c4 },
                    |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.player_has_c4 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate>(
                    "CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate,
        };
        unsafe {
            instance.get(CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    fn clear(&mut self) {
        self.entity_idx = ::std::option::Option::None;
        self.class_id = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.angle_y = ::std::option::Option::None;
        self.defuser = ::std::option::Option::None;
        self.player_has_defuser = ::std::option::Option::None;
        self.player_has_c4 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SendPlayerItemDrops {
    // message fields
    entity_updates: ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendPlayerItemDrops {
    fn default() -> &'a CCSUsrMsg_SendPlayerItemDrops {
        <CCSUsrMsg_SendPlayerItemDrops as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendPlayerItemDrops {
    pub fn new() -> CCSUsrMsg_SendPlayerItemDrops {
        ::std::default::Default::default()
    }

    // repeated .CEconItemPreviewDataBlock entity_updates = 1;


    pub fn get_entity_updates(&self) -> &[super::cstrike15_gcmessages::CEconItemPreviewDataBlock] {
        &self.entity_updates
    }
    pub fn clear_entity_updates(&mut self) {
        self.entity_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_updates(&mut self, v: ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>) {
        self.entity_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entity_updates(&mut self) -> &mut ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock> {
        &mut self.entity_updates
    }

    // Take field
    pub fn take_entity_updates(&mut self) -> ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock> {
        ::std::mem::replace(&mut self.entity_updates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendPlayerItemDrops {
    fn is_initialized(&self) -> bool {
        for v in &self.entity_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entity_updates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entity_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entity_updates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SendPlayerItemDrops {
        CCSUsrMsg_SendPlayerItemDrops::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>>(
                    "entity_updates",
                    |m: &CCSUsrMsg_SendPlayerItemDrops| { &m.entity_updates },
                    |m: &mut CCSUsrMsg_SendPlayerItemDrops| { &mut m.entity_updates },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SendPlayerItemDrops>(
                    "CCSUsrMsg_SendPlayerItemDrops",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SendPlayerItemDrops {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SendPlayerItemDrops> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SendPlayerItemDrops,
        };
        unsafe {
            instance.get(CCSUsrMsg_SendPlayerItemDrops::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SendPlayerItemDrops {
    fn clear(&mut self) {
        self.entity_updates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SendPlayerItemDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendPlayerItemDrops {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SendPlayerItemFound {
    // message fields
    iteminfo: ::protobuf::SingularPtrField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    entindex: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendPlayerItemFound {
    fn default() -> &'a CCSUsrMsg_SendPlayerItemFound {
        <CCSUsrMsg_SendPlayerItemFound as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendPlayerItemFound {
    pub fn new() -> CCSUsrMsg_SendPlayerItemFound {
        ::std::default::Default::default()
    }

    // optional .CEconItemPreviewDataBlock iteminfo = 1;


    pub fn get_iteminfo(&self) -> &super::cstrike15_gcmessages::CEconItemPreviewDataBlock {
        self.iteminfo.as_ref().unwrap_or_else(|| super::cstrike15_gcmessages::CEconItemPreviewDataBlock::default_instance())
    }
    pub fn clear_iteminfo(&mut self) {
        self.iteminfo.clear();
    }

    pub fn has_iteminfo(&self) -> bool {
        self.iteminfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteminfo(&mut self, v: super::cstrike15_gcmessages::CEconItemPreviewDataBlock) {
        self.iteminfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iteminfo(&mut self) -> &mut super::cstrike15_gcmessages::CEconItemPreviewDataBlock {
        if self.iteminfo.is_none() {
            self.iteminfo.set_default();
        }
        self.iteminfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_iteminfo(&mut self) -> super::cstrike15_gcmessages::CEconItemPreviewDataBlock {
        self.iteminfo.take().unwrap_or_else(|| super::cstrike15_gcmessages::CEconItemPreviewDataBlock::new())
    }

    // optional int32 entindex = 2;


    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }
    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendPlayerItemFound {
    fn is_initialized(&self) -> bool {
        for v in &self.iteminfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iteminfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iteminfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SendPlayerItemFound {
        CCSUsrMsg_SendPlayerItemFound::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>>(
                    "iteminfo",
                    |m: &CCSUsrMsg_SendPlayerItemFound| { &m.iteminfo },
                    |m: &mut CCSUsrMsg_SendPlayerItemFound| { &mut m.iteminfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entindex",
                    |m: &CCSUsrMsg_SendPlayerItemFound| { &m.entindex },
                    |m: &mut CCSUsrMsg_SendPlayerItemFound| { &mut m.entindex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SendPlayerItemFound>(
                    "CCSUsrMsg_SendPlayerItemFound",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SendPlayerItemFound {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SendPlayerItemFound> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SendPlayerItemFound,
        };
        unsafe {
            instance.get(CCSUsrMsg_SendPlayerItemFound::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SendPlayerItemFound {
    fn clear(&mut self) {
        self.iteminfo.clear();
        self.entindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SendPlayerItemFound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendPlayerItemFound {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ReloadEffect {
    // message fields
    entidx: ::std::option::Option<i32>,
    actanim: ::std::option::Option<i32>,
    origin_x: ::std::option::Option<f32>,
    origin_y: ::std::option::Option<f32>,
    origin_z: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ReloadEffect {
    fn default() -> &'a CCSUsrMsg_ReloadEffect {
        <CCSUsrMsg_ReloadEffect as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ReloadEffect {
    pub fn new() -> CCSUsrMsg_ReloadEffect {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional int32 actanim = 2;


    pub fn get_actanim(&self) -> i32 {
        self.actanim.unwrap_or(0)
    }
    pub fn clear_actanim(&mut self) {
        self.actanim = ::std::option::Option::None;
    }

    pub fn has_actanim(&self) -> bool {
        self.actanim.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actanim(&mut self, v: i32) {
        self.actanim = ::std::option::Option::Some(v);
    }

    // optional float origin_x = 3;


    pub fn get_origin_x(&self) -> f32 {
        self.origin_x.unwrap_or(0.)
    }
    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: f32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional float origin_y = 4;


    pub fn get_origin_y(&self) -> f32 {
        self.origin_y.unwrap_or(0.)
    }
    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: f32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional float origin_z = 5;


    pub fn get_origin_z(&self) -> f32 {
        self.origin_z.unwrap_or(0.)
    }
    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: f32) {
        self.origin_z = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ReloadEffect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.actanim = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_y = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.actanim {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin_x {
            my_size += 5;
        }
        if let Some(v) = self.origin_y {
            my_size += 5;
        }
        if let Some(v) = self.origin_z {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.actanim {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ReloadEffect {
        CCSUsrMsg_ReloadEffect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entidx",
                    |m: &CCSUsrMsg_ReloadEffect| { &m.entidx },
                    |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.entidx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "actanim",
                    |m: &CCSUsrMsg_ReloadEffect| { &m.actanim },
                    |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.actanim },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "origin_x",
                    |m: &CCSUsrMsg_ReloadEffect| { &m.origin_x },
                    |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.origin_x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "origin_y",
                    |m: &CCSUsrMsg_ReloadEffect| { &m.origin_y },
                    |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.origin_y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "origin_z",
                    |m: &CCSUsrMsg_ReloadEffect| { &m.origin_z },
                    |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.origin_z },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ReloadEffect>(
                    "CCSUsrMsg_ReloadEffect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ReloadEffect {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ReloadEffect> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ReloadEffect,
        };
        unsafe {
            instance.get(CCSUsrMsg_ReloadEffect::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ReloadEffect {
    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.actanim = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ReloadEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ReloadEffect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_WeaponSound {
    // message fields
    entidx: ::std::option::Option<i32>,
    origin_x: ::std::option::Option<f32>,
    origin_y: ::std::option::Option<f32>,
    origin_z: ::std::option::Option<f32>,
    sound: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_WeaponSound {
    fn default() -> &'a CCSUsrMsg_WeaponSound {
        <CCSUsrMsg_WeaponSound as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_WeaponSound {
    pub fn new() -> CCSUsrMsg_WeaponSound {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float origin_x = 2;


    pub fn get_origin_x(&self) -> f32 {
        self.origin_x.unwrap_or(0.)
    }
    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: f32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional float origin_y = 3;


    pub fn get_origin_y(&self) -> f32 {
        self.origin_y.unwrap_or(0.)
    }
    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: f32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional float origin_z = 4;


    pub fn get_origin_z(&self) -> f32 {
        self.origin_z.unwrap_or(0.)
    }
    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: f32) {
        self.origin_z = ::std::option::Option::Some(v);
    }

    // optional string sound = 5;


    pub fn get_sound(&self) -> &str {
        match self.sound.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sound(&mut self) {
        self.sound.clear();
    }

    pub fn has_sound(&self) -> bool {
        self.sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound(&mut self, v: ::std::string::String) {
        self.sound = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sound(&mut self) -> &mut ::std::string::String {
        if self.sound.is_none() {
            self.sound.set_default();
        }
        self.sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_sound(&mut self) -> ::std::string::String {
        self.sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float timestamp = 6;


    pub fn get_timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_WeaponSound {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_z = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sound)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin_x {
            my_size += 5;
        }
        if let Some(v) = self.origin_y {
            my_size += 5;
        }
        if let Some(v) = self.origin_z {
            my_size += 5;
        }
        if let Some(ref v) = self.sound.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_float(4, v)?;
        }
        if let Some(ref v) = self.sound.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_WeaponSound {
        CCSUsrMsg_WeaponSound::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entidx",
                    |m: &CCSUsrMsg_WeaponSound| { &m.entidx },
                    |m: &mut CCSUsrMsg_WeaponSound| { &mut m.entidx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "origin_x",
                    |m: &CCSUsrMsg_WeaponSound| { &m.origin_x },
                    |m: &mut CCSUsrMsg_WeaponSound| { &mut m.origin_x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "origin_y",
                    |m: &CCSUsrMsg_WeaponSound| { &m.origin_y },
                    |m: &mut CCSUsrMsg_WeaponSound| { &mut m.origin_y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "origin_z",
                    |m: &CCSUsrMsg_WeaponSound| { &m.origin_z },
                    |m: &mut CCSUsrMsg_WeaponSound| { &mut m.origin_z },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sound",
                    |m: &CCSUsrMsg_WeaponSound| { &m.sound },
                    |m: &mut CCSUsrMsg_WeaponSound| { &mut m.sound },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "timestamp",
                    |m: &CCSUsrMsg_WeaponSound| { &m.timestamp },
                    |m: &mut CCSUsrMsg_WeaponSound| { &mut m.timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_WeaponSound>(
                    "CCSUsrMsg_WeaponSound",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_WeaponSound {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_WeaponSound> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_WeaponSound,
        };
        unsafe {
            instance.get(CCSUsrMsg_WeaponSound::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_WeaponSound {
    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.sound.clear();
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_WeaponSound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_WeaponSound {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_UpdateScreenHealthBar {
    // message fields
    entidx: ::std::option::Option<i32>,
    healthratio_old: ::std::option::Option<f32>,
    healthratio_new: ::std::option::Option<f32>,
    style: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_UpdateScreenHealthBar {
    fn default() -> &'a CCSUsrMsg_UpdateScreenHealthBar {
        <CCSUsrMsg_UpdateScreenHealthBar as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_UpdateScreenHealthBar {
    pub fn new() -> CCSUsrMsg_UpdateScreenHealthBar {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float healthratio_old = 2;


    pub fn get_healthratio_old(&self) -> f32 {
        self.healthratio_old.unwrap_or(0.)
    }
    pub fn clear_healthratio_old(&mut self) {
        self.healthratio_old = ::std::option::Option::None;
    }

    pub fn has_healthratio_old(&self) -> bool {
        self.healthratio_old.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthratio_old(&mut self, v: f32) {
        self.healthratio_old = ::std::option::Option::Some(v);
    }

    // optional float healthratio_new = 3;


    pub fn get_healthratio_new(&self) -> f32 {
        self.healthratio_new.unwrap_or(0.)
    }
    pub fn clear_healthratio_new(&mut self) {
        self.healthratio_new = ::std::option::Option::None;
    }

    pub fn has_healthratio_new(&self) -> bool {
        self.healthratio_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthratio_new(&mut self, v: f32) {
        self.healthratio_new = ::std::option::Option::Some(v);
    }

    // optional int32 style = 4;


    pub fn get_style(&self) -> i32 {
        self.style.unwrap_or(0)
    }
    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: i32) {
        self.style = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_UpdateScreenHealthBar {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.healthratio_old = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.healthratio_new = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.style = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healthratio_old {
            my_size += 5;
        }
        if let Some(v) = self.healthratio_new {
            my_size += 5;
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.healthratio_old {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.healthratio_new {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.style {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_UpdateScreenHealthBar {
        CCSUsrMsg_UpdateScreenHealthBar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entidx",
                    |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.entidx },
                    |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.entidx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "healthratio_old",
                    |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.healthratio_old },
                    |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.healthratio_old },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "healthratio_new",
                    |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.healthratio_new },
                    |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.healthratio_new },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "style",
                    |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.style },
                    |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.style },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_UpdateScreenHealthBar>(
                    "CCSUsrMsg_UpdateScreenHealthBar",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_UpdateScreenHealthBar {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_UpdateScreenHealthBar> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_UpdateScreenHealthBar,
        };
        unsafe {
            instance.get(CCSUsrMsg_UpdateScreenHealthBar::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_UpdateScreenHealthBar {
    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.healthratio_old = ::std::option::Option::None;
        self.healthratio_new = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_UpdateScreenHealthBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_UpdateScreenHealthBar {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_EntityOutlineHighlight {
    // message fields
    entidx: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_EntityOutlineHighlight {
    fn default() -> &'a CCSUsrMsg_EntityOutlineHighlight {
        <CCSUsrMsg_EntityOutlineHighlight as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_EntityOutlineHighlight {
    pub fn new() -> CCSUsrMsg_EntityOutlineHighlight {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_EntityOutlineHighlight {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_EntityOutlineHighlight {
        CCSUsrMsg_EntityOutlineHighlight::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entidx",
                    |m: &CCSUsrMsg_EntityOutlineHighlight| { &m.entidx },
                    |m: &mut CCSUsrMsg_EntityOutlineHighlight| { &mut m.entidx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_EntityOutlineHighlight>(
                    "CCSUsrMsg_EntityOutlineHighlight",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_EntityOutlineHighlight {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_EntityOutlineHighlight> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_EntityOutlineHighlight,
        };
        unsafe {
            instance.get(CCSUsrMsg_EntityOutlineHighlight::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_EntityOutlineHighlight {
    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_EntityOutlineHighlight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_EntityOutlineHighlight {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_AdjustMoney {
    // message fields
    amount: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AdjustMoney {
    fn default() -> &'a CCSUsrMsg_AdjustMoney {
        <CCSUsrMsg_AdjustMoney as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AdjustMoney {
    pub fn new() -> CCSUsrMsg_AdjustMoney {
        ::std::default::Default::default()
    }

    // optional int32 amount = 1;


    pub fn get_amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_AdjustMoney {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.amount {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_AdjustMoney {
        CCSUsrMsg_AdjustMoney::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "amount",
                    |m: &CCSUsrMsg_AdjustMoney| { &m.amount },
                    |m: &mut CCSUsrMsg_AdjustMoney| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_AdjustMoney>(
                    "CCSUsrMsg_AdjustMoney",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_AdjustMoney {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_AdjustMoney> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_AdjustMoney,
        };
        unsafe {
            instance.get(CCSUsrMsg_AdjustMoney::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_AdjustMoney {
    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_AdjustMoney {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_AdjustMoney {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ReportHit {
    // message fields
    pos_x: ::std::option::Option<f32>,
    pos_y: ::std::option::Option<f32>,
    timestamp: ::std::option::Option<f32>,
    pos_z: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ReportHit {
    fn default() -> &'a CCSUsrMsg_ReportHit {
        <CCSUsrMsg_ReportHit as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ReportHit {
    pub fn new() -> CCSUsrMsg_ReportHit {
        ::std::default::Default::default()
    }

    // optional float pos_x = 1;


    pub fn get_pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }
    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 2;


    pub fn get_pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }
    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float timestamp = 4;


    pub fn get_timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 3;


    pub fn get_pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }
    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ReportHit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pos_x {
            my_size += 5;
        }
        if let Some(v) = self.pos_y {
            my_size += 5;
        }
        if let Some(v) = self.timestamp {
            my_size += 5;
        }
        if let Some(v) = self.pos_z {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pos_x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ReportHit {
        CCSUsrMsg_ReportHit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pos_x",
                    |m: &CCSUsrMsg_ReportHit| { &m.pos_x },
                    |m: &mut CCSUsrMsg_ReportHit| { &mut m.pos_x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pos_y",
                    |m: &CCSUsrMsg_ReportHit| { &m.pos_y },
                    |m: &mut CCSUsrMsg_ReportHit| { &mut m.pos_y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "timestamp",
                    |m: &CCSUsrMsg_ReportHit| { &m.timestamp },
                    |m: &mut CCSUsrMsg_ReportHit| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pos_z",
                    |m: &CCSUsrMsg_ReportHit| { &m.pos_z },
                    |m: &mut CCSUsrMsg_ReportHit| { &mut m.pos_z },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ReportHit>(
                    "CCSUsrMsg_ReportHit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ReportHit {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ReportHit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ReportHit,
        };
        unsafe {
            instance.get(CCSUsrMsg_ReportHit::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ReportHit {
    fn clear(&mut self) {
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ReportHit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ReportHit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_KillCam {
    // message fields
    obs_mode: ::std::option::Option<i32>,
    first_target: ::std::option::Option<i32>,
    second_target: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_KillCam {
    fn default() -> &'a CCSUsrMsg_KillCam {
        <CCSUsrMsg_KillCam as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_KillCam {
    pub fn new() -> CCSUsrMsg_KillCam {
        ::std::default::Default::default()
    }

    // optional int32 obs_mode = 1;


    pub fn get_obs_mode(&self) -> i32 {
        self.obs_mode.unwrap_or(0)
    }
    pub fn clear_obs_mode(&mut self) {
        self.obs_mode = ::std::option::Option::None;
    }

    pub fn has_obs_mode(&self) -> bool {
        self.obs_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_obs_mode(&mut self, v: i32) {
        self.obs_mode = ::std::option::Option::Some(v);
    }

    // optional int32 first_target = 2;


    pub fn get_first_target(&self) -> i32 {
        self.first_target.unwrap_or(0)
    }
    pub fn clear_first_target(&mut self) {
        self.first_target = ::std::option::Option::None;
    }

    pub fn has_first_target(&self) -> bool {
        self.first_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_target(&mut self, v: i32) {
        self.first_target = ::std::option::Option::Some(v);
    }

    // optional int32 second_target = 3;


    pub fn get_second_target(&self) -> i32 {
        self.second_target.unwrap_or(0)
    }
    pub fn clear_second_target(&mut self) {
        self.second_target = ::std::option::Option::None;
    }

    pub fn has_second_target(&self) -> bool {
        self.second_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_second_target(&mut self, v: i32) {
        self.second_target = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_KillCam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.obs_mode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.first_target = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.second_target = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.obs_mode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_target {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.second_target {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.obs_mode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.first_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.second_target {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_KillCam {
        CCSUsrMsg_KillCam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "obs_mode",
                    |m: &CCSUsrMsg_KillCam| { &m.obs_mode },
                    |m: &mut CCSUsrMsg_KillCam| { &mut m.obs_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "first_target",
                    |m: &CCSUsrMsg_KillCam| { &m.first_target },
                    |m: &mut CCSUsrMsg_KillCam| { &mut m.first_target },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "second_target",
                    |m: &CCSUsrMsg_KillCam| { &m.second_target },
                    |m: &mut CCSUsrMsg_KillCam| { &mut m.second_target },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_KillCam>(
                    "CCSUsrMsg_KillCam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_KillCam {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_KillCam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_KillCam,
        };
        unsafe {
            instance.get(CCSUsrMsg_KillCam::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_KillCam {
    fn clear(&mut self) {
        self.obs_mode = ::std::option::Option::None;
        self.first_target = ::std::option::Option::None;
        self.second_target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_KillCam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_KillCam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_DesiredTimescale {
    // message fields
    desired_timescale: ::std::option::Option<f32>,
    duration_realtime_sec: ::std::option::Option<f32>,
    interpolator_type: ::std::option::Option<i32>,
    start_blend_time: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DesiredTimescale {
    fn default() -> &'a CCSUsrMsg_DesiredTimescale {
        <CCSUsrMsg_DesiredTimescale as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DesiredTimescale {
    pub fn new() -> CCSUsrMsg_DesiredTimescale {
        ::std::default::Default::default()
    }

    // optional float desired_timescale = 1;


    pub fn get_desired_timescale(&self) -> f32 {
        self.desired_timescale.unwrap_or(0.)
    }
    pub fn clear_desired_timescale(&mut self) {
        self.desired_timescale = ::std::option::Option::None;
    }

    pub fn has_desired_timescale(&self) -> bool {
        self.desired_timescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_timescale(&mut self, v: f32) {
        self.desired_timescale = ::std::option::Option::Some(v);
    }

    // optional float duration_realtime_sec = 2;


    pub fn get_duration_realtime_sec(&self) -> f32 {
        self.duration_realtime_sec.unwrap_or(0.)
    }
    pub fn clear_duration_realtime_sec(&mut self) {
        self.duration_realtime_sec = ::std::option::Option::None;
    }

    pub fn has_duration_realtime_sec(&self) -> bool {
        self.duration_realtime_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_realtime_sec(&mut self, v: f32) {
        self.duration_realtime_sec = ::std::option::Option::Some(v);
    }

    // optional int32 interpolator_type = 3;


    pub fn get_interpolator_type(&self) -> i32 {
        self.interpolator_type.unwrap_or(0)
    }
    pub fn clear_interpolator_type(&mut self) {
        self.interpolator_type = ::std::option::Option::None;
    }

    pub fn has_interpolator_type(&self) -> bool {
        self.interpolator_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interpolator_type(&mut self, v: i32) {
        self.interpolator_type = ::std::option::Option::Some(v);
    }

    // optional float start_blend_time = 4;


    pub fn get_start_blend_time(&self) -> f32 {
        self.start_blend_time.unwrap_or(0.)
    }
    pub fn clear_start_blend_time(&mut self) {
        self.start_blend_time = ::std::option::Option::None;
    }

    pub fn has_start_blend_time(&self) -> bool {
        self.start_blend_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_blend_time(&mut self, v: f32) {
        self.start_blend_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_DesiredTimescale {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desired_timescale = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration_realtime_sec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.interpolator_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.start_blend_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.desired_timescale {
            my_size += 5;
        }
        if let Some(v) = self.duration_realtime_sec {
            my_size += 5;
        }
        if let Some(v) = self.interpolator_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_blend_time {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.desired_timescale {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.duration_realtime_sec {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.interpolator_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.start_blend_time {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_DesiredTimescale {
        CCSUsrMsg_DesiredTimescale::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "desired_timescale",
                    |m: &CCSUsrMsg_DesiredTimescale| { &m.desired_timescale },
                    |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.desired_timescale },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "duration_realtime_sec",
                    |m: &CCSUsrMsg_DesiredTimescale| { &m.duration_realtime_sec },
                    |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.duration_realtime_sec },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "interpolator_type",
                    |m: &CCSUsrMsg_DesiredTimescale| { &m.interpolator_type },
                    |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.interpolator_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "start_blend_time",
                    |m: &CCSUsrMsg_DesiredTimescale| { &m.start_blend_time },
                    |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.start_blend_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_DesiredTimescale>(
                    "CCSUsrMsg_DesiredTimescale",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_DesiredTimescale {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_DesiredTimescale> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_DesiredTimescale,
        };
        unsafe {
            instance.get(CCSUsrMsg_DesiredTimescale::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_DesiredTimescale {
    fn clear(&mut self) {
        self.desired_timescale = ::std::option::Option::None;
        self.duration_realtime_sec = ::std::option::Option::None;
        self.interpolator_type = ::std::option::Option::None;
        self.start_blend_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_DesiredTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DesiredTimescale {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_CurrentTimescale {
    // message fields
    cur_timescale: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CurrentTimescale {
    fn default() -> &'a CCSUsrMsg_CurrentTimescale {
        <CCSUsrMsg_CurrentTimescale as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CurrentTimescale {
    pub fn new() -> CCSUsrMsg_CurrentTimescale {
        ::std::default::Default::default()
    }

    // optional float cur_timescale = 1;


    pub fn get_cur_timescale(&self) -> f32 {
        self.cur_timescale.unwrap_or(0.)
    }
    pub fn clear_cur_timescale(&mut self) {
        self.cur_timescale = ::std::option::Option::None;
    }

    pub fn has_cur_timescale(&self) -> bool {
        self.cur_timescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cur_timescale(&mut self, v: f32) {
        self.cur_timescale = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_CurrentTimescale {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cur_timescale = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cur_timescale {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cur_timescale {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_CurrentTimescale {
        CCSUsrMsg_CurrentTimescale::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cur_timescale",
                    |m: &CCSUsrMsg_CurrentTimescale| { &m.cur_timescale },
                    |m: &mut CCSUsrMsg_CurrentTimescale| { &mut m.cur_timescale },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_CurrentTimescale>(
                    "CCSUsrMsg_CurrentTimescale",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_CurrentTimescale {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_CurrentTimescale> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_CurrentTimescale,
        };
        unsafe {
            instance.get(CCSUsrMsg_CurrentTimescale::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_CurrentTimescale {
    fn clear(&mut self) {
        self.cur_timescale = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_CurrentTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CurrentTimescale {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_AchievementEvent {
    // message fields
    achievement: ::std::option::Option<i32>,
    count: ::std::option::Option<i32>,
    user_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AchievementEvent {
    fn default() -> &'a CCSUsrMsg_AchievementEvent {
        <CCSUsrMsg_AchievementEvent as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AchievementEvent {
    pub fn new() -> CCSUsrMsg_AchievementEvent {
        ::std::default::Default::default()
    }

    // optional int32 achievement = 1;


    pub fn get_achievement(&self) -> i32 {
        self.achievement.unwrap_or(0)
    }
    pub fn clear_achievement(&mut self) {
        self.achievement = ::std::option::Option::None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: i32) {
        self.achievement = ::std::option::Option::Some(v);
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 user_id = 3;


    pub fn get_user_id(&self) -> i32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: i32) {
        self.user_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_AchievementEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.achievement = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.achievement {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.achievement {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.user_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_AchievementEvent {
        CCSUsrMsg_AchievementEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "achievement",
                    |m: &CCSUsrMsg_AchievementEvent| { &m.achievement },
                    |m: &mut CCSUsrMsg_AchievementEvent| { &mut m.achievement },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "count",
                    |m: &CCSUsrMsg_AchievementEvent| { &m.count },
                    |m: &mut CCSUsrMsg_AchievementEvent| { &mut m.count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "user_id",
                    |m: &CCSUsrMsg_AchievementEvent| { &m.user_id },
                    |m: &mut CCSUsrMsg_AchievementEvent| { &mut m.user_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_AchievementEvent>(
                    "CCSUsrMsg_AchievementEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_AchievementEvent {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_AchievementEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_AchievementEvent,
        };
        unsafe {
            instance.get(CCSUsrMsg_AchievementEvent::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_AchievementEvent {
    fn clear(&mut self) {
        self.achievement = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.user_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_AchievementEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_AchievementEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_MatchEndConditions {
    // message fields
    fraglimit: ::std::option::Option<i32>,
    mp_maxrounds: ::std::option::Option<i32>,
    mp_winlimit: ::std::option::Option<i32>,
    mp_timelimit: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MatchEndConditions {
    fn default() -> &'a CCSUsrMsg_MatchEndConditions {
        <CCSUsrMsg_MatchEndConditions as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MatchEndConditions {
    pub fn new() -> CCSUsrMsg_MatchEndConditions {
        ::std::default::Default::default()
    }

    // optional int32 fraglimit = 1;


    pub fn get_fraglimit(&self) -> i32 {
        self.fraglimit.unwrap_or(0)
    }
    pub fn clear_fraglimit(&mut self) {
        self.fraglimit = ::std::option::Option::None;
    }

    pub fn has_fraglimit(&self) -> bool {
        self.fraglimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fraglimit(&mut self, v: i32) {
        self.fraglimit = ::std::option::Option::Some(v);
    }

    // optional int32 mp_maxrounds = 2;


    pub fn get_mp_maxrounds(&self) -> i32 {
        self.mp_maxrounds.unwrap_or(0)
    }
    pub fn clear_mp_maxrounds(&mut self) {
        self.mp_maxrounds = ::std::option::Option::None;
    }

    pub fn has_mp_maxrounds(&self) -> bool {
        self.mp_maxrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_maxrounds(&mut self, v: i32) {
        self.mp_maxrounds = ::std::option::Option::Some(v);
    }

    // optional int32 mp_winlimit = 3;


    pub fn get_mp_winlimit(&self) -> i32 {
        self.mp_winlimit.unwrap_or(0)
    }
    pub fn clear_mp_winlimit(&mut self) {
        self.mp_winlimit = ::std::option::Option::None;
    }

    pub fn has_mp_winlimit(&self) -> bool {
        self.mp_winlimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_winlimit(&mut self, v: i32) {
        self.mp_winlimit = ::std::option::Option::Some(v);
    }

    // optional int32 mp_timelimit = 4;


    pub fn get_mp_timelimit(&self) -> i32 {
        self.mp_timelimit.unwrap_or(0)
    }
    pub fn clear_mp_timelimit(&mut self) {
        self.mp_timelimit = ::std::option::Option::None;
    }

    pub fn has_mp_timelimit(&self) -> bool {
        self.mp_timelimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_timelimit(&mut self, v: i32) {
        self.mp_timelimit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_MatchEndConditions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fraglimit = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mp_maxrounds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mp_winlimit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mp_timelimit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fraglimit {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mp_maxrounds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mp_winlimit {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mp_timelimit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fraglimit {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mp_maxrounds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.mp_winlimit {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.mp_timelimit {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_MatchEndConditions {
        CCSUsrMsg_MatchEndConditions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "fraglimit",
                    |m: &CCSUsrMsg_MatchEndConditions| { &m.fraglimit },
                    |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.fraglimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mp_maxrounds",
                    |m: &CCSUsrMsg_MatchEndConditions| { &m.mp_maxrounds },
                    |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.mp_maxrounds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mp_winlimit",
                    |m: &CCSUsrMsg_MatchEndConditions| { &m.mp_winlimit },
                    |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.mp_winlimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mp_timelimit",
                    |m: &CCSUsrMsg_MatchEndConditions| { &m.mp_timelimit },
                    |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.mp_timelimit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_MatchEndConditions>(
                    "CCSUsrMsg_MatchEndConditions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_MatchEndConditions {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_MatchEndConditions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_MatchEndConditions,
        };
        unsafe {
            instance.get(CCSUsrMsg_MatchEndConditions::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_MatchEndConditions {
    fn clear(&mut self) {
        self.fraglimit = ::std::option::Option::None;
        self.mp_maxrounds = ::std::option::Option::None;
        self.mp_winlimit = ::std::option::Option::None;
        self.mp_timelimit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_MatchEndConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_MatchEndConditions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_PlayerStatsUpdate {
    // message fields
    version: ::std::option::Option<i32>,
    stats: ::protobuf::RepeatedField<CCSUsrMsg_PlayerStatsUpdate_Stat>,
    user_id: ::std::option::Option<i32>,
    crc: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PlayerStatsUpdate {
    fn default() -> &'a CCSUsrMsg_PlayerStatsUpdate {
        <CCSUsrMsg_PlayerStatsUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PlayerStatsUpdate {
    pub fn new() -> CCSUsrMsg_PlayerStatsUpdate {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // repeated .CCSUsrMsg_PlayerStatsUpdate.Stat stats = 4;


    pub fn get_stats(&self) -> &[CCSUsrMsg_PlayerStatsUpdate_Stat] {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_PlayerStatsUpdate_Stat>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_PlayerStatsUpdate_Stat> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_PlayerStatsUpdate_Stat> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    // optional int32 user_id = 5;


    pub fn get_user_id(&self) -> i32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: i32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // optional int32 crc = 6;


    pub fn get_crc(&self) -> i32 {
        self.crc.unwrap_or(0)
    }
    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: i32) {
        self.crc = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_PlayerStatsUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.crc = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.crc {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        for v in &self.stats {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.user_id {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.crc {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_PlayerStatsUpdate {
        CCSUsrMsg_PlayerStatsUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "version",
                    |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.version },
                    |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_PlayerStatsUpdate_Stat>>(
                    "stats",
                    |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.stats },
                    |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "user_id",
                    |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.user_id },
                    |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "crc",
                    |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.crc },
                    |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.crc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_PlayerStatsUpdate>(
                    "CCSUsrMsg_PlayerStatsUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_PlayerStatsUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_PlayerStatsUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_PlayerStatsUpdate,
        };
        unsafe {
            instance.get(CCSUsrMsg_PlayerStatsUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_PlayerStatsUpdate {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.stats.clear();
        self.user_id = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_PlayerStatsUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_PlayerStatsUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_PlayerStatsUpdate_Stat {
    // message fields
    idx: ::std::option::Option<i32>,
    delta: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PlayerStatsUpdate_Stat {
    fn default() -> &'a CCSUsrMsg_PlayerStatsUpdate_Stat {
        <CCSUsrMsg_PlayerStatsUpdate_Stat as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PlayerStatsUpdate_Stat {
    pub fn new() -> CCSUsrMsg_PlayerStatsUpdate_Stat {
        ::std::default::Default::default()
    }

    // optional int32 idx = 1;


    pub fn get_idx(&self) -> i32 {
        self.idx.unwrap_or(0)
    }
    pub fn clear_idx(&mut self) {
        self.idx = ::std::option::Option::None;
    }

    pub fn has_idx(&self) -> bool {
        self.idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idx(&mut self, v: i32) {
        self.idx = ::std::option::Option::Some(v);
    }

    // optional int32 delta = 2;


    pub fn get_delta(&self) -> i32 {
        self.delta.unwrap_or(0)
    }
    pub fn clear_delta(&mut self) {
        self.delta = ::std::option::Option::None;
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: i32) {
        self.delta = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_PlayerStatsUpdate_Stat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.delta = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.delta {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.delta {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_PlayerStatsUpdate_Stat {
        CCSUsrMsg_PlayerStatsUpdate_Stat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "idx",
                    |m: &CCSUsrMsg_PlayerStatsUpdate_Stat| { &m.idx },
                    |m: &mut CCSUsrMsg_PlayerStatsUpdate_Stat| { &mut m.idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "delta",
                    |m: &CCSUsrMsg_PlayerStatsUpdate_Stat| { &m.delta },
                    |m: &mut CCSUsrMsg_PlayerStatsUpdate_Stat| { &mut m.delta },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_PlayerStatsUpdate_Stat>(
                    "CCSUsrMsg_PlayerStatsUpdate_Stat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_PlayerStatsUpdate_Stat {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_PlayerStatsUpdate_Stat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_PlayerStatsUpdate_Stat,
        };
        unsafe {
            instance.get(CCSUsrMsg_PlayerStatsUpdate_Stat::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_PlayerStatsUpdate_Stat {
    fn clear(&mut self) {
        self.idx = ::std::option::Option::None;
        self.delta = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_PlayerStatsUpdate_Stat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_PlayerStatsUpdate_Stat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_DisplayInventory {
    // message fields
    display: ::std::option::Option<bool>,
    user_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DisplayInventory {
    fn default() -> &'a CCSUsrMsg_DisplayInventory {
        <CCSUsrMsg_DisplayInventory as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DisplayInventory {
    pub fn new() -> CCSUsrMsg_DisplayInventory {
        ::std::default::Default::default()
    }

    // optional bool display = 1;


    pub fn get_display(&self) -> bool {
        self.display.unwrap_or(false)
    }
    pub fn clear_display(&mut self) {
        self.display = ::std::option::Option::None;
    }

    pub fn has_display(&self) -> bool {
        self.display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display(&mut self, v: bool) {
        self.display = ::std::option::Option::Some(v);
    }

    // optional int32 user_id = 2;


    pub fn get_user_id(&self) -> i32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: i32) {
        self.user_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_DisplayInventory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.display = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display {
            my_size += 2;
        }
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.user_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_DisplayInventory {
        CCSUsrMsg_DisplayInventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "display",
                    |m: &CCSUsrMsg_DisplayInventory| { &m.display },
                    |m: &mut CCSUsrMsg_DisplayInventory| { &mut m.display },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "user_id",
                    |m: &CCSUsrMsg_DisplayInventory| { &m.user_id },
                    |m: &mut CCSUsrMsg_DisplayInventory| { &mut m.user_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_DisplayInventory>(
                    "CCSUsrMsg_DisplayInventory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_DisplayInventory {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_DisplayInventory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_DisplayInventory,
        };
        unsafe {
            instance.get(CCSUsrMsg_DisplayInventory::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_DisplayInventory {
    fn clear(&mut self) {
        self.display = ::std::option::Option::None;
        self.user_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_DisplayInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DisplayInventory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_QuestProgress {
    // message fields
    quest_id: ::std::option::Option<u32>,
    normal_points: ::std::option::Option<u32>,
    bonus_points: ::std::option::Option<u32>,
    is_event_quest: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_QuestProgress {
    fn default() -> &'a CCSUsrMsg_QuestProgress {
        <CCSUsrMsg_QuestProgress as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_QuestProgress {
    pub fn new() -> CCSUsrMsg_QuestProgress {
        ::std::default::Default::default()
    }

    // optional uint32 quest_id = 1;


    pub fn get_quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 normal_points = 2;


    pub fn get_normal_points(&self) -> u32 {
        self.normal_points.unwrap_or(0)
    }
    pub fn clear_normal_points(&mut self) {
        self.normal_points = ::std::option::Option::None;
    }

    pub fn has_normal_points(&self) -> bool {
        self.normal_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal_points(&mut self, v: u32) {
        self.normal_points = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_points = 3;


    pub fn get_bonus_points(&self) -> u32 {
        self.bonus_points.unwrap_or(0)
    }
    pub fn clear_bonus_points(&mut self) {
        self.bonus_points = ::std::option::Option::None;
    }

    pub fn has_bonus_points(&self) -> bool {
        self.bonus_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_points(&mut self, v: u32) {
        self.bonus_points = ::std::option::Option::Some(v);
    }

    // optional bool is_event_quest = 4;


    pub fn get_is_event_quest(&self) -> bool {
        self.is_event_quest.unwrap_or(false)
    }
    pub fn clear_is_event_quest(&mut self) {
        self.is_event_quest = ::std::option::Option::None;
    }

    pub fn has_is_event_quest(&self) -> bool {
        self.is_event_quest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_event_quest(&mut self, v: bool) {
        self.is_event_quest = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_QuestProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.normal_points = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bonus_points = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_event_quest = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.normal_points {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bonus_points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_event_quest {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.normal_points {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_event_quest {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_QuestProgress {
        CCSUsrMsg_QuestProgress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quest_id",
                    |m: &CCSUsrMsg_QuestProgress| { &m.quest_id },
                    |m: &mut CCSUsrMsg_QuestProgress| { &mut m.quest_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "normal_points",
                    |m: &CCSUsrMsg_QuestProgress| { &m.normal_points },
                    |m: &mut CCSUsrMsg_QuestProgress| { &mut m.normal_points },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bonus_points",
                    |m: &CCSUsrMsg_QuestProgress| { &m.bonus_points },
                    |m: &mut CCSUsrMsg_QuestProgress| { &mut m.bonus_points },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_event_quest",
                    |m: &CCSUsrMsg_QuestProgress| { &m.is_event_quest },
                    |m: &mut CCSUsrMsg_QuestProgress| { &mut m.is_event_quest },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_QuestProgress>(
                    "CCSUsrMsg_QuestProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_QuestProgress {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_QuestProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_QuestProgress,
        };
        unsafe {
            instance.get(CCSUsrMsg_QuestProgress::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_QuestProgress {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.normal_points = ::std::option::Option::None;
        self.bonus_points = ::std::option::Option::None;
        self.is_event_quest = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_QuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_QuestProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ScoreLeaderboardData {
    // message fields
    data: ::protobuf::SingularPtrField<super::cstrike15_gcmessages::ScoreLeaderboardData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ScoreLeaderboardData {
    fn default() -> &'a CCSUsrMsg_ScoreLeaderboardData {
        <CCSUsrMsg_ScoreLeaderboardData as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ScoreLeaderboardData {
    pub fn new() -> CCSUsrMsg_ScoreLeaderboardData {
        ::std::default::Default::default()
    }

    // optional .ScoreLeaderboardData data = 1;


    pub fn get_data(&self) -> &super::cstrike15_gcmessages::ScoreLeaderboardData {
        self.data.as_ref().unwrap_or_else(|| super::cstrike15_gcmessages::ScoreLeaderboardData::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::cstrike15_gcmessages::ScoreLeaderboardData) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::cstrike15_gcmessages::ScoreLeaderboardData {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::cstrike15_gcmessages::ScoreLeaderboardData {
        self.data.take().unwrap_or_else(|| super::cstrike15_gcmessages::ScoreLeaderboardData::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ScoreLeaderboardData {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ScoreLeaderboardData {
        CCSUsrMsg_ScoreLeaderboardData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::ScoreLeaderboardData>>(
                    "data",
                    |m: &CCSUsrMsg_ScoreLeaderboardData| { &m.data },
                    |m: &mut CCSUsrMsg_ScoreLeaderboardData| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ScoreLeaderboardData>(
                    "CCSUsrMsg_ScoreLeaderboardData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ScoreLeaderboardData {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ScoreLeaderboardData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ScoreLeaderboardData,
        };
        unsafe {
            instance.get(CCSUsrMsg_ScoreLeaderboardData::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ScoreLeaderboardData {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ScoreLeaderboardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ScoreLeaderboardData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_PlayerDecalDigitalSignature {
    // message fields
    data: ::protobuf::SingularPtrField<super::cstrike15_gcmessages::PlayerDecalDigitalSignature>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PlayerDecalDigitalSignature {
    fn default() -> &'a CCSUsrMsg_PlayerDecalDigitalSignature {
        <CCSUsrMsg_PlayerDecalDigitalSignature as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PlayerDecalDigitalSignature {
    pub fn new() -> CCSUsrMsg_PlayerDecalDigitalSignature {
        ::std::default::Default::default()
    }

    // optional .PlayerDecalDigitalSignature data = 1;


    pub fn get_data(&self) -> &super::cstrike15_gcmessages::PlayerDecalDigitalSignature {
        self.data.as_ref().unwrap_or_else(|| super::cstrike15_gcmessages::PlayerDecalDigitalSignature::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::cstrike15_gcmessages::PlayerDecalDigitalSignature) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::cstrike15_gcmessages::PlayerDecalDigitalSignature {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::cstrike15_gcmessages::PlayerDecalDigitalSignature {
        self.data.take().unwrap_or_else(|| super::cstrike15_gcmessages::PlayerDecalDigitalSignature::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_PlayerDecalDigitalSignature {
        CCSUsrMsg_PlayerDecalDigitalSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::PlayerDecalDigitalSignature>>(
                    "data",
                    |m: &CCSUsrMsg_PlayerDecalDigitalSignature| { &m.data },
                    |m: &mut CCSUsrMsg_PlayerDecalDigitalSignature| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_PlayerDecalDigitalSignature>(
                    "CCSUsrMsg_PlayerDecalDigitalSignature",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_PlayerDecalDigitalSignature {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_PlayerDecalDigitalSignature> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_PlayerDecalDigitalSignature,
        };
        unsafe {
            instance.get(CCSUsrMsg_PlayerDecalDigitalSignature::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_XRankGet {
    // message fields
    mode_idx: ::std::option::Option<i32>,
    controller: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XRankGet {
    fn default() -> &'a CCSUsrMsg_XRankGet {
        <CCSUsrMsg_XRankGet as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XRankGet {
    pub fn new() -> CCSUsrMsg_XRankGet {
        ::std::default::Default::default()
    }

    // optional int32 mode_idx = 1;


    pub fn get_mode_idx(&self) -> i32 {
        self.mode_idx.unwrap_or(0)
    }
    pub fn clear_mode_idx(&mut self) {
        self.mode_idx = ::std::option::Option::None;
    }

    pub fn has_mode_idx(&self) -> bool {
        self.mode_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_idx(&mut self, v: i32) {
        self.mode_idx = ::std::option::Option::Some(v);
    }

    // optional int32 controller = 2;


    pub fn get_controller(&self) -> i32 {
        self.controller.unwrap_or(0)
    }
    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: i32) {
        self.controller = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_XRankGet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.controller = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.controller {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.controller {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_XRankGet {
        CCSUsrMsg_XRankGet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mode_idx",
                    |m: &CCSUsrMsg_XRankGet| { &m.mode_idx },
                    |m: &mut CCSUsrMsg_XRankGet| { &mut m.mode_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller",
                    |m: &CCSUsrMsg_XRankGet| { &m.controller },
                    |m: &mut CCSUsrMsg_XRankGet| { &mut m.controller },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_XRankGet>(
                    "CCSUsrMsg_XRankGet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_XRankGet {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_XRankGet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_XRankGet,
        };
        unsafe {
            instance.get(CCSUsrMsg_XRankGet::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_XRankGet {
    fn clear(&mut self) {
        self.mode_idx = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_XRankGet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_XRankGet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_XRankUpd {
    // message fields
    mode_idx: ::std::option::Option<i32>,
    controller: ::std::option::Option<i32>,
    ranking: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XRankUpd {
    fn default() -> &'a CCSUsrMsg_XRankUpd {
        <CCSUsrMsg_XRankUpd as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XRankUpd {
    pub fn new() -> CCSUsrMsg_XRankUpd {
        ::std::default::Default::default()
    }

    // optional int32 mode_idx = 1;


    pub fn get_mode_idx(&self) -> i32 {
        self.mode_idx.unwrap_or(0)
    }
    pub fn clear_mode_idx(&mut self) {
        self.mode_idx = ::std::option::Option::None;
    }

    pub fn has_mode_idx(&self) -> bool {
        self.mode_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_idx(&mut self, v: i32) {
        self.mode_idx = ::std::option::Option::Some(v);
    }

    // optional int32 controller = 2;


    pub fn get_controller(&self) -> i32 {
        self.controller.unwrap_or(0)
    }
    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: i32) {
        self.controller = ::std::option::Option::Some(v);
    }

    // optional int32 ranking = 3;


    pub fn get_ranking(&self) -> i32 {
        self.ranking.unwrap_or(0)
    }
    pub fn clear_ranking(&mut self) {
        self.ranking = ::std::option::Option::None;
    }

    pub fn has_ranking(&self) -> bool {
        self.ranking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranking(&mut self, v: i32) {
        self.ranking = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_XRankUpd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.controller = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ranking = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.controller {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ranking {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.controller {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ranking {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_XRankUpd {
        CCSUsrMsg_XRankUpd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mode_idx",
                    |m: &CCSUsrMsg_XRankUpd| { &m.mode_idx },
                    |m: &mut CCSUsrMsg_XRankUpd| { &mut m.mode_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "controller",
                    |m: &CCSUsrMsg_XRankUpd| { &m.controller },
                    |m: &mut CCSUsrMsg_XRankUpd| { &mut m.controller },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ranking",
                    |m: &CCSUsrMsg_XRankUpd| { &m.ranking },
                    |m: &mut CCSUsrMsg_XRankUpd| { &mut m.ranking },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_XRankUpd>(
                    "CCSUsrMsg_XRankUpd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_XRankUpd {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_XRankUpd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_XRankUpd,
        };
        unsafe {
            instance.get(CCSUsrMsg_XRankUpd::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_XRankUpd {
    fn clear(&mut self) {
        self.mode_idx = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.ranking = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_XRankUpd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_XRankUpd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_CallVoteFailed {
    // message fields
    reason: ::std::option::Option<i32>,
    time: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CallVoteFailed {
    fn default() -> &'a CCSUsrMsg_CallVoteFailed {
        <CCSUsrMsg_CallVoteFailed as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CallVoteFailed {
    pub fn new() -> CCSUsrMsg_CallVoteFailed {
        ::std::default::Default::default()
    }

    // optional int32 reason = 1;


    pub fn get_reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional int32 time = 2;


    pub fn get_time(&self) -> i32 {
        self.time.unwrap_or(0)
    }
    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_CallVoteFailed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reason {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_CallVoteFailed {
        CCSUsrMsg_CallVoteFailed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "reason",
                    |m: &CCSUsrMsg_CallVoteFailed| { &m.reason },
                    |m: &mut CCSUsrMsg_CallVoteFailed| { &mut m.reason },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "time",
                    |m: &CCSUsrMsg_CallVoteFailed| { &m.time },
                    |m: &mut CCSUsrMsg_CallVoteFailed| { &mut m.time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_CallVoteFailed>(
                    "CCSUsrMsg_CallVoteFailed",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_CallVoteFailed {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_CallVoteFailed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_CallVoteFailed,
        };
        unsafe {
            instance.get(CCSUsrMsg_CallVoteFailed::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_CallVoteFailed {
    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_CallVoteFailed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CallVoteFailed {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VoteStart {
    // message fields
    team: ::std::option::Option<i32>,
    ent_idx: ::std::option::Option<i32>,
    vote_type: ::std::option::Option<i32>,
    disp_str: ::protobuf::SingularField<::std::string::String>,
    details_str: ::protobuf::SingularField<::std::string::String>,
    other_team_str: ::protobuf::SingularField<::std::string::String>,
    is_yes_no_vote: ::std::option::Option<bool>,
    entidx_target: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteStart {
    fn default() -> &'a CCSUsrMsg_VoteStart {
        <CCSUsrMsg_VoteStart as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteStart {
    pub fn new() -> CCSUsrMsg_VoteStart {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;


    pub fn get_team(&self) -> i32 {
        self.team.unwrap_or(0)
    }
    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 ent_idx = 2;


    pub fn get_ent_idx(&self) -> i32 {
        self.ent_idx.unwrap_or(0)
    }
    pub fn clear_ent_idx(&mut self) {
        self.ent_idx = ::std::option::Option::None;
    }

    pub fn has_ent_idx(&self) -> bool {
        self.ent_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_idx(&mut self, v: i32) {
        self.ent_idx = ::std::option::Option::Some(v);
    }

    // optional int32 vote_type = 3;


    pub fn get_vote_type(&self) -> i32 {
        self.vote_type.unwrap_or(0)
    }
    pub fn clear_vote_type(&mut self) {
        self.vote_type = ::std::option::Option::None;
    }

    pub fn has_vote_type(&self) -> bool {
        self.vote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_type(&mut self, v: i32) {
        self.vote_type = ::std::option::Option::Some(v);
    }

    // optional string disp_str = 4;


    pub fn get_disp_str(&self) -> &str {
        match self.disp_str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_disp_str(&mut self) {
        self.disp_str.clear();
    }

    pub fn has_disp_str(&self) -> bool {
        self.disp_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_str(&mut self, v: ::std::string::String) {
        self.disp_str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disp_str(&mut self) -> &mut ::std::string::String {
        if self.disp_str.is_none() {
            self.disp_str.set_default();
        }
        self.disp_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_disp_str(&mut self) -> ::std::string::String {
        self.disp_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string details_str = 5;


    pub fn get_details_str(&self) -> &str {
        match self.details_str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_details_str(&mut self) {
        self.details_str.clear();
    }

    pub fn has_details_str(&self) -> bool {
        self.details_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details_str(&mut self, v: ::std::string::String) {
        self.details_str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details_str(&mut self) -> &mut ::std::string::String {
        if self.details_str.is_none() {
            self.details_str.set_default();
        }
        self.details_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_details_str(&mut self) -> ::std::string::String {
        self.details_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string other_team_str = 6;


    pub fn get_other_team_str(&self) -> &str {
        match self.other_team_str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_other_team_str(&mut self) {
        self.other_team_str.clear();
    }

    pub fn has_other_team_str(&self) -> bool {
        self.other_team_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_team_str(&mut self, v: ::std::string::String) {
        self.other_team_str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_team_str(&mut self) -> &mut ::std::string::String {
        if self.other_team_str.is_none() {
            self.other_team_str.set_default();
        }
        self.other_team_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_team_str(&mut self) -> ::std::string::String {
        self.other_team_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_yes_no_vote = 7;


    pub fn get_is_yes_no_vote(&self) -> bool {
        self.is_yes_no_vote.unwrap_or(false)
    }
    pub fn clear_is_yes_no_vote(&mut self) {
        self.is_yes_no_vote = ::std::option::Option::None;
    }

    pub fn has_is_yes_no_vote(&self) -> bool {
        self.is_yes_no_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_yes_no_vote(&mut self, v: bool) {
        self.is_yes_no_vote = ::std::option::Option::Some(v);
    }

    // optional int32 entidx_target = 8;


    pub fn get_entidx_target(&self) -> i32 {
        self.entidx_target.unwrap_or(0)
    }
    pub fn clear_entidx_target(&mut self) {
        self.entidx_target = ::std::option::Option::None;
    }

    pub fn has_entidx_target(&self) -> bool {
        self.entidx_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx_target(&mut self, v: i32) {
        self.entidx_target = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoteStart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ent_idx = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vote_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.disp_str)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.details_str)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.other_team_str)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_yes_no_vote = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx_target = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ent_idx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.disp_str.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.details_str.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.other_team_str.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.is_yes_no_vote {
            my_size += 2;
        }
        if let Some(v) = self.entidx_target {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ent_idx {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.vote_type {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.disp_str.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.details_str.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.other_team_str.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.is_yes_no_vote {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.entidx_target {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VoteStart {
        CCSUsrMsg_VoteStart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team",
                    |m: &CCSUsrMsg_VoteStart| { &m.team },
                    |m: &mut CCSUsrMsg_VoteStart| { &mut m.team },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ent_idx",
                    |m: &CCSUsrMsg_VoteStart| { &m.ent_idx },
                    |m: &mut CCSUsrMsg_VoteStart| { &mut m.ent_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "vote_type",
                    |m: &CCSUsrMsg_VoteStart| { &m.vote_type },
                    |m: &mut CCSUsrMsg_VoteStart| { &mut m.vote_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "disp_str",
                    |m: &CCSUsrMsg_VoteStart| { &m.disp_str },
                    |m: &mut CCSUsrMsg_VoteStart| { &mut m.disp_str },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "details_str",
                    |m: &CCSUsrMsg_VoteStart| { &m.details_str },
                    |m: &mut CCSUsrMsg_VoteStart| { &mut m.details_str },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "other_team_str",
                    |m: &CCSUsrMsg_VoteStart| { &m.other_team_str },
                    |m: &mut CCSUsrMsg_VoteStart| { &mut m.other_team_str },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_yes_no_vote",
                    |m: &CCSUsrMsg_VoteStart| { &m.is_yes_no_vote },
                    |m: &mut CCSUsrMsg_VoteStart| { &mut m.is_yes_no_vote },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entidx_target",
                    |m: &CCSUsrMsg_VoteStart| { &m.entidx_target },
                    |m: &mut CCSUsrMsg_VoteStart| { &mut m.entidx_target },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_VoteStart>(
                    "CCSUsrMsg_VoteStart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteStart {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_VoteStart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_VoteStart,
        };
        unsafe {
            instance.get(CCSUsrMsg_VoteStart::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VoteStart {
    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.ent_idx = ::std::option::Option::None;
        self.vote_type = ::std::option::Option::None;
        self.disp_str.clear();
        self.details_str.clear();
        self.other_team_str.clear();
        self.is_yes_no_vote = ::std::option::Option::None;
        self.entidx_target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VoteStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoteStart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VotePass {
    // message fields
    team: ::std::option::Option<i32>,
    vote_type: ::std::option::Option<i32>,
    disp_str: ::protobuf::SingularField<::std::string::String>,
    details_str: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VotePass {
    fn default() -> &'a CCSUsrMsg_VotePass {
        <CCSUsrMsg_VotePass as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VotePass {
    pub fn new() -> CCSUsrMsg_VotePass {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;


    pub fn get_team(&self) -> i32 {
        self.team.unwrap_or(0)
    }
    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 vote_type = 2;


    pub fn get_vote_type(&self) -> i32 {
        self.vote_type.unwrap_or(0)
    }
    pub fn clear_vote_type(&mut self) {
        self.vote_type = ::std::option::Option::None;
    }

    pub fn has_vote_type(&self) -> bool {
        self.vote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_type(&mut self, v: i32) {
        self.vote_type = ::std::option::Option::Some(v);
    }

    // optional string disp_str = 3;


    pub fn get_disp_str(&self) -> &str {
        match self.disp_str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_disp_str(&mut self) {
        self.disp_str.clear();
    }

    pub fn has_disp_str(&self) -> bool {
        self.disp_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_str(&mut self, v: ::std::string::String) {
        self.disp_str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disp_str(&mut self) -> &mut ::std::string::String {
        if self.disp_str.is_none() {
            self.disp_str.set_default();
        }
        self.disp_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_disp_str(&mut self) -> ::std::string::String {
        self.disp_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string details_str = 4;


    pub fn get_details_str(&self) -> &str {
        match self.details_str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_details_str(&mut self) {
        self.details_str.clear();
    }

    pub fn has_details_str(&self) -> bool {
        self.details_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details_str(&mut self, v: ::std::string::String) {
        self.details_str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details_str(&mut self) -> &mut ::std::string::String {
        if self.details_str.is_none() {
            self.details_str.set_default();
        }
        self.details_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_details_str(&mut self) -> ::std::string::String {
        self.details_str.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_VotePass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vote_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.disp_str)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.details_str)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.disp_str.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.details_str.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.vote_type {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.disp_str.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.details_str.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VotePass {
        CCSUsrMsg_VotePass::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team",
                    |m: &CCSUsrMsg_VotePass| { &m.team },
                    |m: &mut CCSUsrMsg_VotePass| { &mut m.team },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "vote_type",
                    |m: &CCSUsrMsg_VotePass| { &m.vote_type },
                    |m: &mut CCSUsrMsg_VotePass| { &mut m.vote_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "disp_str",
                    |m: &CCSUsrMsg_VotePass| { &m.disp_str },
                    |m: &mut CCSUsrMsg_VotePass| { &mut m.disp_str },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "details_str",
                    |m: &CCSUsrMsg_VotePass| { &m.details_str },
                    |m: &mut CCSUsrMsg_VotePass| { &mut m.details_str },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_VotePass>(
                    "CCSUsrMsg_VotePass",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_VotePass {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_VotePass> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_VotePass,
        };
        unsafe {
            instance.get(CCSUsrMsg_VotePass::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VotePass {
    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.vote_type = ::std::option::Option::None;
        self.disp_str.clear();
        self.details_str.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VotePass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VotePass {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VoteFailed {
    // message fields
    team: ::std::option::Option<i32>,
    reason: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteFailed {
    fn default() -> &'a CCSUsrMsg_VoteFailed {
        <CCSUsrMsg_VoteFailed as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteFailed {
    pub fn new() -> CCSUsrMsg_VoteFailed {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;


    pub fn get_team(&self) -> i32 {
        self.team.unwrap_or(0)
    }
    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 reason = 2;


    pub fn get_reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoteFailed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VoteFailed {
        CCSUsrMsg_VoteFailed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "team",
                    |m: &CCSUsrMsg_VoteFailed| { &m.team },
                    |m: &mut CCSUsrMsg_VoteFailed| { &mut m.team },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "reason",
                    |m: &CCSUsrMsg_VoteFailed| { &m.reason },
                    |m: &mut CCSUsrMsg_VoteFailed| { &mut m.reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_VoteFailed>(
                    "CCSUsrMsg_VoteFailed",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteFailed {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_VoteFailed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_VoteFailed,
        };
        unsafe {
            instance.get(CCSUsrMsg_VoteFailed::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VoteFailed {
    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VoteFailed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoteFailed {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VoteSetup {
    // message fields
    potential_issues: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteSetup {
    fn default() -> &'a CCSUsrMsg_VoteSetup {
        <CCSUsrMsg_VoteSetup as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteSetup {
    pub fn new() -> CCSUsrMsg_VoteSetup {
        ::std::default::Default::default()
    }

    // repeated string potential_issues = 1;


    pub fn get_potential_issues(&self) -> &[::std::string::String] {
        &self.potential_issues
    }
    pub fn clear_potential_issues(&mut self) {
        self.potential_issues.clear();
    }

    // Param is passed by value, moved
    pub fn set_potential_issues(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.potential_issues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_potential_issues(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.potential_issues
    }

    // Take field
    pub fn take_potential_issues(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.potential_issues, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoteSetup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.potential_issues)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.potential_issues {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.potential_issues {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VoteSetup {
        CCSUsrMsg_VoteSetup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "potential_issues",
                    |m: &CCSUsrMsg_VoteSetup| { &m.potential_issues },
                    |m: &mut CCSUsrMsg_VoteSetup| { &mut m.potential_issues },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_VoteSetup>(
                    "CCSUsrMsg_VoteSetup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteSetup {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_VoteSetup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_VoteSetup,
        };
        unsafe {
            instance.get(CCSUsrMsg_VoteSetup::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VoteSetup {
    fn clear(&mut self) {
        self.potential_issues.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VoteSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoteSetup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SendLastKillerDamageToClient {
    // message fields
    num_hits_given: ::std::option::Option<i32>,
    damage_given: ::std::option::Option<i32>,
    num_hits_taken: ::std::option::Option<i32>,
    damage_taken: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendLastKillerDamageToClient {
    fn default() -> &'a CCSUsrMsg_SendLastKillerDamageToClient {
        <CCSUsrMsg_SendLastKillerDamageToClient as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendLastKillerDamageToClient {
    pub fn new() -> CCSUsrMsg_SendLastKillerDamageToClient {
        ::std::default::Default::default()
    }

    // optional int32 num_hits_given = 1;


    pub fn get_num_hits_given(&self) -> i32 {
        self.num_hits_given.unwrap_or(0)
    }
    pub fn clear_num_hits_given(&mut self) {
        self.num_hits_given = ::std::option::Option::None;
    }

    pub fn has_num_hits_given(&self) -> bool {
        self.num_hits_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits_given(&mut self, v: i32) {
        self.num_hits_given = ::std::option::Option::Some(v);
    }

    // optional int32 damage_given = 2;


    pub fn get_damage_given(&self) -> i32 {
        self.damage_given.unwrap_or(0)
    }
    pub fn clear_damage_given(&mut self) {
        self.damage_given = ::std::option::Option::None;
    }

    pub fn has_damage_given(&self) -> bool {
        self.damage_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_given(&mut self, v: i32) {
        self.damage_given = ::std::option::Option::Some(v);
    }

    // optional int32 num_hits_taken = 3;


    pub fn get_num_hits_taken(&self) -> i32 {
        self.num_hits_taken.unwrap_or(0)
    }
    pub fn clear_num_hits_taken(&mut self) {
        self.num_hits_taken = ::std::option::Option::None;
    }

    pub fn has_num_hits_taken(&self) -> bool {
        self.num_hits_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits_taken(&mut self, v: i32) {
        self.num_hits_taken = ::std::option::Option::Some(v);
    }

    // optional int32 damage_taken = 4;


    pub fn get_damage_taken(&self) -> i32 {
        self.damage_taken.unwrap_or(0)
    }
    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: i32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendLastKillerDamageToClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_hits_given = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.damage_given = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_hits_taken = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.damage_taken = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.num_hits_given {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_given {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_hits_taken {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.num_hits_given {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_given {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.num_hits_taken {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SendLastKillerDamageToClient {
        CCSUsrMsg_SendLastKillerDamageToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_hits_given",
                    |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.num_hits_given },
                    |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.num_hits_given },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "damage_given",
                    |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.damage_given },
                    |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.damage_given },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_hits_taken",
                    |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.num_hits_taken },
                    |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.num_hits_taken },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "damage_taken",
                    |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.damage_taken },
                    |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.damage_taken },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SendLastKillerDamageToClient>(
                    "CCSUsrMsg_SendLastKillerDamageToClient",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SendLastKillerDamageToClient {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SendLastKillerDamageToClient> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SendLastKillerDamageToClient,
        };
        unsafe {
            instance.get(CCSUsrMsg_SendLastKillerDamageToClient::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SendLastKillerDamageToClient {
    fn clear(&mut self) {
        self.num_hits_given = ::std::option::Option::None;
        self.damage_given = ::std::option::Option::None;
        self.num_hits_taken = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SendLastKillerDamageToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendLastKillerDamageToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ServerRankUpdate {
    // message fields
    rank_update: ::protobuf::RepeatedField<CCSUsrMsg_ServerRankUpdate_RankUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ServerRankUpdate {
    fn default() -> &'a CCSUsrMsg_ServerRankUpdate {
        <CCSUsrMsg_ServerRankUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ServerRankUpdate {
    pub fn new() -> CCSUsrMsg_ServerRankUpdate {
        ::std::default::Default::default()
    }

    // repeated .CCSUsrMsg_ServerRankUpdate.RankUpdate rank_update = 1;


    pub fn get_rank_update(&self) -> &[CCSUsrMsg_ServerRankUpdate_RankUpdate] {
        &self.rank_update
    }
    pub fn clear_rank_update(&mut self) {
        self.rank_update.clear();
    }

    // Param is passed by value, moved
    pub fn set_rank_update(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_ServerRankUpdate_RankUpdate>) {
        self.rank_update = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rank_update(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_ServerRankUpdate_RankUpdate> {
        &mut self.rank_update
    }

    // Take field
    pub fn take_rank_update(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_ServerRankUpdate_RankUpdate> {
        ::std::mem::replace(&mut self.rank_update, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ServerRankUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.rank_update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rank_update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rank_update {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rank_update {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ServerRankUpdate {
        CCSUsrMsg_ServerRankUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_ServerRankUpdate_RankUpdate>>(
                    "rank_update",
                    |m: &CCSUsrMsg_ServerRankUpdate| { &m.rank_update },
                    |m: &mut CCSUsrMsg_ServerRankUpdate| { &mut m.rank_update },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ServerRankUpdate>(
                    "CCSUsrMsg_ServerRankUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ServerRankUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ServerRankUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ServerRankUpdate,
        };
        unsafe {
            instance.get(CCSUsrMsg_ServerRankUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ServerRankUpdate {
    fn clear(&mut self) {
        self.rank_update.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ServerRankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ServerRankUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ServerRankUpdate_RankUpdate {
    // message fields
    account_id: ::std::option::Option<i32>,
    rank_old: ::std::option::Option<i32>,
    rank_new: ::std::option::Option<i32>,
    num_wins: ::std::option::Option<i32>,
    rank_change: ::std::option::Option<f32>,
    rank_type_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ServerRankUpdate_RankUpdate {
    fn default() -> &'a CCSUsrMsg_ServerRankUpdate_RankUpdate {
        <CCSUsrMsg_ServerRankUpdate_RankUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ServerRankUpdate_RankUpdate {
    pub fn new() -> CCSUsrMsg_ServerRankUpdate_RankUpdate {
        ::std::default::Default::default()
    }

    // optional int32 account_id = 1;


    pub fn get_account_id(&self) -> i32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: i32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 rank_old = 2;


    pub fn get_rank_old(&self) -> i32 {
        self.rank_old.unwrap_or(0)
    }
    pub fn clear_rank_old(&mut self) {
        self.rank_old = ::std::option::Option::None;
    }

    pub fn has_rank_old(&self) -> bool {
        self.rank_old.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_old(&mut self, v: i32) {
        self.rank_old = ::std::option::Option::Some(v);
    }

    // optional int32 rank_new = 3;


    pub fn get_rank_new(&self) -> i32 {
        self.rank_new.unwrap_or(0)
    }
    pub fn clear_rank_new(&mut self) {
        self.rank_new = ::std::option::Option::None;
    }

    pub fn has_rank_new(&self) -> bool {
        self.rank_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_new(&mut self, v: i32) {
        self.rank_new = ::std::option::Option::Some(v);
    }

    // optional int32 num_wins = 4;


    pub fn get_num_wins(&self) -> i32 {
        self.num_wins.unwrap_or(0)
    }
    pub fn clear_num_wins(&mut self) {
        self.num_wins = ::std::option::Option::None;
    }

    pub fn has_num_wins(&self) -> bool {
        self.num_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_wins(&mut self, v: i32) {
        self.num_wins = ::std::option::Option::Some(v);
    }

    // optional float rank_change = 5;


    pub fn get_rank_change(&self) -> f32 {
        self.rank_change.unwrap_or(0.)
    }
    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: f32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    // optional int32 rank_type_id = 6;


    pub fn get_rank_type_id(&self) -> i32 {
        self.rank_type_id.unwrap_or(0)
    }
    pub fn clear_rank_type_id(&mut self) {
        self.rank_type_id = ::std::option::Option::None;
    }

    pub fn has_rank_type_id(&self) -> bool {
        self.rank_type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_type_id(&mut self, v: i32) {
        self.rank_type_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ServerRankUpdate_RankUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rank_old = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rank_new = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_wins = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rank_change = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rank_type_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_old {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_new {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_wins {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_change {
            my_size += 5;
        }
        if let Some(v) = self.rank_type_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.rank_old {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rank_new {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.num_wins {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.rank_type_id {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ServerRankUpdate_RankUpdate {
        CCSUsrMsg_ServerRankUpdate_RankUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "account_id",
                    |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.account_id },
                    |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.account_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "rank_old",
                    |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.rank_old },
                    |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.rank_old },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "rank_new",
                    |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.rank_new },
                    |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.rank_new },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_wins",
                    |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.num_wins },
                    |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.num_wins },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rank_change",
                    |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.rank_change },
                    |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.rank_change },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "rank_type_id",
                    |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.rank_type_id },
                    |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.rank_type_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ServerRankUpdate_RankUpdate>(
                    "CCSUsrMsg_ServerRankUpdate_RankUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ServerRankUpdate_RankUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ServerRankUpdate_RankUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ServerRankUpdate_RankUpdate,
        };
        unsafe {
            instance.get(CCSUsrMsg_ServerRankUpdate_RankUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ServerRankUpdate_RankUpdate {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rank_old = ::std::option::Option::None;
        self.rank_new = ::std::option::Option::None;
        self.num_wins = ::std::option::Option::None;
        self.rank_change = ::std::option::Option::None;
        self.rank_type_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ServerRankUpdate_RankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ServerRankUpdate_RankUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_XpUpdate {
    // message fields
    data: ::protobuf::SingularPtrField<super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XpUpdate {
    fn default() -> &'a CCSUsrMsg_XpUpdate {
        <CCSUsrMsg_XpUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XpUpdate {
    pub fn new() -> CCSUsrMsg_XpUpdate {
        ::std::default::Default::default()
    }

    // optional .CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded data = 1;


    pub fn get_data(&self) -> &super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        self.data.as_ref().unwrap_or_else(|| super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        self.data.take().unwrap_or_else(|| super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_XpUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_XpUpdate {
        CCSUsrMsg_XpUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>>(
                    "data",
                    |m: &CCSUsrMsg_XpUpdate| { &m.data },
                    |m: &mut CCSUsrMsg_XpUpdate| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_XpUpdate>(
                    "CCSUsrMsg_XpUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_XpUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_XpUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_XpUpdate,
        };
        unsafe {
            instance.get(CCSUsrMsg_XpUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_XpUpdate {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_XpUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_XpUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ItemPickup {
    // message fields
    item: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ItemPickup {
    fn default() -> &'a CCSUsrMsg_ItemPickup {
        <CCSUsrMsg_ItemPickup as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ItemPickup {
    pub fn new() -> CCSUsrMsg_ItemPickup {
        ::std::default::Default::default()
    }

    // optional string item = 1;


    pub fn get_item(&self) -> &str {
        match self.item.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::std::string::String) {
        self.item = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut ::std::string::String {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> ::std::string::String {
        self.item.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ItemPickup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.item.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.item.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ItemPickup {
        CCSUsrMsg_ItemPickup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "item",
                    |m: &CCSUsrMsg_ItemPickup| { &m.item },
                    |m: &mut CCSUsrMsg_ItemPickup| { &mut m.item },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ItemPickup>(
                    "CCSUsrMsg_ItemPickup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ItemPickup {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ItemPickup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ItemPickup,
        };
        unsafe {
            instance.get(CCSUsrMsg_ItemPickup::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ItemPickup {
    fn clear(&mut self) {
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ItemPickup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ItemPickup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ShowMenu {
    // message fields
    bits_valid_slots: ::std::option::Option<i32>,
    display_time: ::std::option::Option<i32>,
    menu_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ShowMenu {
    fn default() -> &'a CCSUsrMsg_ShowMenu {
        <CCSUsrMsg_ShowMenu as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ShowMenu {
    pub fn new() -> CCSUsrMsg_ShowMenu {
        ::std::default::Default::default()
    }

    // optional int32 bits_valid_slots = 1;


    pub fn get_bits_valid_slots(&self) -> i32 {
        self.bits_valid_slots.unwrap_or(0)
    }
    pub fn clear_bits_valid_slots(&mut self) {
        self.bits_valid_slots = ::std::option::Option::None;
    }

    pub fn has_bits_valid_slots(&self) -> bool {
        self.bits_valid_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bits_valid_slots(&mut self, v: i32) {
        self.bits_valid_slots = ::std::option::Option::Some(v);
    }

    // optional int32 display_time = 2;


    pub fn get_display_time(&self) -> i32 {
        self.display_time.unwrap_or(0)
    }
    pub fn clear_display_time(&mut self) {
        self.display_time = ::std::option::Option::None;
    }

    pub fn has_display_time(&self) -> bool {
        self.display_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_time(&mut self, v: i32) {
        self.display_time = ::std::option::Option::Some(v);
    }

    // optional string menu_string = 3;


    pub fn get_menu_string(&self) -> &str {
        match self.menu_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_menu_string(&mut self) {
        self.menu_string.clear();
    }

    pub fn has_menu_string(&self) -> bool {
        self.menu_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_string(&mut self, v: ::std::string::String) {
        self.menu_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu_string(&mut self) -> &mut ::std::string::String {
        if self.menu_string.is_none() {
            self.menu_string.set_default();
        }
        self.menu_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_menu_string(&mut self) -> ::std::string::String {
        self.menu_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ShowMenu {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bits_valid_slots = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.display_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.menu_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bits_valid_slots {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.display_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.menu_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bits_valid_slots {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.display_time {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.menu_string.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ShowMenu {
        CCSUsrMsg_ShowMenu::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "bits_valid_slots",
                    |m: &CCSUsrMsg_ShowMenu| { &m.bits_valid_slots },
                    |m: &mut CCSUsrMsg_ShowMenu| { &mut m.bits_valid_slots },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "display_time",
                    |m: &CCSUsrMsg_ShowMenu| { &m.display_time },
                    |m: &mut CCSUsrMsg_ShowMenu| { &mut m.display_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "menu_string",
                    |m: &CCSUsrMsg_ShowMenu| { &m.menu_string },
                    |m: &mut CCSUsrMsg_ShowMenu| { &mut m.menu_string },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ShowMenu>(
                    "CCSUsrMsg_ShowMenu",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ShowMenu {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ShowMenu> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ShowMenu,
        };
        unsafe {
            instance.get(CCSUsrMsg_ShowMenu::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ShowMenu {
    fn clear(&mut self) {
        self.bits_valid_slots = ::std::option::Option::None;
        self.display_time = ::std::option::Option::None;
        self.menu_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ShowMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ShowMenu {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_BarTime {
    // message fields
    time: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_BarTime {
    fn default() -> &'a CCSUsrMsg_BarTime {
        <CCSUsrMsg_BarTime as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_BarTime {
    pub fn new() -> CCSUsrMsg_BarTime {
        ::std::default::Default::default()
    }

    // optional string time = 1;


    pub fn get_time(&self) -> &str {
        match self.time.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::std::string::String) {
        self.time = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::std::string::String {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::std::string::String {
        self.time.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_BarTime {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_BarTime {
        CCSUsrMsg_BarTime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "time",
                    |m: &CCSUsrMsg_BarTime| { &m.time },
                    |m: &mut CCSUsrMsg_BarTime| { &mut m.time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_BarTime>(
                    "CCSUsrMsg_BarTime",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_BarTime {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_BarTime> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_BarTime,
        };
        unsafe {
            instance.get(CCSUsrMsg_BarTime::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_BarTime {
    fn clear(&mut self) {
        self.time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_BarTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_BarTime {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_AmmoDenied {
    // message fields
    ammoIdx: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AmmoDenied {
    fn default() -> &'a CCSUsrMsg_AmmoDenied {
        <CCSUsrMsg_AmmoDenied as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AmmoDenied {
    pub fn new() -> CCSUsrMsg_AmmoDenied {
        ::std::default::Default::default()
    }

    // optional int32 ammoIdx = 1;


    pub fn get_ammoIdx(&self) -> i32 {
        self.ammoIdx.unwrap_or(0)
    }
    pub fn clear_ammoIdx(&mut self) {
        self.ammoIdx = ::std::option::Option::None;
    }

    pub fn has_ammoIdx(&self) -> bool {
        self.ammoIdx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammoIdx(&mut self, v: i32) {
        self.ammoIdx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_AmmoDenied {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ammoIdx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ammoIdx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ammoIdx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_AmmoDenied {
        CCSUsrMsg_AmmoDenied::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ammoIdx",
                    |m: &CCSUsrMsg_AmmoDenied| { &m.ammoIdx },
                    |m: &mut CCSUsrMsg_AmmoDenied| { &mut m.ammoIdx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_AmmoDenied>(
                    "CCSUsrMsg_AmmoDenied",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_AmmoDenied {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_AmmoDenied> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_AmmoDenied,
        };
        unsafe {
            instance.get(CCSUsrMsg_AmmoDenied::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_AmmoDenied {
    fn clear(&mut self) {
        self.ammoIdx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_AmmoDenied {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_AmmoDenied {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_MarkAchievement {
    // message fields
    achievement: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MarkAchievement {
    fn default() -> &'a CCSUsrMsg_MarkAchievement {
        <CCSUsrMsg_MarkAchievement as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MarkAchievement {
    pub fn new() -> CCSUsrMsg_MarkAchievement {
        ::std::default::Default::default()
    }

    // optional string achievement = 1;


    pub fn get_achievement(&self) -> &str {
        match self.achievement.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_achievement(&mut self) {
        self.achievement.clear();
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: ::std::string::String) {
        self.achievement = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievement(&mut self) -> &mut ::std::string::String {
        if self.achievement.is_none() {
            self.achievement.set_default();
        }
        self.achievement.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievement(&mut self) -> ::std::string::String {
        self.achievement.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_MarkAchievement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.achievement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.achievement.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.achievement.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_MarkAchievement {
        CCSUsrMsg_MarkAchievement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "achievement",
                    |m: &CCSUsrMsg_MarkAchievement| { &m.achievement },
                    |m: &mut CCSUsrMsg_MarkAchievement| { &mut m.achievement },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_MarkAchievement>(
                    "CCSUsrMsg_MarkAchievement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_MarkAchievement {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_MarkAchievement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_MarkAchievement,
        };
        unsafe {
            instance.get(CCSUsrMsg_MarkAchievement::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_MarkAchievement {
    fn clear(&mut self) {
        self.achievement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_MarkAchievement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_MarkAchievement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_MatchStatsUpdate {
    // message fields
    update: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MatchStatsUpdate {
    fn default() -> &'a CCSUsrMsg_MatchStatsUpdate {
        <CCSUsrMsg_MatchStatsUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MatchStatsUpdate {
    pub fn new() -> CCSUsrMsg_MatchStatsUpdate {
        ::std::default::Default::default()
    }

    // optional string update = 1;


    pub fn get_update(&self) -> &str {
        match self.update.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: ::std::string::String) {
        self.update = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut ::std::string::String {
        if self.update.is_none() {
            self.update.set_default();
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> ::std::string::String {
        self.update.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_MatchStatsUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.update.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.update.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_MatchStatsUpdate {
        CCSUsrMsg_MatchStatsUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "update",
                    |m: &CCSUsrMsg_MatchStatsUpdate| { &m.update },
                    |m: &mut CCSUsrMsg_MatchStatsUpdate| { &mut m.update },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_MatchStatsUpdate>(
                    "CCSUsrMsg_MatchStatsUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_MatchStatsUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_MatchStatsUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_MatchStatsUpdate,
        };
        unsafe {
            instance.get(CCSUsrMsg_MatchStatsUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_MatchStatsUpdate {
    fn clear(&mut self) {
        self.update.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_MatchStatsUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_MatchStatsUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ItemDrop {
    // message fields
    itemid: ::std::option::Option<i64>,
    death: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ItemDrop {
    fn default() -> &'a CCSUsrMsg_ItemDrop {
        <CCSUsrMsg_ItemDrop as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ItemDrop {
    pub fn new() -> CCSUsrMsg_ItemDrop {
        ::std::default::Default::default()
    }

    // optional int64 itemid = 1;


    pub fn get_itemid(&self) -> i64 {
        self.itemid.unwrap_or(0)
    }
    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: i64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    // optional bool death = 2;


    pub fn get_death(&self) -> bool {
        self.death.unwrap_or(false)
    }
    pub fn clear_death(&mut self) {
        self.death = ::std::option::Option::None;
    }

    pub fn has_death(&self) -> bool {
        self.death.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death(&mut self, v: bool) {
        self.death = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ItemDrop {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.death = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.death {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.itemid {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.death {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ItemDrop {
        CCSUsrMsg_ItemDrop::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "itemid",
                    |m: &CCSUsrMsg_ItemDrop| { &m.itemid },
                    |m: &mut CCSUsrMsg_ItemDrop| { &mut m.itemid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "death",
                    |m: &CCSUsrMsg_ItemDrop| { &m.death },
                    |m: &mut CCSUsrMsg_ItemDrop| { &mut m.death },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ItemDrop>(
                    "CCSUsrMsg_ItemDrop",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ItemDrop {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ItemDrop> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ItemDrop,
        };
        unsafe {
            instance.get(CCSUsrMsg_ItemDrop::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ItemDrop {
    fn clear(&mut self) {
        self.itemid = ::std::option::Option::None;
        self.death = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ItemDrop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ItemDrop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_GlowPropTurnOff {
    // message fields
    entidx: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_GlowPropTurnOff {
    fn default() -> &'a CCSUsrMsg_GlowPropTurnOff {
        <CCSUsrMsg_GlowPropTurnOff as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_GlowPropTurnOff {
    pub fn new() -> CCSUsrMsg_GlowPropTurnOff {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_GlowPropTurnOff {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_GlowPropTurnOff {
        CCSUsrMsg_GlowPropTurnOff::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entidx",
                    |m: &CCSUsrMsg_GlowPropTurnOff| { &m.entidx },
                    |m: &mut CCSUsrMsg_GlowPropTurnOff| { &mut m.entidx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_GlowPropTurnOff>(
                    "CCSUsrMsg_GlowPropTurnOff",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_GlowPropTurnOff {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_GlowPropTurnOff> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_GlowPropTurnOff,
        };
        unsafe {
            instance.get(CCSUsrMsg_GlowPropTurnOff::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_GlowPropTurnOff {
    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_GlowPropTurnOff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_GlowPropTurnOff {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RoundBackupFilenames {
    // message fields
    count: ::std::option::Option<i32>,
    index: ::std::option::Option<i32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    nicename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundBackupFilenames {
    fn default() -> &'a CCSUsrMsg_RoundBackupFilenames {
        <CCSUsrMsg_RoundBackupFilenames as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundBackupFilenames {
    pub fn new() -> CCSUsrMsg_RoundBackupFilenames {
        ::std::default::Default::default()
    }

    // optional int32 count = 1;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 index = 2;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string filename = 3;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nicename = 4;


    pub fn get_nicename(&self) -> &str {
        match self.nicename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nicename(&mut self) {
        self.nicename.clear();
    }

    pub fn has_nicename(&self) -> bool {
        self.nicename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nicename(&mut self, v: ::std::string::String) {
        self.nicename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nicename(&mut self) -> &mut ::std::string::String {
        if self.nicename.is_none() {
            self.nicename.set_default();
        }
        self.nicename.as_mut().unwrap()
    }

    // Take field
    pub fn take_nicename(&mut self) -> ::std::string::String {
        self.nicename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_RoundBackupFilenames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nicename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.nicename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.nicename.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RoundBackupFilenames {
        CCSUsrMsg_RoundBackupFilenames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "count",
                    |m: &CCSUsrMsg_RoundBackupFilenames| { &m.count },
                    |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    |m: &CCSUsrMsg_RoundBackupFilenames| { &m.index },
                    |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.index },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    |m: &CCSUsrMsg_RoundBackupFilenames| { &m.filename },
                    |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.filename },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nicename",
                    |m: &CCSUsrMsg_RoundBackupFilenames| { &m.nicename },
                    |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.nicename },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_RoundBackupFilenames>(
                    "CCSUsrMsg_RoundBackupFilenames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundBackupFilenames {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_RoundBackupFilenames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_RoundBackupFilenames,
        };
        unsafe {
            instance.get(CCSUsrMsg_RoundBackupFilenames::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RoundBackupFilenames {
    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.filename.clear();
        self.nicename.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RoundBackupFilenames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RoundBackupFilenames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SSUI {
    // message fields
    show: ::std::option::Option<bool>,
    start_time: ::std::option::Option<f32>,
    end_time: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SSUI {
    fn default() -> &'a CCSUsrMsg_SSUI {
        <CCSUsrMsg_SSUI as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SSUI {
    pub fn new() -> CCSUsrMsg_SSUI {
        ::std::default::Default::default()
    }

    // optional bool show = 1;


    pub fn get_show(&self) -> bool {
        self.show.unwrap_or(false)
    }
    pub fn clear_show(&mut self) {
        self.show = ::std::option::Option::None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = ::std::option::Option::Some(v);
    }

    // optional float start_time = 2;


    pub fn get_start_time(&self) -> f32 {
        self.start_time.unwrap_or(0.)
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional float end_time = 3;


    pub fn get_end_time(&self) -> f32 {
        self.end_time.unwrap_or(0.)
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: f32) {
        self.end_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SSUI {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.end_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.show {
            my_size += 2;
        }
        if let Some(v) = self.start_time {
            my_size += 5;
        }
        if let Some(v) = self.end_time {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.show {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SSUI {
        CCSUsrMsg_SSUI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show",
                    |m: &CCSUsrMsg_SSUI| { &m.show },
                    |m: &mut CCSUsrMsg_SSUI| { &mut m.show },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "start_time",
                    |m: &CCSUsrMsg_SSUI| { &m.start_time },
                    |m: &mut CCSUsrMsg_SSUI| { &mut m.start_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "end_time",
                    |m: &CCSUsrMsg_SSUI| { &m.end_time },
                    |m: &mut CCSUsrMsg_SSUI| { &mut m.end_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SSUI>(
                    "CCSUsrMsg_SSUI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SSUI {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SSUI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SSUI,
        };
        unsafe {
            instance.get(CCSUsrMsg_SSUI::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SSUI {
    fn clear(&mut self) {
        self.show = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SSUI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SSUI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SurvivalStats {
    // message fields
    xuid: ::std::option::Option<u64>,
    facts: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Fact>,
    users: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Placement>,
    damages: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Damage>,
    ticknumber: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SurvivalStats {
    fn default() -> &'a CCSUsrMsg_SurvivalStats {
        <CCSUsrMsg_SurvivalStats as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SurvivalStats {
    pub fn new() -> CCSUsrMsg_SurvivalStats {
        ::std::default::Default::default()
    }

    // optional uint64 xuid = 1;


    pub fn get_xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }
    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // repeated .CCSUsrMsg_SurvivalStats.Fact facts = 2;


    pub fn get_facts(&self) -> &[CCSUsrMsg_SurvivalStats_Fact] {
        &self.facts
    }
    pub fn clear_facts(&mut self) {
        self.facts.clear();
    }

    // Param is passed by value, moved
    pub fn set_facts(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Fact>) {
        self.facts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_facts(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Fact> {
        &mut self.facts
    }

    // Take field
    pub fn take_facts(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Fact> {
        ::std::mem::replace(&mut self.facts, ::protobuf::RepeatedField::new())
    }

    // repeated .CCSUsrMsg_SurvivalStats.Placement users = 3;


    pub fn get_users(&self) -> &[CCSUsrMsg_SurvivalStats_Placement] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Placement>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Placement> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Placement> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }

    // repeated .CCSUsrMsg_SurvivalStats.Damage damages = 5;


    pub fn get_damages(&self) -> &[CCSUsrMsg_SurvivalStats_Damage] {
        &self.damages
    }
    pub fn clear_damages(&mut self) {
        self.damages.clear();
    }

    // Param is passed by value, moved
    pub fn set_damages(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Damage>) {
        self.damages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_damages(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Damage> {
        &mut self.damages
    }

    // Take field
    pub fn take_damages(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Damage> {
        ::std::mem::replace(&mut self.damages, ::protobuf::RepeatedField::new())
    }

    // optional int32 ticknumber = 4;


    pub fn get_ticknumber(&self) -> i32 {
        self.ticknumber.unwrap_or(0)
    }
    pub fn clear_ticknumber(&mut self) {
        self.ticknumber = ::std::option::Option::None;
    }

    pub fn has_ticknumber(&self) -> bool {
        self.ticknumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticknumber(&mut self, v: i32) {
        self.ticknumber = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SurvivalStats {
    fn is_initialized(&self) -> bool {
        for v in &self.facts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.damages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.xuid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.facts)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.damages)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ticknumber = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.xuid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.facts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.damages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.ticknumber {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.xuid {
            os.write_uint64(1, v)?;
        }
        for v in &self.facts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.users {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.damages {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.ticknumber {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SurvivalStats {
        CCSUsrMsg_SurvivalStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "xuid",
                    |m: &CCSUsrMsg_SurvivalStats| { &m.xuid },
                    |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.xuid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_SurvivalStats_Fact>>(
                    "facts",
                    |m: &CCSUsrMsg_SurvivalStats| { &m.facts },
                    |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.facts },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_SurvivalStats_Placement>>(
                    "users",
                    |m: &CCSUsrMsg_SurvivalStats| { &m.users },
                    |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.users },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_SurvivalStats_Damage>>(
                    "damages",
                    |m: &CCSUsrMsg_SurvivalStats| { &m.damages },
                    |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.damages },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ticknumber",
                    |m: &CCSUsrMsg_SurvivalStats| { &m.ticknumber },
                    |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.ticknumber },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SurvivalStats>(
                    "CCSUsrMsg_SurvivalStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SurvivalStats {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SurvivalStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SurvivalStats,
        };
        unsafe {
            instance.get(CCSUsrMsg_SurvivalStats::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SurvivalStats {
    fn clear(&mut self) {
        self.xuid = ::std::option::Option::None;
        self.facts.clear();
        self.users.clear();
        self.damages.clear();
        self.ticknumber = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SurvivalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SurvivalStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SurvivalStats_Fact {
    // message fields
    field_type: ::std::option::Option<i32>,
    display: ::std::option::Option<i32>,
    value: ::std::option::Option<i32>,
    interestingness: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SurvivalStats_Fact {
    fn default() -> &'a CCSUsrMsg_SurvivalStats_Fact {
        <CCSUsrMsg_SurvivalStats_Fact as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SurvivalStats_Fact {
    pub fn new() -> CCSUsrMsg_SurvivalStats_Fact {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional int32 display = 2;


    pub fn get_display(&self) -> i32 {
        self.display.unwrap_or(0)
    }
    pub fn clear_display(&mut self) {
        self.display = ::std::option::Option::None;
    }

    pub fn has_display(&self) -> bool {
        self.display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display(&mut self, v: i32) {
        self.display = ::std::option::Option::Some(v);
    }

    // optional int32 value = 3;


    pub fn get_value(&self) -> i32 {
        self.value.unwrap_or(0)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional float interestingness = 4;


    pub fn get_interestingness(&self) -> f32 {
        self.interestingness.unwrap_or(0.)
    }
    pub fn clear_interestingness(&mut self) {
        self.interestingness = ::std::option::Option::None;
    }

    pub fn has_interestingness(&self) -> bool {
        self.interestingness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interestingness(&mut self, v: f32) {
        self.interestingness = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SurvivalStats_Fact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.display = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.interestingness = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.display {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.interestingness {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.display {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.interestingness {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SurvivalStats_Fact {
        CCSUsrMsg_SurvivalStats_Fact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type",
                    |m: &CCSUsrMsg_SurvivalStats_Fact| { &m.field_type },
                    |m: &mut CCSUsrMsg_SurvivalStats_Fact| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "display",
                    |m: &CCSUsrMsg_SurvivalStats_Fact| { &m.display },
                    |m: &mut CCSUsrMsg_SurvivalStats_Fact| { &mut m.display },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &CCSUsrMsg_SurvivalStats_Fact| { &m.value },
                    |m: &mut CCSUsrMsg_SurvivalStats_Fact| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "interestingness",
                    |m: &CCSUsrMsg_SurvivalStats_Fact| { &m.interestingness },
                    |m: &mut CCSUsrMsg_SurvivalStats_Fact| { &mut m.interestingness },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SurvivalStats_Fact>(
                    "CCSUsrMsg_SurvivalStats_Fact",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SurvivalStats_Fact {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SurvivalStats_Fact> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SurvivalStats_Fact,
        };
        unsafe {
            instance.get(CCSUsrMsg_SurvivalStats_Fact::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SurvivalStats_Fact {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.display = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.interestingness = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SurvivalStats_Fact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SurvivalStats_Fact {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SurvivalStats_Placement {
    // message fields
    xuid: ::std::option::Option<u64>,
    teamnumber: ::std::option::Option<i32>,
    placement: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SurvivalStats_Placement {
    fn default() -> &'a CCSUsrMsg_SurvivalStats_Placement {
        <CCSUsrMsg_SurvivalStats_Placement as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SurvivalStats_Placement {
    pub fn new() -> CCSUsrMsg_SurvivalStats_Placement {
        ::std::default::Default::default()
    }

    // optional uint64 xuid = 1;


    pub fn get_xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }
    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 teamnumber = 2;


    pub fn get_teamnumber(&self) -> i32 {
        self.teamnumber.unwrap_or(0)
    }
    pub fn clear_teamnumber(&mut self) {
        self.teamnumber = ::std::option::Option::None;
    }

    pub fn has_teamnumber(&self) -> bool {
        self.teamnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teamnumber(&mut self, v: i32) {
        self.teamnumber = ::std::option::Option::Some(v);
    }

    // optional int32 placement = 3;


    pub fn get_placement(&self) -> i32 {
        self.placement.unwrap_or(0)
    }
    pub fn clear_placement(&mut self) {
        self.placement = ::std::option::Option::None;
    }

    pub fn has_placement(&self) -> bool {
        self.placement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placement(&mut self, v: i32) {
        self.placement = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SurvivalStats_Placement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.xuid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.teamnumber = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.placement = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.xuid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.teamnumber {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.placement {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.xuid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.teamnumber {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.placement {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SurvivalStats_Placement {
        CCSUsrMsg_SurvivalStats_Placement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "xuid",
                    |m: &CCSUsrMsg_SurvivalStats_Placement| { &m.xuid },
                    |m: &mut CCSUsrMsg_SurvivalStats_Placement| { &mut m.xuid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "teamnumber",
                    |m: &CCSUsrMsg_SurvivalStats_Placement| { &m.teamnumber },
                    |m: &mut CCSUsrMsg_SurvivalStats_Placement| { &mut m.teamnumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "placement",
                    |m: &CCSUsrMsg_SurvivalStats_Placement| { &m.placement },
                    |m: &mut CCSUsrMsg_SurvivalStats_Placement| { &mut m.placement },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SurvivalStats_Placement>(
                    "CCSUsrMsg_SurvivalStats_Placement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SurvivalStats_Placement {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SurvivalStats_Placement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SurvivalStats_Placement,
        };
        unsafe {
            instance.get(CCSUsrMsg_SurvivalStats_Placement::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SurvivalStats_Placement {
    fn clear(&mut self) {
        self.xuid = ::std::option::Option::None;
        self.teamnumber = ::std::option::Option::None;
        self.placement = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SurvivalStats_Placement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SurvivalStats_Placement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SurvivalStats_Damage {
    // message fields
    xuid: ::std::option::Option<u64>,
    to: ::std::option::Option<i32>,
    to_hits: ::std::option::Option<i32>,
    from: ::std::option::Option<i32>,
    from_hits: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SurvivalStats_Damage {
    fn default() -> &'a CCSUsrMsg_SurvivalStats_Damage {
        <CCSUsrMsg_SurvivalStats_Damage as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SurvivalStats_Damage {
    pub fn new() -> CCSUsrMsg_SurvivalStats_Damage {
        ::std::default::Default::default()
    }

    // optional uint64 xuid = 1;


    pub fn get_xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }
    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 to = 2;


    pub fn get_to(&self) -> i32 {
        self.to.unwrap_or(0)
    }
    pub fn clear_to(&mut self) {
        self.to = ::std::option::Option::None;
    }

    pub fn has_to(&self) -> bool {
        self.to.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: i32) {
        self.to = ::std::option::Option::Some(v);
    }

    // optional int32 to_hits = 3;


    pub fn get_to_hits(&self) -> i32 {
        self.to_hits.unwrap_or(0)
    }
    pub fn clear_to_hits(&mut self) {
        self.to_hits = ::std::option::Option::None;
    }

    pub fn has_to_hits(&self) -> bool {
        self.to_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_hits(&mut self, v: i32) {
        self.to_hits = ::std::option::Option::Some(v);
    }

    // optional int32 from = 4;


    pub fn get_from(&self) -> i32 {
        self.from.unwrap_or(0)
    }
    pub fn clear_from(&mut self) {
        self.from = ::std::option::Option::None;
    }

    pub fn has_from(&self) -> bool {
        self.from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: i32) {
        self.from = ::std::option::Option::Some(v);
    }

    // optional int32 from_hits = 5;


    pub fn get_from_hits(&self) -> i32 {
        self.from_hits.unwrap_or(0)
    }
    pub fn clear_from_hits(&mut self) {
        self.from_hits = ::std::option::Option::None;
    }

    pub fn has_from_hits(&self) -> bool {
        self.from_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_hits(&mut self, v: i32) {
        self.from_hits = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SurvivalStats_Damage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.xuid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.to = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.to_hits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.from = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.from_hits = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.xuid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.to {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.to_hits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_hits {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.xuid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.to {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.to_hits {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.from {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.from_hits {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SurvivalStats_Damage {
        CCSUsrMsg_SurvivalStats_Damage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "xuid",
                    |m: &CCSUsrMsg_SurvivalStats_Damage| { &m.xuid },
                    |m: &mut CCSUsrMsg_SurvivalStats_Damage| { &mut m.xuid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "to",
                    |m: &CCSUsrMsg_SurvivalStats_Damage| { &m.to },
                    |m: &mut CCSUsrMsg_SurvivalStats_Damage| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "to_hits",
                    |m: &CCSUsrMsg_SurvivalStats_Damage| { &m.to_hits },
                    |m: &mut CCSUsrMsg_SurvivalStats_Damage| { &mut m.to_hits },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "from",
                    |m: &CCSUsrMsg_SurvivalStats_Damage| { &m.from },
                    |m: &mut CCSUsrMsg_SurvivalStats_Damage| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "from_hits",
                    |m: &CCSUsrMsg_SurvivalStats_Damage| { &m.from_hits },
                    |m: &mut CCSUsrMsg_SurvivalStats_Damage| { &mut m.from_hits },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_SurvivalStats_Damage>(
                    "CCSUsrMsg_SurvivalStats_Damage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_SurvivalStats_Damage {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_SurvivalStats_Damage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_SurvivalStats_Damage,
        };
        unsafe {
            instance.get(CCSUsrMsg_SurvivalStats_Damage::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SurvivalStats_Damage {
    fn clear(&mut self) {
        self.xuid = ::std::option::Option::None;
        self.to = ::std::option::Option::None;
        self.to_hits = ::std::option::Option::None;
        self.from = ::std::option::Option::None;
        self.from_hits = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SurvivalStats_Damage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SurvivalStats_Damage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ResetHud {
    // message fields
    reset: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ResetHud {
    fn default() -> &'a CCSUsrMsg_ResetHud {
        <CCSUsrMsg_ResetHud as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ResetHud {
    pub fn new() -> CCSUsrMsg_ResetHud {
        ::std::default::Default::default()
    }

    // optional bool reset = 1;


    pub fn get_reset(&self) -> bool {
        self.reset.unwrap_or(false)
    }
    pub fn clear_reset(&mut self) {
        self.reset = ::std::option::Option::None;
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: bool) {
        self.reset = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ResetHud {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reset = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reset {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reset {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ResetHud {
        CCSUsrMsg_ResetHud::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reset",
                    |m: &CCSUsrMsg_ResetHud| { &m.reset },
                    |m: &mut CCSUsrMsg_ResetHud| { &mut m.reset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ResetHud>(
                    "CCSUsrMsg_ResetHud",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ResetHud {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ResetHud> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ResetHud,
        };
        unsafe {
            instance.get(CCSUsrMsg_ResetHud::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ResetHud {
    fn clear(&mut self) {
        self.reset = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ResetHud {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ResetHud {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_GameTitle {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_GameTitle {
    fn default() -> &'a CCSUsrMsg_GameTitle {
        <CCSUsrMsg_GameTitle as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_GameTitle {
    pub fn new() -> CCSUsrMsg_GameTitle {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_GameTitle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_GameTitle {
        CCSUsrMsg_GameTitle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy",
                    |m: &CCSUsrMsg_GameTitle| { &m.dummy },
                    |m: &mut CCSUsrMsg_GameTitle| { &mut m.dummy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_GameTitle>(
                    "CCSUsrMsg_GameTitle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_GameTitle {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_GameTitle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_GameTitle,
        };
        unsafe {
            instance.get(CCSUsrMsg_GameTitle::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_GameTitle {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_GameTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_GameTitle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RequestState {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RequestState {
    fn default() -> &'a CCSUsrMsg_RequestState {
        <CCSUsrMsg_RequestState as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RequestState {
    pub fn new() -> CCSUsrMsg_RequestState {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_RequestState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RequestState {
        CCSUsrMsg_RequestState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy",
                    |m: &CCSUsrMsg_RequestState| { &m.dummy },
                    |m: &mut CCSUsrMsg_RequestState| { &mut m.dummy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_RequestState>(
                    "CCSUsrMsg_RequestState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_RequestState {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_RequestState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_RequestState,
        };
        unsafe {
            instance.get(CCSUsrMsg_RequestState::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RequestState {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RequestState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_StopSpectatorMode {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_StopSpectatorMode {
    fn default() -> &'a CCSUsrMsg_StopSpectatorMode {
        <CCSUsrMsg_StopSpectatorMode as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_StopSpectatorMode {
    pub fn new() -> CCSUsrMsg_StopSpectatorMode {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_StopSpectatorMode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_StopSpectatorMode {
        CCSUsrMsg_StopSpectatorMode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy",
                    |m: &CCSUsrMsg_StopSpectatorMode| { &m.dummy },
                    |m: &mut CCSUsrMsg_StopSpectatorMode| { &mut m.dummy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_StopSpectatorMode>(
                    "CCSUsrMsg_StopSpectatorMode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_StopSpectatorMode {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_StopSpectatorMode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_StopSpectatorMode,
        };
        unsafe {
            instance.get(CCSUsrMsg_StopSpectatorMode::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_StopSpectatorMode {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_StopSpectatorMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_StopSpectatorMode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_DisconnectToLobby {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DisconnectToLobby {
    fn default() -> &'a CCSUsrMsg_DisconnectToLobby {
        <CCSUsrMsg_DisconnectToLobby as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DisconnectToLobby {
    pub fn new() -> CCSUsrMsg_DisconnectToLobby {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_DisconnectToLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_DisconnectToLobby {
        CCSUsrMsg_DisconnectToLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy",
                    |m: &CCSUsrMsg_DisconnectToLobby| { &m.dummy },
                    |m: &mut CCSUsrMsg_DisconnectToLobby| { &mut m.dummy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_DisconnectToLobby>(
                    "CCSUsrMsg_DisconnectToLobby",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_DisconnectToLobby {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_DisconnectToLobby> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_DisconnectToLobby,
        };
        unsafe {
            instance.get(CCSUsrMsg_DisconnectToLobby::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_DisconnectToLobby {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_DisconnectToLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DisconnectToLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_WarmupHasEnded {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_WarmupHasEnded {
    fn default() -> &'a CCSUsrMsg_WarmupHasEnded {
        <CCSUsrMsg_WarmupHasEnded as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_WarmupHasEnded {
    pub fn new() -> CCSUsrMsg_WarmupHasEnded {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_WarmupHasEnded {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_WarmupHasEnded {
        CCSUsrMsg_WarmupHasEnded::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy",
                    |m: &CCSUsrMsg_WarmupHasEnded| { &m.dummy },
                    |m: &mut CCSUsrMsg_WarmupHasEnded| { &mut m.dummy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_WarmupHasEnded>(
                    "CCSUsrMsg_WarmupHasEnded",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_WarmupHasEnded {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_WarmupHasEnded> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_WarmupHasEnded,
        };
        unsafe {
            instance.get(CCSUsrMsg_WarmupHasEnded::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_WarmupHasEnded {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_WarmupHasEnded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_WarmupHasEnded {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ClientInfo {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ClientInfo {
    fn default() -> &'a CCSUsrMsg_ClientInfo {
        <CCSUsrMsg_ClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ClientInfo {
    pub fn new() -> CCSUsrMsg_ClientInfo {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ClientInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ClientInfo {
        CCSUsrMsg_ClientInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dummy",
                    |m: &CCSUsrMsg_ClientInfo| { &m.dummy },
                    |m: &mut CCSUsrMsg_ClientInfo| { &mut m.dummy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ClientInfo>(
                    "CCSUsrMsg_ClientInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ClientInfo {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ClientInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ClientInfo,
        };
        unsafe {
            instance.get(CCSUsrMsg_ClientInfo::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ClientInfo {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ClientInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ServerRankRevealAll {
    // message fields
    seconds_till_shutdown: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ServerRankRevealAll {
    fn default() -> &'a CCSUsrMsg_ServerRankRevealAll {
        <CCSUsrMsg_ServerRankRevealAll as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ServerRankRevealAll {
    pub fn new() -> CCSUsrMsg_ServerRankRevealAll {
        ::std::default::Default::default()
    }

    // optional int32 seconds_till_shutdown = 1;


    pub fn get_seconds_till_shutdown(&self) -> i32 {
        self.seconds_till_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_till_shutdown(&mut self) {
        self.seconds_till_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_till_shutdown(&self) -> bool {
        self.seconds_till_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_till_shutdown(&mut self, v: i32) {
        self.seconds_till_shutdown = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ServerRankRevealAll {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seconds_till_shutdown = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seconds_till_shutdown {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seconds_till_shutdown {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ServerRankRevealAll {
        CCSUsrMsg_ServerRankRevealAll::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "seconds_till_shutdown",
                    |m: &CCSUsrMsg_ServerRankRevealAll| { &m.seconds_till_shutdown },
                    |m: &mut CCSUsrMsg_ServerRankRevealAll| { &mut m.seconds_till_shutdown },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCSUsrMsg_ServerRankRevealAll>(
                    "CCSUsrMsg_ServerRankRevealAll",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCSUsrMsg_ServerRankRevealAll {
        static mut instance: ::protobuf::lazy::Lazy<CCSUsrMsg_ServerRankRevealAll> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCSUsrMsg_ServerRankRevealAll,
        };
        unsafe {
            instance.get(CCSUsrMsg_ServerRankRevealAll::new)
        }
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ServerRankRevealAll {
    fn clear(&mut self) {
        self.seconds_till_shutdown = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ServerRankRevealAll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ServerRankRevealAll {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ECstrike15UserMessages {
    CS_UM_VGUIMenu = 1,
    CS_UM_Geiger = 2,
    CS_UM_Train = 3,
    CS_UM_HudText = 4,
    CS_UM_SayText = 5,
    CS_UM_SayText2 = 6,
    CS_UM_TextMsg = 7,
    CS_UM_HudMsg = 8,
    CS_UM_ResetHud = 9,
    CS_UM_GameTitle = 10,
    CS_UM_Shake = 12,
    CS_UM_Fade = 13,
    CS_UM_Rumble = 14,
    CS_UM_CloseCaption = 15,
    CS_UM_CloseCaptionDirect = 16,
    CS_UM_SendAudio = 17,
    CS_UM_RawAudio = 18,
    CS_UM_VoiceMask = 19,
    CS_UM_RequestState = 20,
    CS_UM_Damage = 21,
    CS_UM_RadioText = 22,
    CS_UM_HintText = 23,
    CS_UM_KeyHintText = 24,
    CS_UM_ProcessSpottedEntityUpdate = 25,
    CS_UM_ReloadEffect = 26,
    CS_UM_AdjustMoney = 27,
    CS_UM_UpdateTeamMoney = 28,
    CS_UM_StopSpectatorMode = 29,
    CS_UM_KillCam = 30,
    CS_UM_DesiredTimescale = 31,
    CS_UM_CurrentTimescale = 32,
    CS_UM_AchievementEvent = 33,
    CS_UM_MatchEndConditions = 34,
    CS_UM_DisconnectToLobby = 35,
    CS_UM_PlayerStatsUpdate = 36,
    CS_UM_DisplayInventory = 37,
    CS_UM_WarmupHasEnded = 38,
    CS_UM_ClientInfo = 39,
    CS_UM_XRankGet = 40,
    CS_UM_XRankUpd = 41,
    CS_UM_CallVoteFailed = 45,
    CS_UM_VoteStart = 46,
    CS_UM_VotePass = 47,
    CS_UM_VoteFailed = 48,
    CS_UM_VoteSetup = 49,
    CS_UM_ServerRankRevealAll = 50,
    CS_UM_SendLastKillerDamageToClient = 51,
    CS_UM_ServerRankUpdate = 52,
    CS_UM_ItemPickup = 53,
    CS_UM_ShowMenu = 54,
    CS_UM_BarTime = 55,
    CS_UM_AmmoDenied = 56,
    CS_UM_MarkAchievement = 57,
    CS_UM_MatchStatsUpdate = 58,
    CS_UM_ItemDrop = 59,
    CS_UM_GlowPropTurnOff = 60,
    CS_UM_SendPlayerItemDrops = 61,
    CS_UM_RoundBackupFilenames = 62,
    CS_UM_SendPlayerItemFound = 63,
    CS_UM_ReportHit = 64,
    CS_UM_XpUpdate = 65,
    CS_UM_QuestProgress = 66,
    CS_UM_ScoreLeaderboardData = 67,
    CS_UM_PlayerDecalDigitalSignature = 68,
    CS_UM_WeaponSound = 69,
    CS_UM_UpdateScreenHealthBar = 70,
    CS_UM_EntityOutlineHighlight = 71,
    CS_UM_SSUI = 72,
    CS_UM_SurvivalStats = 73,
    CS_UM_DisconnectToLobby2 = 74,
}

impl ::protobuf::ProtobufEnum for ECstrike15UserMessages {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECstrike15UserMessages> {
        match value {
            1 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VGUIMenu),
            2 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Geiger),
            3 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Train),
            4 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudText),
            5 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText),
            6 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText2),
            7 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_TextMsg),
            8 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudMsg),
            9 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ResetHud),
            10 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GameTitle),
            12 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Shake),
            13 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Fade),
            14 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Rumble),
            15 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaption),
            16 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaptionDirect),
            17 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendAudio),
            18 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RawAudio),
            19 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoiceMask),
            20 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RequestState),
            21 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Damage),
            22 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RadioText),
            23 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HintText),
            24 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KeyHintText),
            25 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate),
            26 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReloadEffect),
            27 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AdjustMoney),
            28 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateTeamMoney),
            29 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_StopSpectatorMode),
            30 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KillCam),
            31 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DesiredTimescale),
            32 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentTimescale),
            33 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AchievementEvent),
            34 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchEndConditions),
            35 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby),
            36 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerStatsUpdate),
            37 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisplayInventory),
            38 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WarmupHasEnded),
            39 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ClientInfo),
            40 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankGet),
            41 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankUpd),
            45 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CallVoteFailed),
            46 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteStart),
            47 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VotePass),
            48 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteFailed),
            49 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteSetup),
            50 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankRevealAll),
            51 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient),
            52 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankUpdate),
            53 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemPickup),
            54 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ShowMenu),
            55 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_BarTime),
            56 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AmmoDenied),
            57 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MarkAchievement),
            58 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchStatsUpdate),
            59 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemDrop),
            60 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GlowPropTurnOff),
            61 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemDrops),
            62 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundBackupFilenames),
            63 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemFound),
            64 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReportHit),
            65 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XpUpdate),
            66 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_QuestProgress),
            67 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ScoreLeaderboardData),
            68 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature),
            69 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WeaponSound),
            70 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar),
            71 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EntityOutlineHighlight),
            72 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SSUI),
            73 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SurvivalStats),
            74 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ECstrike15UserMessages] = &[
            ECstrike15UserMessages::CS_UM_VGUIMenu,
            ECstrike15UserMessages::CS_UM_Geiger,
            ECstrike15UserMessages::CS_UM_Train,
            ECstrike15UserMessages::CS_UM_HudText,
            ECstrike15UserMessages::CS_UM_SayText,
            ECstrike15UserMessages::CS_UM_SayText2,
            ECstrike15UserMessages::CS_UM_TextMsg,
            ECstrike15UserMessages::CS_UM_HudMsg,
            ECstrike15UserMessages::CS_UM_ResetHud,
            ECstrike15UserMessages::CS_UM_GameTitle,
            ECstrike15UserMessages::CS_UM_Shake,
            ECstrike15UserMessages::CS_UM_Fade,
            ECstrike15UserMessages::CS_UM_Rumble,
            ECstrike15UserMessages::CS_UM_CloseCaption,
            ECstrike15UserMessages::CS_UM_CloseCaptionDirect,
            ECstrike15UserMessages::CS_UM_SendAudio,
            ECstrike15UserMessages::CS_UM_RawAudio,
            ECstrike15UserMessages::CS_UM_VoiceMask,
            ECstrike15UserMessages::CS_UM_RequestState,
            ECstrike15UserMessages::CS_UM_Damage,
            ECstrike15UserMessages::CS_UM_RadioText,
            ECstrike15UserMessages::CS_UM_HintText,
            ECstrike15UserMessages::CS_UM_KeyHintText,
            ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate,
            ECstrike15UserMessages::CS_UM_ReloadEffect,
            ECstrike15UserMessages::CS_UM_AdjustMoney,
            ECstrike15UserMessages::CS_UM_UpdateTeamMoney,
            ECstrike15UserMessages::CS_UM_StopSpectatorMode,
            ECstrike15UserMessages::CS_UM_KillCam,
            ECstrike15UserMessages::CS_UM_DesiredTimescale,
            ECstrike15UserMessages::CS_UM_CurrentTimescale,
            ECstrike15UserMessages::CS_UM_AchievementEvent,
            ECstrike15UserMessages::CS_UM_MatchEndConditions,
            ECstrike15UserMessages::CS_UM_DisconnectToLobby,
            ECstrike15UserMessages::CS_UM_PlayerStatsUpdate,
            ECstrike15UserMessages::CS_UM_DisplayInventory,
            ECstrike15UserMessages::CS_UM_WarmupHasEnded,
            ECstrike15UserMessages::CS_UM_ClientInfo,
            ECstrike15UserMessages::CS_UM_XRankGet,
            ECstrike15UserMessages::CS_UM_XRankUpd,
            ECstrike15UserMessages::CS_UM_CallVoteFailed,
            ECstrike15UserMessages::CS_UM_VoteStart,
            ECstrike15UserMessages::CS_UM_VotePass,
            ECstrike15UserMessages::CS_UM_VoteFailed,
            ECstrike15UserMessages::CS_UM_VoteSetup,
            ECstrike15UserMessages::CS_UM_ServerRankRevealAll,
            ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient,
            ECstrike15UserMessages::CS_UM_ServerRankUpdate,
            ECstrike15UserMessages::CS_UM_ItemPickup,
            ECstrike15UserMessages::CS_UM_ShowMenu,
            ECstrike15UserMessages::CS_UM_BarTime,
            ECstrike15UserMessages::CS_UM_AmmoDenied,
            ECstrike15UserMessages::CS_UM_MarkAchievement,
            ECstrike15UserMessages::CS_UM_MatchStatsUpdate,
            ECstrike15UserMessages::CS_UM_ItemDrop,
            ECstrike15UserMessages::CS_UM_GlowPropTurnOff,
            ECstrike15UserMessages::CS_UM_SendPlayerItemDrops,
            ECstrike15UserMessages::CS_UM_RoundBackupFilenames,
            ECstrike15UserMessages::CS_UM_SendPlayerItemFound,
            ECstrike15UserMessages::CS_UM_ReportHit,
            ECstrike15UserMessages::CS_UM_XpUpdate,
            ECstrike15UserMessages::CS_UM_QuestProgress,
            ECstrike15UserMessages::CS_UM_ScoreLeaderboardData,
            ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature,
            ECstrike15UserMessages::CS_UM_WeaponSound,
            ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar,
            ECstrike15UserMessages::CS_UM_EntityOutlineHighlight,
            ECstrike15UserMessages::CS_UM_SSUI,
            ECstrike15UserMessages::CS_UM_SurvivalStats,
            ECstrike15UserMessages::CS_UM_DisconnectToLobby2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ECstrike15UserMessages", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ECstrike15UserMessages {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ECstrike15UserMessages {
    fn default() -> Self {
        ECstrike15UserMessages::CS_UM_VGUIMenu
    }
}

impl ::protobuf::reflect::ProtobufValue for ECstrike15UserMessages {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ECSUsrMsg_DisconnectToLobby_Action {
    k_ECSUsrMsg_DisconnectToLobby_Action_Default = 0,
    k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue = 1,
}

impl ::protobuf::ProtobufEnum for ECSUsrMsg_DisconnectToLobby_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECSUsrMsg_DisconnectToLobby_Action> {
        match value {
            0 => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default),
            1 => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ECSUsrMsg_DisconnectToLobby_Action] = &[
            ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default,
            ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ECSUsrMsg_DisconnectToLobby_Action", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ECSUsrMsg_DisconnectToLobby_Action {
}

impl ::std::default::Default for ECSUsrMsg_DisconnectToLobby_Action {
    fn default() -> Self {
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default
    }
}

impl ::protobuf::reflect::ProtobufValue for ECSUsrMsg_DisconnectToLobby_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1ccstrike15_usermessages.proto\x1a\x20google/protobuf/descriptor.pro\
    to\x1a\x11netmessages.proto\x1a\x1acstrike15_gcmessages.proto\"\xa2\x01\
    \n\x12CCSUsrMsg_VGUIMenu\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x12\n\x04show\x18\x02\x20\x01(\x08R\x04show\x124\n\x07subkeys\x18\
    \x03\x20\x03(\x0b2\x1a.CCSUsrMsg_VGUIMenu.SubkeyR\x07subkeys\x1a.\n\x06S\
    ubkey\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x10\n\x03str\x18\
    \x02\x20\x01(\tR\x03str\"(\n\x10CCSUsrMsg_Geiger\x12\x14\n\x05range\x18\
    \x01\x20\x01(\x05R\x05range\"'\n\x0fCCSUsrMsg_Train\x12\x14\n\x05train\
    \x18\x01\x20\x01(\x05R\x05train\"'\n\x11CCSUsrMsg_HudText\x12\x12\n\x04t\
    ext\x18\x01\x20\x01(\tR\x04text\"v\n\x11CCSUsrMsg_SayText\x12\x17\n\x07e\
    nt_idx\x18\x01\x20\x01(\x05R\x06entIdx\x12\x12\n\x04text\x18\x02\x20\x01\
    (\tR\x04text\x12\x12\n\x04chat\x18\x03\x20\x01(\x08R\x04chat\x12\x20\n\
    \x0btextallchat\x18\x04\x20\x01(\x08R\x0btextallchat\"\x96\x01\n\x12CCSU\
    srMsg_SayText2\x12\x17\n\x07ent_idx\x18\x01\x20\x01(\x05R\x06entIdx\x12\
    \x12\n\x04chat\x18\x02\x20\x01(\x08R\x04chat\x12\x19\n\x08msg_name\x18\
    \x03\x20\x01(\tR\x07msgName\x12\x16\n\x06params\x18\x04\x20\x03(\tR\x06p\
    arams\x12\x20\n\x0btextallchat\x18\x05\x20\x01(\x08R\x0btextallchat\"D\n\
    \x11CCSUsrMsg_TextMsg\x12\x17\n\x07msg_dst\x18\x01\x20\x01(\x05R\x06msgD\
    st\x12\x16\n\x06params\x18\x03\x20\x03(\tR\x06params\"\xb3\x02\n\x10CCSU\
    srMsg_HudMsg\x12\x18\n\x07channel\x18\x01\x20\x01(\x05R\x07channel\x12\
    \x1f\n\x03pos\x18\x02\x20\x01(\x0b2\r.CMsgVector2DR\x03pos\x12\x1d\n\x04\
    clr1\x18\x03\x20\x01(\x0b2\t.CMsgRGBAR\x04clr1\x12\x1d\n\x04clr2\x18\x04\
    \x20\x01(\x0b2\t.CMsgRGBAR\x04clr2\x12\x16\n\x06effect\x18\x05\x20\x01(\
    \x05R\x06effect\x12\x20\n\x0cfade_in_time\x18\x06\x20\x01(\x02R\nfadeInT\
    ime\x12\"\n\rfade_out_time\x18\x07\x20\x01(\x02R\x0bfadeOutTime\x12\x1b\
    \n\thold_time\x18\t\x20\x01(\x02R\x08holdTime\x12\x17\n\x07fx_time\x18\n\
    \x20\x01(\x02R\x06fxTime\x12\x12\n\x04text\x18\x0b\x20\x01(\tR\x04text\"\
    \x8e\x01\n\x0fCCSUsrMsg_Shake\x12\x18\n\x07command\x18\x01\x20\x01(\x05R\
    \x07command\x12'\n\x0flocal_amplitude\x18\x02\x20\x01(\x02R\x0elocalAmpl\
    itude\x12\x1c\n\tfrequency\x18\x03\x20\x01(\x02R\tfrequency\x12\x1a\n\
    \x08duration\x18\x04\x20\x01(\x02R\x08duration\"|\n\x0eCCSUsrMsg_Fade\
    \x12\x1a\n\x08duration\x18\x01\x20\x01(\x05R\x08duration\x12\x1b\n\thold\
    _time\x18\x02\x20\x01(\x05R\x08holdTime\x12\x14\n\x05flags\x18\x03\x20\
    \x01(\x05R\x05flags\x12\x1b\n\x03clr\x18\x04\x20\x01(\x0b2\t.CMsgRGBAR\
    \x03clr\"R\n\x10CCSUsrMsg_Rumble\x12\x14\n\x05index\x18\x01\x20\x01(\x05\
    R\x05index\x12\x12\n\x04data\x18\x02\x20\x01(\x05R\x04data\x12\x14\n\x05\
    flags\x18\x03\x20\x01(\x05R\x05flags\"i\n\x16CCSUsrMsg_CloseCaption\x12\
    \x12\n\x04hash\x18\x01\x20\x01(\rR\x04hash\x12\x1a\n\x08duration\x18\x02\
    \x20\x01(\x05R\x08duration\x12\x1f\n\x0bfrom_player\x18\x03\x20\x01(\x08\
    R\nfromPlayer\"o\n\x1cCCSUsrMsg_CloseCaptionDirect\x12\x12\n\x04hash\x18\
    \x01\x20\x01(\rR\x04hash\x12\x1a\n\x08duration\x18\x02\x20\x01(\x05R\x08\
    duration\x12\x1f\n\x0bfrom_player\x18\x03\x20\x01(\x08R\nfromPlayer\"6\n\
    \x13CCSUsrMsg_SendAudio\x12\x1f\n\x0bradio_sound\x18\x01\x20\x01(\tR\nra\
    dioSound\"\x85\x01\n\x12CCSUsrMsg_RawAudio\x12\x14\n\x05pitch\x18\x01\
    \x20\x01(\x05R\x05pitch\x12\x16\n\x06entidx\x18\x02\x20\x01(\x05R\x06ent\
    idx\x12\x1a\n\x08duration\x18\x03\x20\x01(\x02R\x08duration\x12%\n\x0evo\
    ice_filename\x18\x04\x20\x01(\tR\rvoiceFilename\"\xd8\x01\n\x13CCSUsrMsg\
    _VoiceMask\x12B\n\x0cplayer_masks\x18\x01\x20\x03(\x0b2\x1f.CCSUsrMsg_Vo\
    iceMask.PlayerMaskR\x0bplayerMasks\x12*\n\x11player_mod_enable\x18\x02\
    \x20\x01(\x08R\x0fplayerModEnable\x1aQ\n\nPlayerMask\x12&\n\x0fgame_rule\
    s_mask\x18\x01\x20\x01(\x05R\rgameRulesMask\x12\x1b\n\tban_masks\x18\x02\
    \x20\x01(\x05R\x08banMasks\"\x90\x01\n\x10CCSUsrMsg_Damage\x12\x16\n\x06\
    amount\x18\x01\x20\x01(\x05R\x06amount\x12;\n\x13inflictor_world_pos\x18\
    \x02\x20\x01(\x0b2\x0b.CMsgVectorR\x11inflictorWorldPos\x12'\n\x0fvictim\
    _entindex\x18\x03\x20\x01(\x05R\x0evictimEntindex\"y\n\x13CCSUsrMsg_Radi\
    oText\x12\x17\n\x07msg_dst\x18\x01\x20\x01(\x05R\x06msgDst\x12\x16\n\x06\
    client\x18\x02\x20\x01(\x05R\x06client\x12\x19\n\x08msg_name\x18\x03\x20\
    \x01(\tR\x07msgName\x12\x16\n\x06params\x18\x04\x20\x03(\tR\x06params\"(\
    \n\x12CCSUsrMsg_HintText\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"\
    -\n\x15CCSUsrMsg_KeyHintText\x12\x14\n\x05hints\x18\x01\x20\x03(\tR\x05h\
    ints\"\xcf\x03\n$CCSUsrMsg_ProcessSpottedEntityUpdate\x12\x1d\n\nnew_upd\
    ate\x18\x01\x20\x01(\x08R\tnewUpdate\x12`\n\x0eentity_updates\x18\x02\
    \x20\x03(\x0b29.CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\
    R\rentityUpdates\x1a\xa5\x02\n\x13SpottedEntityUpdate\x12\x1d\n\nentity_\
    idx\x18\x01\x20\x01(\x05R\tentityIdx\x12\x19\n\x08class_id\x18\x02\x20\
    \x01(\x05R\x07classId\x12\x19\n\x08origin_x\x18\x03\x20\x01(\x05R\x07ori\
    ginX\x12\x19\n\x08origin_y\x18\x04\x20\x01(\x05R\x07originY\x12\x19\n\
    \x08origin_z\x18\x05\x20\x01(\x05R\x07originZ\x12\x17\n\x07angle_y\x18\
    \x06\x20\x01(\x05R\x06angleY\x12\x18\n\x07defuser\x18\x07\x20\x01(\x08R\
    \x07defuser\x12,\n\x12player_has_defuser\x18\x08\x20\x01(\x08R\x10player\
    HasDefuser\x12\"\n\rplayer_has_c4\x18\t\x20\x01(\x08R\x0bplayerHasC4\"b\
    \n\x1dCCSUsrMsg_SendPlayerItemDrops\x12A\n\x0eentity_updates\x18\x01\x20\
    \x03(\x0b2\x1a.CEconItemPreviewDataBlockR\rentityUpdates\"s\n\x1dCCSUsrM\
    sg_SendPlayerItemFound\x126\n\x08iteminfo\x18\x01\x20\x01(\x0b2\x1a.CEco\
    nItemPreviewDataBlockR\x08iteminfo\x12\x1a\n\x08entindex\x18\x02\x20\x01\
    (\x05R\x08entindex\"\x9b\x01\n\x16CCSUsrMsg_ReloadEffect\x12\x16\n\x06en\
    tidx\x18\x01\x20\x01(\x05R\x06entidx\x12\x18\n\x07actanim\x18\x02\x20\
    \x01(\x05R\x07actanim\x12\x19\n\x08origin_x\x18\x03\x20\x01(\x02R\x07ori\
    ginX\x12\x19\n\x08origin_y\x18\x04\x20\x01(\x02R\x07originY\x12\x19\n\
    \x08origin_z\x18\x05\x20\x01(\x02R\x07originZ\"\xb4\x01\n\x15CCSUsrMsg_W\
    eaponSound\x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\x12\x19\n\
    \x08origin_x\x18\x02\x20\x01(\x02R\x07originX\x12\x19\n\x08origin_y\x18\
    \x03\x20\x01(\x02R\x07originY\x12\x19\n\x08origin_z\x18\x04\x20\x01(\x02\
    R\x07originZ\x12\x14\n\x05sound\x18\x05\x20\x01(\tR\x05sound\x12\x1c\n\t\
    timestamp\x18\x06\x20\x01(\x02R\ttimestamp\"\xa1\x01\n\x1fCCSUsrMsg_Upda\
    teScreenHealthBar\x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\
    \x12'\n\x0fhealthratio_old\x18\x02\x20\x01(\x02R\x0ehealthratioOld\x12'\
    \n\x0fhealthratio_new\x18\x03\x20\x01(\x02R\x0ehealthratioNew\x12\x14\n\
    \x05style\x18\x04\x20\x01(\x05R\x05style\":\n\x20CCSUsrMsg_EntityOutline\
    Highlight\x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\"/\n\x15CC\
    SUsrMsg_AdjustMoney\x12\x16\n\x06amount\x18\x01\x20\x01(\x05R\x06amount\
    \"r\n\x13CCSUsrMsg_ReportHit\x12\x13\n\x05pos_x\x18\x01\x20\x01(\x02R\
    \x04posX\x12\x13\n\x05pos_y\x18\x02\x20\x01(\x02R\x04posY\x12\x1c\n\ttim\
    estamp\x18\x04\x20\x01(\x02R\ttimestamp\x12\x13\n\x05pos_z\x18\x03\x20\
    \x01(\x02R\x04posZ\"v\n\x11CCSUsrMsg_KillCam\x12\x19\n\x08obs_mode\x18\
    \x01\x20\x01(\x05R\x07obsMode\x12!\n\x0cfirst_target\x18\x02\x20\x01(\
    \x05R\x0bfirstTarget\x12#\n\rsecond_target\x18\x03\x20\x01(\x05R\x0cseco\
    ndTarget\"\xd4\x01\n\x1aCCSUsrMsg_DesiredTimescale\x12+\n\x11desired_tim\
    escale\x18\x01\x20\x01(\x02R\x10desiredTimescale\x122\n\x15duration_real\
    time_sec\x18\x02\x20\x01(\x02R\x13durationRealtimeSec\x12+\n\x11interpol\
    ator_type\x18\x03\x20\x01(\x05R\x10interpolatorType\x12(\n\x10start_blen\
    d_time\x18\x04\x20\x01(\x02R\x0estartBlendTime\"A\n\x1aCCSUsrMsg_Current\
    Timescale\x12#\n\rcur_timescale\x18\x01\x20\x01(\x02R\x0ccurTimescale\"m\
    \n\x1aCCSUsrMsg_AchievementEvent\x12\x20\n\x0bachievement\x18\x01\x20\
    \x01(\x05R\x0bachievement\x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05co\
    unt\x12\x17\n\x07user_id\x18\x03\x20\x01(\x05R\x06userId\"\xa3\x01\n\x1c\
    CCSUsrMsg_MatchEndConditions\x12\x1c\n\tfraglimit\x18\x01\x20\x01(\x05R\
    \tfraglimit\x12!\n\x0cmp_maxrounds\x18\x02\x20\x01(\x05R\x0bmpMaxrounds\
    \x12\x1f\n\x0bmp_winlimit\x18\x03\x20\x01(\x05R\nmpWinlimit\x12!\n\x0cmp\
    _timelimit\x18\x04\x20\x01(\x05R\x0bmpTimelimit\"\xcb\x01\n\x1bCCSUsrMsg\
    _PlayerStatsUpdate\x12\x18\n\x07version\x18\x01\x20\x01(\x05R\x07version\
    \x127\n\x05stats\x18\x04\x20\x03(\x0b2!.CCSUsrMsg_PlayerStatsUpdate.Stat\
    R\x05stats\x12\x17\n\x07user_id\x18\x05\x20\x01(\x05R\x06userId\x12\x10\
    \n\x03crc\x18\x06\x20\x01(\x05R\x03crc\x1a.\n\x04Stat\x12\x10\n\x03idx\
    \x18\x01\x20\x01(\x05R\x03idx\x12\x14\n\x05delta\x18\x02\x20\x01(\x05R\
    \x05delta\"O\n\x1aCCSUsrMsg_DisplayInventory\x12\x18\n\x07display\x18\
    \x01\x20\x01(\x08R\x07display\x12\x17\n\x07user_id\x18\x02\x20\x01(\x05R\
    \x06userId\"\xa2\x01\n\x17CCSUsrMsg_QuestProgress\x12\x19\n\x08quest_id\
    \x18\x01\x20\x01(\rR\x07questId\x12#\n\rnormal_points\x18\x02\x20\x01(\r\
    R\x0cnormalPoints\x12!\n\x0cbonus_points\x18\x03\x20\x01(\rR\x0bbonusPoi\
    nts\x12$\n\x0eis_event_quest\x18\x04\x20\x01(\x08R\x0cisEventQuest\"K\n\
    \x1eCCSUsrMsg_ScoreLeaderboardData\x12)\n\x04data\x18\x01\x20\x01(\x0b2\
    \x15.ScoreLeaderboardDataR\x04data\"Y\n%CCSUsrMsg_PlayerDecalDigitalSign\
    ature\x120\n\x04data\x18\x01\x20\x01(\x0b2\x1c.PlayerDecalDigitalSignatu\
    reR\x04data\"O\n\x12CCSUsrMsg_XRankGet\x12\x19\n\x08mode_idx\x18\x01\x20\
    \x01(\x05R\x07modeIdx\x12\x1e\n\ncontroller\x18\x02\x20\x01(\x05R\ncontr\
    oller\"i\n\x12CCSUsrMsg_XRankUpd\x12\x19\n\x08mode_idx\x18\x01\x20\x01(\
    \x05R\x07modeIdx\x12\x1e\n\ncontroller\x18\x02\x20\x01(\x05R\ncontroller\
    \x12\x18\n\x07ranking\x18\x03\x20\x01(\x05R\x07ranking\"F\n\x18CCSUsrMsg\
    _CallVoteFailed\x12\x16\n\x06reason\x18\x01\x20\x01(\x05R\x06reason\x12\
    \x12\n\x04time\x18\x02\x20\x01(\x05R\x04time\"\x8b\x02\n\x13CCSUsrMsg_Vo\
    teStart\x12\x12\n\x04team\x18\x01\x20\x01(\x05R\x04team\x12\x17\n\x07ent\
    _idx\x18\x02\x20\x01(\x05R\x06entIdx\x12\x1b\n\tvote_type\x18\x03\x20\
    \x01(\x05R\x08voteType\x12\x19\n\x08disp_str\x18\x04\x20\x01(\tR\x07disp\
    Str\x12\x1f\n\x0bdetails_str\x18\x05\x20\x01(\tR\ndetailsStr\x12$\n\x0eo\
    ther_team_str\x18\x06\x20\x01(\tR\x0cotherTeamStr\x12#\n\x0eis_yes_no_vo\
    te\x18\x07\x20\x01(\x08R\x0bisYesNoVote\x12#\n\rentidx_target\x18\x08\
    \x20\x01(\x05R\x0centidxTarget\"\x81\x01\n\x12CCSUsrMsg_VotePass\x12\x12\
    \n\x04team\x18\x01\x20\x01(\x05R\x04team\x12\x1b\n\tvote_type\x18\x02\
    \x20\x01(\x05R\x08voteType\x12\x19\n\x08disp_str\x18\x03\x20\x01(\tR\x07\
    dispStr\x12\x1f\n\x0bdetails_str\x18\x04\x20\x01(\tR\ndetailsStr\"B\n\
    \x14CCSUsrMsg_VoteFailed\x12\x12\n\x04team\x18\x01\x20\x01(\x05R\x04team\
    \x12\x16\n\x06reason\x18\x02\x20\x01(\x05R\x06reason\"@\n\x13CCSUsrMsg_V\
    oteSetup\x12)\n\x10potential_issues\x18\x01\x20\x03(\tR\x0fpotentialIssu\
    es\"\xba\x01\n&CCSUsrMsg_SendLastKillerDamageToClient\x12$\n\x0enum_hits\
    _given\x18\x01\x20\x01(\x05R\x0cnumHitsGiven\x12!\n\x0cdamage_given\x18\
    \x02\x20\x01(\x05R\x0bdamageGiven\x12$\n\x0enum_hits_taken\x18\x03\x20\
    \x01(\x05R\x0cnumHitsTaken\x12!\n\x0cdamage_taken\x18\x04\x20\x01(\x05R\
    \x0bdamageTaken\"\xa7\x02\n\x1aCCSUsrMsg_ServerRankUpdate\x12G\n\x0brank\
    _update\x18\x01\x20\x03(\x0b2&.CCSUsrMsg_ServerRankUpdate.RankUpdateR\nr\
    ankUpdate\x1a\xbf\x01\n\nRankUpdate\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\x05R\taccountId\x12\x19\n\x08rank_old\x18\x02\x20\x01(\x05R\x07ran\
    kOld\x12\x19\n\x08rank_new\x18\x03\x20\x01(\x05R\x07rankNew\x12\x19\n\
    \x08num_wins\x18\x04\x20\x01(\x05R\x07numWins\x12\x1f\n\x0brank_change\
    \x18\x05\x20\x01(\x02R\nrankChange\x12\x20\n\x0crank_type_id\x18\x06\x20\
    \x01(\x05R\nrankTypeId\"W\n\x12CCSUsrMsg_XpUpdate\x12A\n\x04data\x18\x01\
    \x20\x01(\x0b2-.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewardedR\x04data\"*\
    \n\x14CCSUsrMsg_ItemPickup\x12\x12\n\x04item\x18\x01\x20\x01(\tR\x04item\
    \"\x82\x01\n\x12CCSUsrMsg_ShowMenu\x12(\n\x10bits_valid_slots\x18\x01\
    \x20\x01(\x05R\x0ebitsValidSlots\x12!\n\x0cdisplay_time\x18\x02\x20\x01(\
    \x05R\x0bdisplayTime\x12\x1f\n\x0bmenu_string\x18\x03\x20\x01(\tR\nmenuS\
    tring\"'\n\x11CCSUsrMsg_BarTime\x12\x12\n\x04time\x18\x01\x20\x01(\tR\
    \x04time\"0\n\x14CCSUsrMsg_AmmoDenied\x12\x18\n\x07ammoIdx\x18\x01\x20\
    \x01(\x05R\x07ammoIdx\"=\n\x19CCSUsrMsg_MarkAchievement\x12\x20\n\x0bach\
    ievement\x18\x01\x20\x01(\tR\x0bachievement\"4\n\x1aCCSUsrMsg_MatchStats\
    Update\x12\x16\n\x06update\x18\x01\x20\x01(\tR\x06update\"B\n\x12CCSUsrM\
    sg_ItemDrop\x12\x16\n\x06itemid\x18\x01\x20\x01(\x03R\x06itemid\x12\x14\
    \n\x05death\x18\x02\x20\x01(\x08R\x05death\"3\n\x19CCSUsrMsg_GlowPropTur\
    nOff\x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\"\x84\x01\n\x1e\
    CCSUsrMsg_RoundBackupFilenames\x12\x14\n\x05count\x18\x01\x20\x01(\x05R\
    \x05count\x12\x14\n\x05index\x18\x02\x20\x01(\x05R\x05index\x12\x1a\n\
    \x08filename\x18\x03\x20\x01(\tR\x08filename\x12\x1a\n\x08nicename\x18\
    \x04\x20\x01(\tR\x08nicename\"^\n\x0eCCSUsrMsg_SSUI\x12\x12\n\x04show\
    \x18\x01\x20\x01(\x08R\x04show\x12\x1d\n\nstart_time\x18\x02\x20\x01(\
    \x02R\tstartTime\x12\x19\n\x08end_time\x18\x03\x20\x01(\x02R\x07endTime\
    \"\xc4\x04\n\x17CCSUsrMsg_SurvivalStats\x12\x12\n\x04xuid\x18\x01\x20\
    \x01(\x04R\x04xuid\x123\n\x05facts\x18\x02\x20\x03(\x0b2\x1d.CCSUsrMsg_S\
    urvivalStats.FactR\x05facts\x128\n\x05users\x18\x03\x20\x03(\x0b2\".CCSU\
    srMsg_SurvivalStats.PlacementR\x05users\x129\n\x07damages\x18\x05\x20\
    \x03(\x0b2\x1f.CCSUsrMsg_SurvivalStats.DamageR\x07damages\x12\x1e\n\ntic\
    knumber\x18\x04\x20\x01(\x05R\nticknumber\x1at\n\x04Fact\x12\x12\n\x04ty\
    pe\x18\x01\x20\x01(\x05R\x04type\x12\x18\n\x07display\x18\x02\x20\x01(\
    \x05R\x07display\x12\x14\n\x05value\x18\x03\x20\x01(\x05R\x05value\x12(\
    \n\x0finterestingness\x18\x04\x20\x01(\x02R\x0finterestingness\x1a]\n\tP\
    lacement\x12\x12\n\x04xuid\x18\x01\x20\x01(\x04R\x04xuid\x12\x1e\n\nteam\
    number\x18\x02\x20\x01(\x05R\nteamnumber\x12\x1c\n\tplacement\x18\x03\
    \x20\x01(\x05R\tplacement\x1av\n\x06Damage\x12\x12\n\x04xuid\x18\x01\x20\
    \x01(\x04R\x04xuid\x12\x0e\n\x02to\x18\x02\x20\x01(\x05R\x02to\x12\x17\n\
    \x07to_hits\x18\x03\x20\x01(\x05R\x06toHits\x12\x12\n\x04from\x18\x04\
    \x20\x01(\x05R\x04from\x12\x1b\n\tfrom_hits\x18\x05\x20\x01(\x05R\x08fro\
    mHits\"*\n\x12CCSUsrMsg_ResetHud\x12\x14\n\x05reset\x18\x01\x20\x01(\x08\
    R\x05reset\"+\n\x13CCSUsrMsg_GameTitle\x12\x14\n\x05dummy\x18\x01\x20\
    \x01(\x05R\x05dummy\".\n\x16CCSUsrMsg_RequestState\x12\x14\n\x05dummy\
    \x18\x01\x20\x01(\x05R\x05dummy\"3\n\x1bCCSUsrMsg_StopSpectatorMode\x12\
    \x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05dummy\"3\n\x1bCCSUsrMsg_Disconn\
    ectToLobby\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05dummy\"0\n\x18CCS\
    UsrMsg_WarmupHasEnded\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05dummy\
    \",\n\x14CCSUsrMsg_ClientInfo\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\
    \x05dummy\"S\n\x1dCCSUsrMsg_ServerRankRevealAll\x122\n\x15seconds_till_s\
    hutdown\x18\x01\x20\x01(\x05R\x13secondsTillShutdown*\xba\r\n\x16ECstrik\
    e15UserMessages\x12\x12\n\x0eCS_UM_VGUIMenu\x10\x01\x12\x10\n\x0cCS_UM_G\
    eiger\x10\x02\x12\x0f\n\x0bCS_UM_Train\x10\x03\x12\x11\n\rCS_UM_HudText\
    \x10\x04\x12\x11\n\rCS_UM_SayText\x10\x05\x12\x12\n\x0eCS_UM_SayText2\
    \x10\x06\x12\x11\n\rCS_UM_TextMsg\x10\x07\x12\x10\n\x0cCS_UM_HudMsg\x10\
    \x08\x12\x12\n\x0eCS_UM_ResetHud\x10\t\x12\x13\n\x0fCS_UM_GameTitle\x10\
    \n\x12\x0f\n\x0bCS_UM_Shake\x10\x0c\x12\x0e\n\nCS_UM_Fade\x10\r\x12\x10\
    \n\x0cCS_UM_Rumble\x10\x0e\x12\x16\n\x12CS_UM_CloseCaption\x10\x0f\x12\
    \x1c\n\x18CS_UM_CloseCaptionDirect\x10\x10\x12\x13\n\x0fCS_UM_SendAudio\
    \x10\x11\x12\x12\n\x0eCS_UM_RawAudio\x10\x12\x12\x13\n\x0fCS_UM_VoiceMas\
    k\x10\x13\x12\x16\n\x12CS_UM_RequestState\x10\x14\x12\x10\n\x0cCS_UM_Dam\
    age\x10\x15\x12\x13\n\x0fCS_UM_RadioText\x10\x16\x12\x12\n\x0eCS_UM_Hint\
    Text\x10\x17\x12\x15\n\x11CS_UM_KeyHintText\x10\x18\x12$\n\x20CS_UM_Proc\
    essSpottedEntityUpdate\x10\x19\x12\x16\n\x12CS_UM_ReloadEffect\x10\x1a\
    \x12\x15\n\x11CS_UM_AdjustMoney\x10\x1b\x12\x19\n\x15CS_UM_UpdateTeamMon\
    ey\x10\x1c\x12\x1b\n\x17CS_UM_StopSpectatorMode\x10\x1d\x12\x11\n\rCS_UM\
    _KillCam\x10\x1e\x12\x1a\n\x16CS_UM_DesiredTimescale\x10\x1f\x12\x1a\n\
    \x16CS_UM_CurrentTimescale\x10\x20\x12\x1a\n\x16CS_UM_AchievementEvent\
    \x10!\x12\x1c\n\x18CS_UM_MatchEndConditions\x10\"\x12\x1b\n\x17CS_UM_Dis\
    connectToLobby\x10#\x12\x1b\n\x17CS_UM_PlayerStatsUpdate\x10$\x12\x1a\n\
    \x16CS_UM_DisplayInventory\x10%\x12\x18\n\x14CS_UM_WarmupHasEnded\x10&\
    \x12\x14\n\x10CS_UM_ClientInfo\x10'\x12\x12\n\x0eCS_UM_XRankGet\x10(\x12\
    \x12\n\x0eCS_UM_XRankUpd\x10)\x12\x18\n\x14CS_UM_CallVoteFailed\x10-\x12\
    \x13\n\x0fCS_UM_VoteStart\x10.\x12\x12\n\x0eCS_UM_VotePass\x10/\x12\x14\
    \n\x10CS_UM_VoteFailed\x100\x12\x13\n\x0fCS_UM_VoteSetup\x101\x12\x1d\n\
    \x19CS_UM_ServerRankRevealAll\x102\x12&\n\"CS_UM_SendLastKillerDamageToC\
    lient\x103\x12\x1a\n\x16CS_UM_ServerRankUpdate\x104\x12\x14\n\x10CS_UM_I\
    temPickup\x105\x12\x12\n\x0eCS_UM_ShowMenu\x106\x12\x11\n\rCS_UM_BarTime\
    \x107\x12\x14\n\x10CS_UM_AmmoDenied\x108\x12\x19\n\x15CS_UM_MarkAchievem\
    ent\x109\x12\x1a\n\x16CS_UM_MatchStatsUpdate\x10:\x12\x12\n\x0eCS_UM_Ite\
    mDrop\x10;\x12\x19\n\x15CS_UM_GlowPropTurnOff\x10<\x12\x1d\n\x19CS_UM_Se\
    ndPlayerItemDrops\x10=\x12\x1e\n\x1aCS_UM_RoundBackupFilenames\x10>\x12\
    \x1d\n\x19CS_UM_SendPlayerItemFound\x10?\x12\x13\n\x0fCS_UM_ReportHit\
    \x10@\x12\x12\n\x0eCS_UM_XpUpdate\x10A\x12\x17\n\x13CS_UM_QuestProgress\
    \x10B\x12\x1e\n\x1aCS_UM_ScoreLeaderboardData\x10C\x12%\n!CS_UM_PlayerDe\
    calDigitalSignature\x10D\x12\x15\n\x11CS_UM_WeaponSound\x10E\x12\x1f\n\
    \x1bCS_UM_UpdateScreenHealthBar\x10F\x12\x20\n\x1cCS_UM_EntityOutlineHig\
    hlight\x10G\x12\x0e\n\nCS_UM_SSUI\x10H\x12\x17\n\x13CS_UM_SurvivalStats\
    \x10I\x12\x1c\n\x18CS_UM_DisconnectToLobby2\x10J*\x88\x01\n\"ECSUsrMsg_D\
    isconnectToLobby_Action\x120\n,k_ECSUsrMsg_DisconnectToLobby_Action_Defa\
    ult\x10\0\x120\n,k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue\x10\x01B\
    \x05H\x01\x80\x01\0\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
